## Randomized Quantum Singular Value Transformation

Xinzhao Wang [∗][1,2], Yuxin Zhang [†‡][3], Soumyabrata Hazra [§][4], Tongyang Li [¶][1,2], Changpeng
Shao [‖][3] and Shantanav Chakraborty [∗∗][4]


1Center on Frontiers of Computing Studies, Peking University, Beijing, China
2School of Computer Science, Peking University, Beijing, China
3SKLMS, Academy of Mathematics and Systems Science, Chinese Academy of Sciences, Beijing, China
4CQST and CSTAR, International Institute of Information Technology Hyderabad, Telangana, India


October 9, 2025


**Abstract**


We introduce the first randomized algorithms for Quantum Singular Value Transformation
(QSVT), a unifying framework for many quantum algorithms. Standard implementations of
QSVT rely on block encodings of the Hamiltonian, which are costly to construct, requiring a
logarithmic number of ancilla qubits, intricate multi-qubit control, and circuit depth scaling
linearly with the number of Hamiltonian terms. In contrast, our algorithms use only a single
ancilla qubit and entirely avoid block encodings. We develop two methods: (i) a direct randomization of QSVT, where block encodings are replaced by importance sampling, and (ii) an
approach that integrates qDRIFT into the generalized quantum signal processing framework,
with the dependence on precision exponentially improved through classical extrapolation. Both
algorithms achieve gate complexity independent of the number of Hamiltonian terms, a hallmark of randomized methods, while incurring only quadratic dependence on the degree of the
target polynomial. We identify natural parameter regimes where our methods outperform even
standard QSVT, making them promising for early fault-tolerant quantum devices. We also
establish a fundamental lower bound showing that the quadratic dependence on the polynomial degree is optimal within this framework. We apply our framework to two fundamental
tasks: solving quantum linear systems and estimating ground-state properties of Hamiltonians,
obtaining polynomial advantages over prior randomized algorithms. Finally, we benchmark
our ground-state property estimation algorithm on electronic structure Hamiltonians and the
transverse-field Ising model with long-range interactions. In both cases, our approach outperforms prior work by several orders of magnitude in circuit depth, establishing randomized QSVT
as a practical and resource-efficient alternative for early fault-tolerant quantum devices.


∗wangxz@stu.pku.edu.cn
†zhangyuxin@amss.ac.cn
‡The first two authors contributed equally.
§soumyabrata.hazra@research.iiit.ac.in
¶tongyangli@pku.edu.cn
‖changpeng.shao@amss.ac.cn
∗∗shchakra@iiit.ac.in


### **Contents**

**1** **Introduction** **1**


**2** **Preliminaries** **3**
2.1 Notations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
2.2 Brief overview of QSVT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
2.3 Generalized quantum signal processing . . . . . . . . . . . . . . . . . . . . . . . . . . 6
2.4 Time-ordered evolution in the interaction picture . . . . . . . . . . . . . . . . . . . . 6
2.5 Richardson extrapolation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
2.6 Hamiltonian simulation by qDRIFT . . . . . . . . . . . . . . . . . . . . . . . . . . . 10


**3** **Randomized algorithms for QSVT** **11**
3.1 A direct randomization of QSVT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
3.2 Randomized QSVT with qDRIFT . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3.2.1 Expectation value with respect to the normalized quantum state . . . . . . . 28


**4** **Lower bounds** **31**


**5** **Applications** **35**
5.1 Quantum linear systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
5.2 Ground state property estimation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37


**6** **Numerical Benchmarking** **40**
6.1 Quantum chemistry Hamiltonians . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
6.2 Transverse-field Ising model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
6.2.1 Long-range Transverse Ising field Ising chain . . . . . . . . . . . . . . . . . . 43
6.2.2 Transverse field Ising model with hybrid XX-ZZ interactions . . . . . . . . . 45


**7** **Discussion** **47**


**A Some polynomial approximation results** **48**


**B Properties of the Transverse-Field Ising Model Hamiltonian** **52**
B.1 Spectral gap of the Transverse-field Ising Hamiltonian with long-range interactions . 52
B.2 Pre-factor scaling of higher order Trotterization for Ising Hamiltonians with hybrid
interactions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54


**C Randomized QSVT for density operators** **58**


i


### **1 Introduction**



Quantum singular value transformation (QSVT) [1] has emerged as a central paradigm in quantum
algorithms, unifying and extending many of the most powerful techniques. At its core, QSVT
enables polynomial transformations of the singular values of an operator, provided the operator
is embedded as the top-left block of a unitary, known as a block encoding [2, 3]. This simple but
versatile abstraction subsumes a broad class of prior methods and provides a systematic framework
for designing new algorithms. Consequently, QSVT underlies state-of-the-art approaches to widely
studied problems of practical interest, including Hamiltonian simulation [2, 4], solving quantum
linear systems [1, 5], linear regression and quantum machine learning [3, 6], quantum walks [1, 7],
and optimization [8–10]. It further serves as the key subroutine in many recent advances in quantum
algorithms [11].
Despite its power, QSVT suffers from two major bottlenecks that limit its near-term implementability, even on early fault-tolerant quantum devices. The first is its reliance on block encodings, which can be costly to construct. For instance, consider an _n_ -qubit Hamiltonian of the
form



_H_ =



_L_




_λkHk,_ (1.1)

_k_ =1



where each _Hk_ is unitary (or Hermitian) with _∥Hk∥_ = 1, and the total weight of the coefficients _λ_ =

_k_ _[|][λ][k][|]_ [. Such Hamiltonians are ubiquitous in condensed matter [][12][], high-energy physics [][13][–][15][],]
and quantum chemistry [16–20]. A block encoding of any such _H_ is typically obtained via the Linear
Combination of Unitaries (LCU) method, using _O_ (log _L_ ) ancilla qubits and a series of complicated
controlled operations. Moreover, it was recently shown that this logarithmic ancilla overhead is
unavoidable in general [21]. Consequently, implementing a degree- _d_ polynomial transformation via
QSVT results in circuit depth scaling as _O_ ( _Lλd_ ), while also incurring an _O_ (log _L_ ) ancilla overhead.

[�]
The second bottleneck is the explicit linear dependence on _L_, which can be prohibitively large
for many Hamiltonians of practical interest, particularly those arising in quantum chemistry [16–20]
and high-energy physics [13,14]. This challenge has motivated growing interest in randomized quantum algorithms, which can eliminate the dependence on _L_ . The key idea is to replace deterministic
constructions, such as Trotter decompositions [22, 23] or LCU [24], with randomized procedures
that reproduce the desired evolution in expectation. Notable examples include qDRIFT [17, 25]
and qSWIFT [26] for Hamiltonian simulation, randomized LCU methods [27, 28] for more general
transformations, and randomized implementations of linear combination of Hamiltonian simulation [29].
There has been growing interest in designing algorithms tailored to early fault-tolerant quantum
devices, where the number of logical qubits is limited, ancilla qubits are scarce, and multi-qubit
controlled gates remain expensive or unavailable [30–34]. In this regime, resource-efficient methods
for broad algorithmic paradigms are of critical importance. Recent progress has been achieved
for the LCU framework, yielding algorithms with very low hardware overhead and applications
to problems of practical interest [27, 28]. However, these approaches achieve only sub-optimal
total complexity. Since QSVT is a more general paradigm, encompassing LCU and many other
techniques, developing early fault-tolerant algorithms for QSVT is even more pressing. A recent
advance in this direction is the work of [21], which introduced a QSVT algorithm based on higherorder Trotterization [23] combined with classical extrapolation. Their method achieves circuit depth
_O_ �( _Lλd_ [1+] _[o]_ [(1)] ), which is nearly optimal, while avoiding block encodings and using only a single ancilla
qubit. This resolves the first bottleneck (block-encoding and ancilla overhead), but the second
(linear dependence on _L_ ) remains. Moreover, the use of higher-order Trotter–Suzuki decompositions


1


introduces an additional challenge: the prefactor in the gate complexity grows exponentially with
the order 2 _k_ . In practice, only second-order ( _k_ = 1) and fourth-order ( _k_ = 2) formulas are typically
feasible [17], leading to complexities scaling as _∼_ _Ld_ [3] _[/]_ [2] and _∼_ _Ld_ [5] _[/]_ [4], respectively.
In this work, we develop the first randomized quantum algorithms for QSVT, simultaneously
overcoming both bottlenecks described above. We introduce two distinct approaches. The first
is a direct randomization of the standard QSVT framework. For Hamiltonians with an LCU
decomposition, we incorporate stochastic sampling into the construction, thereby preserving the
alternating-phase structure of QSVT while replacing costly block encodings with randomly sampled
unitaries. Conceptually, this establishes the feasibility of randomized block encoding. However, it
also inherits certain inefficiencies of prior randomized approaches [21,28,31], most notably the need
for a suboptimal number of classical repetitions in regimes where block-encoding-based QSVT
benefits from amplitude amplification.
Our second algorithm overcomes these limitations by embedding qDRIFT-based Hamiltonian
simulation [17] into the framework of generalized quantum signal processing (GQSP) [35, 36]. This
formulation applies to any Hamiltonian expressible as a linear combination of Hermitian operators
(LCH). [1] Building on the interleaved-sequence circuit framework of [21], we consider general quantum circuits that alternate between arbitrary unitaries and Hamiltonian evolution operators, with
GQSP (and consequently, QSVT) arising as a special case. Our second algorithm estimates the expectation value of any observable with respect to the output of such circuits, substituting qDRIFT
in place of exact time-evolutions. A naive substitution, however, would inherit the intrinsic 1 _/ε_
precision scaling of qDRIFT [17], resulting in prohibitively large circuit depths. To overcome this,
we incorporate Richardson extrapolation [37] in a novel way, suppressing the error and yielding an
end-to-end procedure with exponentially improved precision scaling.
Importantly, this result does not follow directly from prior work on Hamiltonian simulation
with classical extrapolation [38, 39]. Our main technical contribution is to establish an upper
bound on the diamond-norm distance between two states: one obtained from any interleaved sequence of qDRIFT-based Hamiltonian simulation and arbitrary unitaries, and the other from the
corresponding ideal interleaved circuit with exact time evolutions. We show that this distance can
be expressed explicitly in terms of the parameters of the qDRIFT channel, which in turn enables us
to bound the time-dependent error in expectation values of arbitrary observables. By judiciously
tuning these parameters through Richardson extrapolation, we reduce the precision dependence
from 1 _/ε_ to polylog(1 _/ε_ ), thereby achieving substantially shorter circuit depths.
As a result, our second randomized algorithm is both more powerful and more versatile in practice, capable of implementing polynomial transformations with asymptotically better performance
than prior randomized approaches. Crucially, both of our algorithms preserve the same core advantages: they require only a single ancilla qubit, achieve circuit depth _O_ ( _λ_ [2] _d_ [2] ) independent of the

[�]
number of Hamiltonian terms _L_, and completely eliminate the need for block encodings.
We also establish a matching lower bound, proving that a quadratic dependence on the polynomial degree is unavoidable for any randomized procedure that samples each _Hk_ with probability
_|λk|/λ_ . This lower bound is fundamental: it applies not only to algorithms for implementing generic
polynomial transformations within this access model, but also extends naturally to other prominent
randomized approaches, including Hamiltonian simulation via qDRIFT [17, 40] and qSWIFT [26],
as well as randomized LCU approaches [27, 28].
The advantages of our second algorithm are demonstrated through two broad applications:
quantum linear systems and ground-state property estimation. In both cases, it delivers significant


1Since Pauli operators are both unitary and Hermitian, for any Hamiltonian written in terms of its Pauli decomposition, i.e. _H_ = [�] _k_ _[L]_ =1 _[λ][k][P][k]_ [, where] _[ P][k][ ∈{][I, X, Y, Z][}]_ [, the notions of LCU and LCH coincide.]


2


polynomial improvements over randomized LCU-based methods [27, 28]: the linear systems algorithm yields a fourth-power improvement in the condition number of _H_, while the ground-state
property estimation algorithm achieves a quadratic improvement in the dependence on the overlap
between the initial “guess” state and the true ground state. More broadly, both of our algorithms
are resource-efficient, and there exist natural parameter regimes where they even outperform standard, block encoding-based QSVT.
To complement our theoretical results, we benchmark randomized QSVT for ground-state property estimation on two classes of Hamiltonians: electronic structure problems [41] and spin models
with long-range interactions [42]. In both settings, our methods exhibit substantial practical advantages as compared to block encoding-based standard QSVT [10], recent early fault-tolerant
quantum algorithms [30], as well as other randomized approaches [27, 28]. For molecular Hamiltonians such as propane, carbon dioxide, and ethane, randomized QSVT achieves orders-of-magnitude
reductions in circuit depth compared to prior work. Similarly, for one-dimensional transverse-field
Ising models with long-range or hybrid interactions, we observe improvements in scaling with the
system size, resulting in concrete reductions in gate complexity as observed in numerical simulations. These results underscore the practical relevance of randomized QSVT for early fault-tolerant
quantum devices, where reducing circuit depth is paramount. Taken together, our results establish a resource-efficient framework for randomized quantum algorithms that is optimal within this
access model and broadly applicable to problems of practical interest.
The remainder of this article is organized as follows. In Sec. 2, we introduce the notation
used throughout the paper and review preliminary concepts that form the basis of our algorithms.
Sec. 3 presents our randomized quantum algorithms for QSVT, and Sec. 4 establishes matching
lower bounds. Applications to quantum linear systems and ground-state property estimation are
discussed in Sec. 5, and we provide numerical benchmarks of our algorithm for the latter task on
Hamiltonians from quantum chemistry and condensed matter physics in Sec. 6. Finally, Sec. 7
summarizes our contributions and outlines promising directions for future research.

### **2 Preliminaries**


In this section, we introduce the notation used throughout this work and the preliminary techniques
and algorithms that underlie our results.


**2.1** **Notations**


We use N = Z _>_ 0 and T = _{z ∈_ C : _|z|_ = 1 _}_ . We use _O_ [�] ( _·_ ) to hide polylogarithmic factors, i.e.,
_O_ �( _f_ ( _n_ )) = _O_ ( _f_ ( _n_ ) polylog( _f_ ( _n_ ))). Bold lowercase letters denote vectors, for example, _**a**_ denotes
( _a_ 1 _, . . ., an_ ). _∥· ∥_ 1 denotes the vector _ℓ_ 1-norm, i.e., _∥_ _**a**_ _∥_ 1 = [�] _i_ _[n]_ =1 _[|][a][i][|]_ [. Unless otherwise specified,]
_∥A∥_ denotes the spectral norm of an operator _A_ . For operators _A, B_, we write _A ≈ε B_ if they are
_ε_ -close in spectral norm, i.e., _∥A −_ _B∥≤_ _ε_ . _Mn_ (C) denotes the space of _n × n_ complex matrices.
For _A, B ∈_ _Mn_ (C), we define ad _B_ ( _A_ ) = [ _B, A_ ] = _BA −_ _A√B_, so that _e_ [ad] _[B]_ ( _A_ ) = _e_ _[B]_ _Ae_ _[−][B]_ . The trace
of an operator _A_ is denoted by Tr[ _A_ ], and _∥A∥_ 1 := Tr[ _A_ _[†]_ _A_ ] denotes the Schatten 1-norm, also

called the trace norm. For a quantum channel _E_ : _Mn_ (C) _→_ _Mn_ (C), its diamond norm is defined
as
_∥E∥⋄_ := max
_ρ_ : _∥ρ∥_ 1 _≤_ 1 _[∥]_ [(] _[E ⊗]_ _[I][n]_ [) (] _[ρ]_ [)] _[∥]_ [1] _[,]_


where _ρ ∈_ _Mn_ 2(C). For _f_ ( _x_ ) : [ _a, b_ ] _→_ C, we denote _∥f_ _∥_ [ _a,b_ ] = max _x∈_ [ _a,b_ ] _|f_ ( _x_ ) _|._


3


The expectation value of a random variable _V_ is denoted by E[ _V_ ]. The probability of an event
_E_ is denoted by Pr[ _E_ ]. The Pauli matrices are



�1 0
_I_ =
0 1




- �0 1
_,_ _X_ =
1 0




- �0 _−_ i
_,_ _Y_ =
i 0




- �1 0
_,_ _Z_ =
0 _−_ 1




_._



Any matrix _A ∈_ _M_ 2 _[n]_ (C) can be uniquely expressed as a linear combination of tensor products of
Pauli matrices:

      _A_ = _λP P,_ _λP_ = [1] [Tr[] _[A][†][P]_ []] _[.]_




 
_λP P,_ _λP_ = [1]

2

_P_ _∈{I,X,Y,Z}_ _[⊗][n]_




[Tr[] _[A][†][P]_ []] _[.]_
2 _[n]_



If _A_ is Hermitian, then _λP ∈_ R. For any unitary matrix _U_, there exists a unique skew-Hermitian
matrix _V_ with eigenvalues in ( _−_ i _π,_ i _π_ ] such that _e_ _[V]_ = _U_, and we denote _V_ by log( _U_ ).
Throughout this article, the _time complexity_ of a quantum algorithm refers to the number of
elementary gates used to implement the algorithm.


**2.2** **Brief overview of QSVT**


We begin by recalling the standard framework of quantum singular value transformation (QSVT).
At its core, QSVT provides a systematic way to implement polynomial transformations of the
singular values of a matrix, provided the matrix is embedded as the top-left block of a larger unitary,
known as a block encoding. This idea generalizes the earlier framework of quantum signal processing
(QSP) [4], which achieves polynomial transformations of single-qubit rotations. Formally, QSP is
summarized by the following lemma:



**Lemma 2.1** (QSP, Corollary 8 of [1]) **.** _Let P_ ( _x_ ) _∈_ C[ _x_ ] _be a degree-d polynomial of parity-_ ( _d_ mod 2) _,_
_satisfying ∥P_ ( _x_ ) _∥_ [ _−_ 1 _,_ 1] _≤_ 1 _and |P_ ( _x_ ) _| >_ 1 _for all x /∈_ [ _−_ 1 _,_ 1] _. Then there exists_ Φ = ( _ϕ_ 1 _, . . ., ϕd_ ) _∈_
R _[d]_ _such that_
_d_

                      -                      
      -      - [i] _[ϕ]_ _[Z]_ [�] _P_ ( _x_ ) _∗_




_._



_j_ =1




       
- _P_ ( _x_ ) _∗_
_R_ ( _x_ ) _e_ [i] _[ϕ][j]_ _[Z]_ [�] =
_∗_ _∗_



_where_



_√_

    - _x_
_R_ ( _x_ ) = _√_



_x_ 1 _−_ _x_ [2]

_√_




(2.1)



1 _−_ _x_ [2] _−x_



_is the single-qubit reflection operator defined for x ∈_ [ _−_ 1 _,_ 1] _. Moreover, if P_ ( _x_ ) _is real, then there_
_exists a complex polynomial_ _P_ [˜] ( _x_ ) _with_ Re( _P_ [˜] ( _x_ )) = _P_ ( _x_ ) _, so that the interleaved gate product can_
_also implement real polynomials._


Block encoding [1–3] plays a central role in extending this single-qubit procedure to arbitrary
operators:


**Definition 2.2** (Block encoding) **.** Let _H_ be an operator acting on _s_ qubits, _α, ε >_ 0 and _a ∈_ N,
then we say that the ( _s_ + _a_ )-qubit unitary _U_ is an ( _α, a, ε_ )-block-encoding of _H_, if


_∥H −_ _α_ ( _⟨_ 0 _[a]_ _| ⊗_ _I_ ) _U_ ( _|_ 0 _[a]_ _⟩⊗_ _I_ ) _∥≤_ _ε._


That is,



_U ≈ε_




 - _H/α_ _∗_ 
_._

_∗_ _∗_


4


Given access to such a block encoding, QSVT provides a general procedure to implement polynomial transformations of the singular values of _H_ . This is formalized via the notion of singular
value transformation:


**Definition 2.3** (Singular value transformation) **.** Let _P_ : R _→_ C be an even or odd polynomial.
Let _H ∈_ C _[m][×][n]_ be a matrix with singular value decomposition _H_ = [�] _i_ _[n]_ =1 _[σ][i][|][u][i][⟩⟨][v][i][|]_ [ with] _[ σ][i]_ [ := 0]
when _i >_ min( _m, n_ ). We define the singular value transformation corresponding to _P_ as



_P_ ( _H_ ) :=









- _ni_ =1 _[P]_ [ (] _[σ][i]_ [)] _[ |][u][i][⟩⟨][v][i][|]_ if _P_ is odd,

- _ni_ =1 _[P]_ [ (] _[σ][i]_ [)] _[ |][v][i][⟩⟨][v][i][|]_ if _P_ is even.







To achieve such transformations, QSVT employs alternating phase sequences _U_ Φ, which interleave the block encoding _U_ with controlled single-qubit rotations:


**Definition 2.4** (Definition 8 of [1]) **.** Let _HU_ be a finite dimensional Hilbert space and _U,_ Π _,_ Π [�] _∈_
End ( _HU_ ) be linear operators such that _U_ is unitary and Π _,_ Π are orthogonal projectors. [�] Let
Φ = ( _ϕ_ 1 _, . . ., ϕd_ ) _∈_ R _[d]_, we define the alternating phase modulation sequences _U_ Φ as follows



_U_ Φ :=










        -        _e_ [i] _[ϕ]_ [1][(2][Π][�] _[−][I]_ [)] _U_ [�] _j_ [(] _[d]_ =1 _[−]_ [1)] _[/]_ [2] _e_ [i] _[ϕ]_ [2] _[j]_ [(2Π] _[−][I]_ [)] _U_ _[†]_ _e_ [i] _[ϕ]_ [2] _[j]_ [+1][(2][Π][�] _[−][I]_ [)] _U_ _,_ if _d_ is odd,



(2.2)

- _d/j_ =12 - _e_ [i] _[ϕ]_ [2] _[j][−]_ [1][(2Π] _[−][I]_ [)] _U_ _[†]_ _e_ [i] _[ϕ]_ [2] _[j]_ [(2][Π][�] _[−][I]_ [)] _U_ - _,_ if _d_ is even.








The key theorem of QSVT shows that such sequences can realize polynomial transformations
of the singular values of the block-encoded operator:


**Lemma 2.5** (QSVT, Theorem 10 of [1]) **.** _Assume that P_ ( _x_ ) _∈_ C[ _x_ ] _satisfies the conditions in_
_Lemma 2.1, then there exists_ Φ _∈_ R _[d]_ _such that_



_P_ (Π [�] _U_ Π) =



��Π _U_ ΦΠ _if d is odd,_
Π _U_ ΦΠ _if d is even._




          - _I_ 0�
Intuitively, if Π = Π = _,_ then Lemma 2.5 states that

[�] 0 0




   - _P_ ( _H/α_ ) _∗_
_U_ Φ =
_∗_ _∗_




- - _H/α_ _∗_
_,_ if _U_ =
_∗_ _∗_




_._



Despite its generality, QSVT crucially relies on the efficient construction of block encodings, which
is often costly. For Hamiltonians of the form



_H_ =



_L_


_λkHk,_

_k_ =1



with _∥Hk∥_ = 1, a block encoding of _H/λ_ can be built using the LCU technique [43], typically
requiring _O_ (log _L_ ) ancilla qubits. Recent results show that this ancilla requirement is unavoidable

[21]. Moreover, the LCU procedure entails a circuit depth of _O_ ( _L_ ), yielding an overall cost of
_O_ �( _Lλd_ ). These overheads (large ancilla requirements and linear dependence on _L_ ) constitute the
main bottlenecks of standard QSVT and severely limit its practicality on near-term and early faulttolerant devices. Our first algorithm is a direct randomized variant of QSVT, which replaces block
encodings with randomly sampled unitaries.


5


**2.3** **Generalized quantum signal processing**


In standard QSVT, the implementable polynomials are restricted to being either complex-even or
complex-odd. While real polynomials can also be realized, this typically requires additional ancilla
qubits. The recently introduced framework of quantum phase processing [35], or equivalently
generalized quantum signal processing (GQSP) [36], significantly extends this setting: by allowing
access to controlled Hamiltonian evolution, it enables the implementation of arbitrary polynomials
bounded within the complex unit circle, including Laurent polynomials (polynomials with both
negative and positive powers) of the time evolution operator, without requiring additional ancilla
qubits. Next, we outline key results used in this work and refer the reader to [36] for further details.
Formally, suppose we can query the controlled Hamiltonian simulation unitaries




                - _U_ 0
_c_ 0- _U_ =
0 _I_


where _U_ = _e_ [i] _[H]_ and _U_ _[†]_ = _e_ _[−]_ [i] _[H]_ . Let




- - _I_ 0
_,_ _c_ 1- _U_ _[†]_ =
0 _U_ _[†]_




_,_ (2.3)


 _⊗_ _I,_




     - _e_ [i(] _[λ]_ [+] _[ϕ]_ [)] cos( _θ_ ) _e_ [i] _[ϕ]_ sin( _θ_ )
_R_ ( _θ, ϕ, λ_ ) =
_e_ [i] _[λ]_ sin( _θ_ ) _−_ cos( _θ_ )



be arbitrary _U_ (2) rotation of the single ancilla qubit. Motlagh and Wiebe [36] showed that for
any degree- _d_ Laurent polynomial _P_ satisfying _|P_ ( _x_ ) _| ≤_ 1 on T := _{x ∈_ C : _|x|_ = 1 _}_, there exists
an interleaved sequence of _R_ ( _θj, ϕj,_ 0) and _c_ 0- _U_, _c_ 1- _U_ _[†]_, of length 2 _d_ + 1, that implements a block
encoding of _P_ ( _U_ ). We restate the result below:



**Theorem 2.6** (Combining Corollary 5 and Theorem 6 of [36]) **.** _For any Laurent polynomial P_ ( _z_ ) =

- _d_
_j_ = _−d_ _[a][j][z][j][ such that][ |][P]_ [(] _[z]_ [)] _[| ≤]_ [1] _[ for all][ z][ ∈]_ [T] _[, there exist]_ [ Θ = (] _[θ][j]_ [)] _[j][,]_ [ Φ = (] _[ϕ][j]_ [)] _[j][ ∈]_ [R][2] _[d]_ [+1] _[, λ][ ∈]_ [R]
_such that_


_d_ _d_

     -     _P_ ( _U_ ) _∗_     -     -     -     _∗_ _∗_ = _R_ ( _θd_ + _j, ϕd_ + _j,_ 0) _c_ 1 _-U_ _[†]_ [��] _R_ ( _θj, ϕj,_ 0) _c_ 0 _-U_ _R_ ( _θ_ 0 _, ϕ_ 0 _, λ_ ) _._ (2.4)



_d_ _d_

- 
_R_ ( _θd_ + _j, ϕd_ + _j,_ 0) _c_ 1 _-U_ _[†]_ [��]

_j_ =1 _j_ =1



_d_


  -  =




- 
_R_ ( _θj, ϕj,_ 0) _c_ 0 _-U_ _R_ ( _θ_ 0 _, ϕ_ 0 _, λ_ ) _._ (2.4)

_j_ =1



Recently, it was shown that many commonly used functions can be approximated by Laurent
polynomials in _e_ [i] _[kx]_, bounded on T, for some constant _k_ [21]. Standard QSVT implements functions
expressed as polynomials in _x_ that are bounded on [ _−_ 1 _,_ 1]. Ref. [21] further establishes the precise
conditions under which a polynomial _Q_ ( _x_ ) can be approximated by a Laurent polynomial _P_ ( _e_ [i] _[kx]_ ),
bounded on T, with deg( _P_ ) scaling linearly with deg( _Q_ ). Moreover, they prove that near-optimal
complexity can be achieved by implementing the controlled Hamiltonian evolution operators in
GQSP using higher-order Trotterization, combined with classical interpolation to exponentially
reduce the quantum circuit depth.
Our second method extends this line of ideas by developing a fully randomized implementation
of QSVT within the GQSP framework. Specifically, we use qDRIFT (see Sec. 2.6) [17] for implementing Hamiltonian evolution, combined with a novel use of classical extrapolation. The resulting
end-to-end randomized QSVT algorithm (i) avoids block encodings entirely, (ii) requires only a single ancilla qubit, and (iii) achieves circuit depth independent of the number of Hamiltonian terms,
thereby improving on the complexity achieved in [21].


**2.4** **Time-ordered evolution in the interaction picture**


Let _H_ ( _τ_ ) = _A_ ( _τ_ ) + _B_ ( _τ_ ) be a continuous operator-valued function. The time-evolution of _H_ ( _τ_ ) in
the interaction picture of quantum mechanics, can be formally expressed via the following lemma.


6


**Lemma 2.7** ([44, Page 21]) **.** _Let H_ ( _τ_ ) = _A_ ( _τ_ ) + _B_ ( _τ_ ) _be an operator-valued function defined for_
_τ ∈_ R _with continuous summands A_ ( _τ_ ) _and B_ ( _τ_ ) _. Then_


_̸_



�� _t_ 
_A_ ( _τ_ ) d _τ_
0


_̸_



exp _T_


_̸_



�� _t_ 
_H_ ( _τ_ ) d _τ_ = exp _T_
0


_̸_



�� _τ_ 1

_A_ ( _τ_ 2) d _τ_ 2
0


_̸_



�� _τ_ 1

_A_ ( _τ_ 2) d _τ_ 2
0


_̸_




d _τ_ 1


_̸_




_._


_̸_




_·_ exp _T_


_̸_



�� _t_

exp _[−]_ _T_ [1]
0


_̸_




_B_ ( _τ_ 1) exp _T_


_̸_



The lemma, while stated for continuous functions, also holds for piecewise continuous functions,
such as the ones we use in the derivations of the correctness of our second randomized quantum
algorithm for QSVT (see Lemma 3.5).


**2.5** **Richardson extrapolation**


Richardson extrapolation is a classical technique for estimating limits of the form _f_ (0) = lim _x→_ 0 _f_ ( _x_ )
by evaluating _f_ at a finite set of nonzero points _x ∈{s_ 1 _, s_ 2 _, . . ., sm}_ and combining these values
with carefully chosen coefficients. The key idea is to systematically cancel the leading error terms
in the expansion of _f_ ( _x_ ), thereby achieving higher-order accuracy without a corresponding increase
in computational effort. Originally developed for numerical analysis, Richardson extrapolation
has recently found applications in quantum computing, in particular for suppressing discretization
errors in Hamiltonian simulation via Trotter methods and qDRIFT [25, 38].


**Lemma 2.8** (Richardson extrapolation, see [25, 37]) **.** _Suppose that function f_ : R _→_ R _has a series_
_expansion_


_̸_



_f_ ( _x_ ) = _f_ (0) +


_̸_



_∞_


_cix_ _[i]_ _._

_i_ =1


_̸_



_Choose an initial point s ∈_ (0 _,_ 1) _and set points si_ = _srm/ri with positive integers ri for i ∈_ [ _m_ ] _._
_Then, using these m sample points {si_ : _i ∈_ [ _m_ ] _}, we can derive an m-term Richardson extrapolation_


_̸_



_F_ [(] _[m]_ [)] ( _s_ ) =


_̸_



_m_


_bif_ ( _si_ ) (2.5)

_i_ =1


_̸_



_by choosing appropriate coefficients bi to cancel the first m −_ 1 _terms in the series expansion, such_
_that_
_|F_ [(] _[m]_ [)] ( _s_ ) _−_ _f_ (0) _| ≤∥_ **b** _∥_ 1 _|Rm_ ( _s_ ) _|_ = _O_ ( _s_ _[m]_ ) _._


_where_ **b** = ( _b_ 1 _, . . ., bm_ ) _, and Rm_ ( _x_ ) _is a function that only has terms of order O_ ( _x_ _[m]_ ) _and above. In_
_particular, let_


_̸_




- _√_


_̸_



�2

   _,_ _bi_ =


_ℓ̸_ = _i_



1
_,_ (2.6)
1 _−_ _rℓ/ri_

_̸_



_ri_ =

_̸_



8 _m_
_π_ sin( _π_ (2 _i −_ 1) _/_ 8 _m_ )

_̸_



_̸_


_then ∥_ **b** _∥_ 1 = _O_ (log _m_ ) _,_ max _i{ri}_ = _O_ ( _m_ [4] ) _, and_ max _i{ri/rm}_ = _O_ ( _m_ [2] ) _._


Here, we modify _ri_ by first squaring it and then applying the ceiling function, using a rescaling
technique similar to that in [45]. This reduces the rounding error and ensures _t/sj ∈_ Z for any
given _t >_ 0.


7


**Lemma 2.9.** _Suppose that function f_ : R _→_ R _can be decomposed as_


_f_ ( _x_ ) = _Pm_ ( _x_ ) + _Rm_ ( _x_ ) _,_


_where Pm_ ( _x_ ) _is a degree-_ ( _m −_ 1) _polynomial and Rm_ ( _x_ ) _is the remainder. Given any t >_ 0 _and_
_s ∈_ (0 _,_ 1) _, we can choose_


_̸_




_,_


_̸_




   - _m_
_K_ = max


_̸_



_s_


_̸_



_m_ [2] _[t]_

_π_ _[,]_ _s_


_̸_




    
- _K_
_,_ _rj_ =
sin [2] ( _π_ (2 _j −_ 1) _/_ 8 _m_ )


_̸_



_and_


_̸_



_sj_ = _[t]_

_̸_




  _,_ _bj_ =
_rj_

_̸_



_ℓ̸_ = _j_



1
1 _−_ _rℓ/rj_

_̸_



_̸_


_so that ∥_ **b** _∥_ 1 _≤_ _C_ log _m for some absolute constant C, rj_ = _O_ (max _{m_ [3] _, m_ [2] _t/s}/j_ [2] ) _, and_ max _j{sj} ≤_
_s. Then define the m-term Richardson extrapolation_



_̸_


_F_ [(] _[m]_ [)] ( _s_ ) =



_̸_


_m_


_bjf_ ( _sj_ ) _,_ (2.7)

_j_ =1



_̸_


_which satisfies_


_|F_ [(] _[m]_ [)] ( _s_ ) _−_ _f_ (0) _| ≤∥_ **b** _∥_ 1 max _|Rm_ ( _sj_ ) _|._ (2.8)
_j_


_Proof._ The choice of _bj_ ensures to cancel all terms in _Pm_ ( _x_ ), which directly implies Eq. (2.8). Also,
we have


_rj_ = _O_ ( _m_ [2] _K/j_ [2] ) = _O_ (max _{m_ [3] _, m_ [2] _t/s}/j_ [2] ) _,_


and



_̸_


                - _K_
max
_j_ _[{][s][j][}]_ [ =] _[ s][m][ ≤]_ _[t]_ sin [2] ( _π/_ 4)


Now, we upper bound the coefficients _bi_ . Let



_̸_


- _−_ 1 _t_
_≤_
2 _K_ _[≤]_ _[s.]_



_̸_


1
_rj_ _[′]_ [:=]
sin [2] ( _π_ (2 _j −_ 1) _/_ 8 _m_ ) [= Θ(] _[m]_ [2] _[/j]_ [2][)] _[,]_


and then by [37, Theorem 1], the corresponding coefficients _b_ _[′]_ _j_ [satisfy]



_̸_


( _−_ 1) _[j]_ [+1]
_|b_ _[′]_ _j_ _[| ≤]_
���� _m_



_̸_


1) _[j]_ [+1] - _π_ (2 _j −_ 1)

cot
_m_ 8 _m_



_̸_


- [�]
��� = _O_ (1 _/j_ ) _._



_̸_


8 _m_



_̸_


Note that _rj_ satisfies


_rj_ = _⌈Krj_ _[′]_ _[⌉][.]_


We first prove that for any _j ̸_ = _j_ _[′]_, _rj ̸_ = _rj′_ . For any _j ̸_ = _j_ _[′]_, we have



_̸_


_|Krj_ _[′]_ _[−]_ _[Kr]_ _j_ _[′]_ _[′][| ≥]_ _[K]_ [ min]
_x∈_ [1 _,m_ ]



_̸_


_π_ 2 cos( _π_ (2 _x −_ 1) _/_ 8 _m_ )
���� 4 _m_ sin [3] ( _π_ (2 _x −_ 1) _/_ 8 _m_ )


8



_̸_


_π_

_>_
���� _m_ _[K >]_ [ 1] _[.]_



_̸_


_π_

_>_
���� _m_


Therefore, for any _j ̸_ = _j_ _[′]_, _rj ̸_ = _rj_ _[′]_ [, and]


_rj_ = _Krj_ _[′]_ [+] _[ O]_ [(1)] _[,]_


for any _j ∈_ [ _m_ ]. The ratio _γq_ _[′]_ [:=] _[ r]_ _q_ _[′]_ _[/r]_ _j_ _[′]_ [satisfies]


_rq_ _q_ [+] _[ O]_ [(1)] _q_ _q_
_rj_ = _[Kr]_ _Krj_ _[′][′]_ [+] _[ O]_ [(1)] [=] _[ r]_ _rj_ _[′][′]_ (1 + _O_ (1 _/_ ( _mrj_ _[′]_ [) + 1] _[/]_ [(] _[mr]_ _q_ _[′]_ [)) =] _[ r]_ _rj_ _[′][′]_


Then we propagate the error to _bj_ using


_∂b_ _[′]_ _j_ 1
_∂γq_ _[′]_ = _b_ _[′]_ _j_ 1 _−_ _γq_ _[′]_ _._


The relative error of _bj_ satisfies


_̸_


_̸_


_̸_


_̸_



2 2

- - _j_ + _q_
1 + _O_

_m_ [3]


_̸_


_̸_


_̸_


_̸_



2 2

- - _j_ + _q_
1 + _O_


_̸_


_̸_


_̸_


_̸_



��
_._


_̸_


_̸_


_̸_


_̸_



_|bj_ _−_ _b_ _[′]_ _j_ _[|]_ ��
= _O_
_|b_ _[′]_ _j_ _[|]_ _q̸_ = _j_


��
= _O_


_q̸_ = _j_


��
= _O_


_q̸_ = _j_


��
= _O_


_q̸_ = _j_



1 _rq_ _[′]_ [(] _[j]_ [2] [+] _[ q]_ [2][)]

_̸_ (1 _−_ _rq_ _[′]_ _/rj_ _[′]_ [)] _rj_ _[′]_ _[m]_ [3]


_̸_


_̸_


_̸_



_̸_

1 _/rj_ _[′]_

_̸_ 1 _/rq_ _[′]_ _−_ 1 _/rj_ _[′]_


_̸_


_̸_



_̸_

_j_ [2] + _q_ [2]

_m_ [3]

_̸_


_̸_


_̸_



_̸_




_̸_


_̸_


_̸_



_̸_


_̸_

_j_ [2] _j_ [2] + _q_ [2]

_|q_ [2] _−_ _j_ [2] _|_ _m_ [3]

_̸_


_̸_



_̸_


_̸_

_j_ [2]


_̸_


_̸_



_̸_


_̸_




_̸_


_̸_



_̸_


_̸_


_m_ [3]

_̸_


_̸_



_̸_


_̸_


_̸_

_j_ [2]


_̸_



_̸_


_̸_


_̸_


_j_ _j_ + _q_

_|q −_ _j|_ _m_ [3]

_̸_



_̸_


_̸_


_̸_


_m_ [3]

_̸_



_̸_


_̸_


_̸_


_._


_̸_



_̸_


_̸_


_̸_


_̸_


Therefore, the additive error of _∥_ **b** _∥_ 1 can be bounded as



_̸_


_̸_


_̸_


_̸_


- _[m]_ _|b_ _[′]_ _j_ _[|]_ - - _[j][−]_ [1]

_j_ =1 _q_ =1



_̸_


_̸_


_̸_


_̸_


_∥_ **b** _−_ **b** _[′]_ _∥_ 1 = _O_ - - _[m]_



_̸_


_̸_


_̸_


_̸_


_m_



_q_ = _j_ +1


_m_



_q_ = _j_ +1



_̸_


_̸_


_̸_


_̸_


_j_ [2] _q_

_q −_ _j_ _m_ [3]






_̸_


_̸_


_̸_


_̸_


��



_̸_


_̸_


_̸_


_̸_


_q_ =1



_̸_


_̸_


_̸_


_̸_


_j_ [2] _j_

[+]
_j −_ _q_ _m_ [3]



_̸_


_̸_


_̸_


_̸_


  -  - _[m]_
= _O_


_j_ =1

  -  - _[m]_
= _O_


_j_ =1

  -  - _[m]_
= _O_


_j_ =1



_̸_


_̸_


_̸_


_̸_


_j_ [2] _q_
( _q −_ _j_ ) _m_ [3]



_̸_


_̸_


_̸_


_̸_


��


_m_



_j_ =1



_̸_


_̸_


_̸_


_̸_


1

_j_


1

_j_



_̸_


_̸_


_̸_


_̸_


- - _[j][−]_ [1]


_q_ =1



_̸_


_̸_


_̸_


_̸_


3

- _j_

[log] _[ j]_ [ +]
_m_ [3]



_̸_


_̸_


_̸_


_̸_


_j_ [3]

[+]
( _j −_ _q_ ) _m_ [3]



_̸_


_̸_


_̸_


_̸_


_m−j_



_ℓ_ =1



_̸_


_̸_


_̸_


_̸_


_j_ [2] ( _j_ + _ℓ_ )

_ℓm_ [3]



_̸_


_̸_


_̸_


_̸_


��



_̸_


_̸_


_̸_


_̸_


_j_ ( _m −_ _j_ ) 
_m_ [3]



_̸_


_̸_


_̸_


_̸_


_j_ [2]

[log] _[ j]_ [ +]
_m_ [3]



_̸_


_̸_


_̸_


_̸_


_m_



_j_ =1



_̸_


_̸_


_̸_


_̸_


_j_ [2]

[log(] _[m][ −]_ _[j]_ [ + 1) +]
_m_ [3]



_̸_


_̸_


_̸_


_̸_


= _O_ (log _m_ ) _._


In conclusion, we have


_m_

_∥_ **b** _∥_ 1 _≤∥_ **b** _−_ **b** _[′]_ _∥_ 1 + _∥_ **b** _[′]_ _∥_ 1 = _O_         - log _m_ +         

_j_ =1


and there is an absolute constant _C_ such that _∥_ **b** _∥_ 1 _≤_ log _m_ .


9



_̸_


_̸_


_̸_


_̸_


1

_j_



_̸_


_̸_


_̸_


_̸_


= _O_ (log _m_ ) _,_


**2.6** **Hamiltonian simulation by qDRIFT**


qDRIFT is a randomized algorithm for Hamiltonian simulation that uses importance sampling to
achieve a circuit depth independent of the number of Hamiltonian terms [17]. This is in sharp
contrast to Trotter–Suzuki methods [22, 23], whose circuit depth always scales linearly with the
number of Hamiltonian terms, regardless of the approximation order. We provide a brief overview
of qDRIFT below, and refer the reader to [17, 40] for further details.
Suppose



_H_ =



_L_


_λkHk_

_k_ =1



is a Hermitian matrix with _∥Hk∥_ = 1, for all _k ∈_ [ _L_ ]. For _λ_ = [�] _k_ _[L]_ =1 _[|][λ][k][|]_ [ and the distribution]


_D_ = _{_ ( _|λk|/λ, Hk_ ) : _k ∈_ [ _L_ ] _},_


the qDRIFT procedure (outlined in Algorithm 1) randomly and independently samples matrices
_Hj_ 1 _, . . ., Hjℓ_ from _D_, and applies [�] _r_ _[ℓ]_ =1 _[e]_ [i] _[λH][jr]_ _[t][,]_ [ to an arbitrary input density operator] _[ ρ]_ [. With a]
suitable choice of _t_, this randomized evolution approximates the target evolution _e_ _[−]_ [i] _[HT]_ _ρe_ [i] _[HT]_ .


**Algorithm 1** qDRIFT protocol

**Input:** A Hermitian operator _H_ = ~~[�]~~ _k_ _[L]_ =1 _[λ][k][H][k]_ [ with] _[ ∥][H][k][∥]_ [= 1.]
Classical sample access to the distribution _D_ = _{_ ( _|λk|/λ, Hk_ ) : _k ∈_ [ _L_ ] _}_, where _λ_ = [�] _k_ _[|][λ][k][|]_ [.]
A time-step parameter _t <_ 1 _/_ 2 _λ_ .
An initial density operator _ρ_ .
**Output:** _E_ ( _ρ_ ), where _E_ := [�] _k_ _[p][k][e][−]_ [i] _[tλ]_ [ad] _[Hk]_ [ with] _[ p][k]_ [ =] _[ |][λ][k][|][/λ]_ [.]

1: Compute _N_ = _⌈T/t⌉_ .

2: For _r_ = 1 _, . . ., N_
Sample _Hjr_ from the distribution _D_ .
Let _ρ ←_ _e_ _[−]_ [i] _[tλH][jr]_ _ρe_ [i] _[tλH][jr]_

3: Return _ρ_ .


Mathematically, qDRIFT defines the quantum channel



_L_


_pke_ _[−]_ [i] _[tλ]_ [ad] _[Hk]_ ( _ρ_ )

_k_ =1



_E_ ( _ρ_ ) =



_L_


_pke_ _[−]_ [i] _[λH][k][t]_ _ρe_ [i] _[λH][k][t]_ =

_k_ =1



for a time-step _t_, where _pk_ = _λk/λ_ . Campbell proved that [17, (B12) in the appendix]

_E −_ _e−_ iad _H_ _t_
��� ��� _⋄_ [=] _[ O]_ [(] _[t]_ [2][)] _[.]_


Moreover, if we take _t_ = _T/N_ and apply the qDRIFT channel _N_ times, the total error is bounded
by
_E_ _N −_ _e−_ iad _H_ _T_ �( _λT_ ) [2] _/N_              - _._
��� ��� _⋄_ [=] _[ O]_

This leads to a circuit depth of _O_ ( _λ_ [2] _t_ [2] _/ε_ ), which is independent of _L_ . This independence makes
qDRIFT particularly advantageous (over Trotter methods) in settings where _λ ≪_ _L_, as is often the
case in quantum chemistry [17, 18, 20].
The recent work of [25] shows that if the goal is to measure the expectation value of any observable with respect to the time-evolved state, this dependence on precision can be exponentially


10


improved from 1 _/ε_ to polylog(1 _/ε_ ) with the help of classical extrapolation techniques. More precisely, Ref. [25] considered the parametrized qDRIFT channels with free parameter _s_ and step size
_sT_ : [2]

_Es_ ( _ρ_ ) :=                  - _pke_ [i] _[sTλ]_ [ad] _[Hk]_ ( _ρ_ ) _._ (2.9)


_k_


It was shown in [25] that for _sT <_ 1 _/_ 2 _λ_, the channel _Es_ has the following form.



**Lemma 2.10** (Section 4.2 and Lemma 10 of [25]) **.** _If sT <_ 1 _/_ 2 _λ, then the channel Es can be written_
_as_



_Es_ = _e_ [i] _[sT]_ _[G]_ [(] _[s]_ [)] _,_ _where G_ ( _s_ ) = ad _H_ +



_∞_






( _sT_ ) _[j]_ _Dj_ +1 _,_ (2.10)

_j_ =1



_where {Dj_ +1 _}_ _[∞]_ _j_ =1 _[are superoperators satisfying][ ∥D][j][∥]_ _⋄_ _[≤]_ [(4] _[λ]_ [)] _[j][.]_


Then the difference between the true time evolved density matrix, and the one obtained by
applying the qDRIFT channel can be written as a power of the step size as shown below (we set
_T_ = 1):


**Lemma 2.11** (Lemma 3 of [25]) **.** _Let K ≥_ 3 _be an integer. For any density operator ρ, we have_


       _Es_ [1] _[/s]_ ( _ρ_ ) _−_ _e_ [i] _[H]_ _ρe_ _[−]_ [i] _[H]_ = _s_ _[j]_ [ ˜] _Dj_ +1 _,K_ ( _ρ_ ) + _D_ [˜] _K,s_ ( _ρ_ ) _,_

_j≥_ 1


_where the diamond norm of the superoperators satisfies_



min _{K−_ 1 _,n}_
�� _D_ ˜ _j_ +1 _,K_ �� _⋄_ _[≤]_ [(8] _[λ]_ [)] _[j]_ 
_ℓ_ =1



(8 _λ_ ) _[ℓ]_

_,_
_ℓ_ !



�� _D_ ˜ _K,s_ �� _⋄_ _[≤]_ [(8] _[λ]_ [)] _[K]_

_K_ !



_∞_


(8 _λs_ ) _[j]_ _._

_j_ =1



Parametrizing the error as a polynomial in _s_ enables the use of Richardson extrapolation to
exponentially reduce the circuit depth.

### **3 Randomized algorithms for QSVT**


In this section, we present two randomized quantum algorithms for QSVT. Consider an _n_ -qubit
Hamiltonian expressed as a linear combination of local terms,



_L_

- _|λk|._


_k_ =1



_H_ =



_L_


_λkHk,_ _λ_ =

_k_ =1



For the first algorithm, we assume that each _Hk_ is unitary and can be implemented efficiently on
a quantum computer, using constant-depth circuits over elementary gates. This setting captures
the vast majority of physically relevant Hamiltonians; in particular, in quantum chemistry and
condensed matter physics, the terms _Hk_ are typically tensor products of Pauli operators, _Hk ∈_
_{I, X, Y, Z}_ _[⊗][n]_ . The second algorithm applies to a more general setting where each _Hk_ is an
arbitrary Hermitian operator of unit norm, provided that _e_ [i] _[H][k]_ can be implemented efficiently.


2Here, we use channel _Es_ to approximate _e_ i _s_ ad _H_ instead of _e−_ i _s_ ad _H_ for our convenience.


11


Our key assumption is sampling access to the decomposition: namely, we can efficiently obtain
i.i.d. samples from the distribution


_D_ = _{_ ( _|λk| /λ, Hk_ ) : _k ∈_ [ _L_ ] _} ._


This sampling model is what makes our algorithms inherently randomized. Given this access model,
our goal is to implement a target function _f_ ( _H_ ), approximated by a bounded polynomial of degree
_d_, which is the central task of QSVT. Concretely, for any observable _O_ and initial state _|ψ_ 0 _⟩_, we
design randomized procedures that output an estimate _µ_ such that

�� _µ −⟨ψ_ 0 _|f_ ( _H_ ) _†Of_ ( _H_ ) _|ψ_ 0 _⟩_ �� _≤_ _ε∥O∥._


Our challenge is to realize this while (i) avoiding block encodings, (ii) minimizing the number of
ancilla qubits, and (iii) achieving circuit depth independent of the number of terms _L_ .


**3.1** **A direct randomization of QSVT**


We begin by developing a method that can be viewed as a direct randomization of QSVT. Recall
that in the standard framework, given a block encoding _U_ (see Definition 2.2) of a Hermitian
operator _H_ with _∥H∥≤_ 1 and a degree- _d_ even or odd polynomial _P_ ( _x_ ), there exists a phase vector
Φ = ( _ϕ_ 1 _, . . ., ϕd_ ) _∈_ R _[d]_ such that the alternating phase sequence



_U_ Φ :=








_e_ [i] _[ϕ]_ [1] _[Z]_ _U_ [�] _j_ [(] _[d]_ =1 _[−]_ [1)] _[/]_ [2] - _e_ [i] _[ϕ]_ [2] _[j]_ _[Z]_ _U_ _[†]_ _e_ [i] _[ϕ]_ [2] _[j]_ [+1] _[Z]_ _U_ - _,_ if _d_ is odd,
(3.1)

- _d/j_ =12 - _e_ [i] _[ϕ]_ [2] _[j][−]_ [1] _[Z]_ _U_ _[†]_ _e_ [i] _[ϕ]_ [2] _[j]_ _[Z]_ _U_ - _,_ if _d_ is even,







is itself a block encoding of _P_ ( _H_ ). The phase sequence Φ is determined entirely by the target
polynomial _P_ ( _x_ ) and can be computed efficiently on a classical computer, e.g., see [46, 47].
However, in the sampling access model considered in this work, constructing a block encoding
of _H_ is infeasible, since we only have access to individual terms _Hk_ sampled according to their
weights _|λk|/λ_ . This motivates a different approach. Instead of a block encoding, we introduce a
simpler operator of the form




  - _cI_ _sH_
_U_ =
_sH_ _[†]_ _−cI_




_,_ _c, s ∈_ (0 _,_ 1) _, c_ [2] + _s_ [2] = 1 _._ (3.2)



and study its behavior within the alternating phase sequence in Eq. (3.1). Although _U_ is not
unitary in general, it becomes unitary whenever _H_ is unitary, and more importantly, it serves as a
randomized analogue of a block encoding of _H_ . Concretely, by sampling a random term _Hk_ from
_D_, we can efficiently construct the unitary




   - _cI_ _sHk_
_Uk_ =
_sHk_ _[†]_ _−cI_




_,_ (3.3)



satisfying E[ _Uk_ ] = _U_ . Each run of the algorithm thus implements a randomized circuit: an interleaved sequence of single-qubit rotations and unitaries _Uk_, which in expectation reproduces the
effect of the sequence _U_ Φ.
With this setup, we first provide a general characterization of alternating phase-modulation
sequences _U_ Φ that incorporate the operator _U_, and demonstrate how such sequences can be used to
implement polynomial transformations of _H_ . In fact, the following theorem, which holds for arbitrary matrices (not necessarily Hermitian or square), can be viewed as the analogue of Lemma 2.5
in the standard QSVT framework.


12


**Theorem 3.1.** _Let P_ ( _x_ ) _∈_ C[ _x_ ] _be a degree-d polynomial such that |P_ ( _x_ ) _| ≤_ 1 _/_ 2 _for all x ∈_ [ _−_ 1 _,_ 1]
_and has parity-_ ( _d_ mod 2) _. Let m, c, s, α ∈_ R _be such that_



_√_
1 _−_ 1 _/m,_ _α_ =



_m_ = Θ� _d ·_ log [2] ( _d/ε_ ) log [2] (log ( _d/ε_ ))� _,_ _s_ = 1 _/_ _[√]_ _m,_ _c_ = ~~�~~



_m_ = Θ� _d ·_ log [2] ( _d/ε_ ) log [2] (log ( _d/ε_ ))� _,_ _s_ = 1 _/_ _m,_ _c_ = ~~�~~ 1 _−_ 1 _/m,_ _α_ = _m −_ 1 log� _d_ [2] _/ε_ - _._

(3.4)
_Let H ∈_ C _[k][×][ℓ]_ _be a matrix with ∥H∥≤_ 1 _. Define_



_U_ :=        - _cIk_ _sH_
_sH_ _[†]_ _−cIℓ_


_Then there exists_ Φ _∈_ R _[m]_ _such that_




- Π :=� - _I_ 0 _k_ 00� Π := �00 _I_ 0 _ℓ_




- Π :=� - _I_ 0 _k_ 00




_._



_|_ 0 _⟩⟨_ 1 _| ⊗_ _P_ ( _H/α_ ) _≈ε_ Π [�] _U_ ΦΠ _if m is odd,_

_|_ 1 _⟩⟨_ 1 _| ⊗_ _P_ ( _H/α_ ) _≈ε_ Π _U_ ΦΠ _if m is even,_


_where U_ Φ _is the alternating phase sequence defined as_



_U_ Φ :=










        -         _e_ [i] _[ϕ]_ [1][(2][Π][�] _[−][I]_ [)] _U_ [�] _j_ [(] _[m]_ =1 _[−]_ [1)] _[/]_ [2] _e_ [i] _[ϕ]_ [2] _[j]_ [(2Π] _[−][I]_ [)] _U_ _[†]_ _e_ [i] _[ϕ]_ [2] _[j]_ [+1][(2][Π][�] _[−][I]_ [)] _U_ _,_ _if m is odd,_



(3.5)

- _m/j_ =12 - _e_ [i] _[ϕ]_ [2] _[j][−]_ [1][(2Π] _[−][I]_ [)] _U_ _[†]_ _e_ [i] _[ϕ]_ [2] _[j]_ [(2][Π][�] _[−][I]_ [)] _U_ - _,_ _if m is even._








The above result realizes polynomial transformations of _H/α_, in analogy with standard QSVT.
Specifically,




_,_


_,_




- _∗_ _P_ ( _H/α_ )
_∗_ _∗_


- _∗_ _∗_
_∗_ _P_ ( _H/α_ )



if _m_ is odd and



_U_ Φ _≈ε_


_U_ Φ _≈ε_



if _m_ is even. By conjugating _U_ Φ with appropriate swap operators, we can place _P_ ( _H/α_ ) in the
top-left block in both cases.


_Proof._ We consider the case when _d_ is even. The odd case can be proved similarly. Let _H_ =
�min( _i_ =1 _k,ℓ_ ) _σi|ui⟩⟨vi|_ be the singular value decomposition of _H_ . Denote




   - 0
_|ψi⟩_ = _|vi⟩_




 - - _|ui⟩_
_,_ _|ψ_ [˜] _i⟩_ =
0




_,_



then we have Π _|ψi⟩_ = _|ψi⟩,_ Π [�] _|ψ_ [˜] _i⟩_ = _|ψ_ [˜] _i⟩_, and Π [�] _U_ Π = _s_ [�] _i_ [min(] =1 _[k,ℓ]_ [)] _σi|ψ_ [˜] _i⟩⟨ψi|_ . For each _i_, define two
vectors



( _I −_ Π) _U_ _[†]_ _|ψ_ [˜] _i⟩_      - _|ui⟩_
_|ψi_ _[⊥][⟩]_ [:=] =
_∥_ ( _I −_ Π) _U_ _[†]_ _|ψ_ [˜] _i⟩∥_ 0



( _I −_ Π) [�] _U |ψi⟩_ - 0

=
_∥_ ( _I −_ Π) [�] _U |ψi⟩∥_ _−|vi⟩_




- ( _I −_ Π) [�] _U |ψi⟩_
_,_ _|ψ_ [˜] _i_ _[⊥][⟩]_ [:=]




_._



Observe that [3]


_U_ _|ψi⟩_ = _sσi|ψ_ [˜] _i⟩_ + _c|ψ_ [˜] _i_ _[⊥][⟩][,]_

_U_ _|ψi_ _[⊥][⟩]_ = _c|ψ_ [˜] _i⟩−_ _sσi|ψ_ [˜] _i_ _[⊥][⟩][.]_


3Note that _U_ is not unitary generally, hence the output quantum states are no longer normalized.


13


Let _Hi_ := Span _{|ψi⟩_ _,_ �� _ψi⊥_ - _}_ and _H_ [˜] _i_ := Span _{|ψ_ [˜] _i⟩, |ψ_ [˜] _i_ _[⊥][⟩}]_ [ for] _[ i][ ∈]_ [[min(] _[k, ℓ]_ [)], then]




 -  - _sσi_ _c_
_U_ =

_c_ _−sσi_

_i∈_ [min( _k,ℓ_ )]




- _Hi_

_._ (3.6)
_H_ ˜ _i_



We also have


   _e_ [i] _[ϕ]_ [(2Π] _[−][I]_ [)] =


_i∈_ [min( _k,ℓ_ )]




- _e_ i _ϕ_ 0
0 _e_ _[−]_ [i] _[ϕ]_




- _Hi_




    _,_ _e_ [i] _[ϕ]_ [(2][Π][�] _[−][I]_ [)] =
_Hi_



_i∈_ [min( _k,ℓ_ )]




- _H_ ˜ _i_

_._ (3.7)
_H_ ˜ _i_




- _e_ i _ϕ_ 0
0 _e_ _[−]_ [i] _[ϕ]_



Note that

            - _sx_ _c_
_R_ ˜( _x_ ) :=
_c_ _−sx_







_√_

     - _sx/_
_c_ [2] + _s_ [2] _x_ [2] _·_ _√_



_c_ [2] + _s_ [2] _x_ [2]




 =



_√_
_c/_



_√_
_c_ [2] + _s_ [2] _x_ [2] _−sx/_



_√_
_c_ [2] + _s_ [2] _x_ [2] _c/_



_c_ [2] + _s_ [2] _x_ [2]








     - _sx_
_c_ [2] + _s_ [2] _x_ [2] _· R_ ~~_√_~~




~~�~~
=



_c_ [2] + _s_ [2] _x_ [2]




_,_



where _R_ is the single-qubit reflection operator, see Eq. (2.1). For the given polynomial _P_ ( _x_ ), we
can derive a polynomial _P_ [˜] ( _z_ ) according to Proposition A.4 such that

          - ~~�~~          - _m_          - _sx_          
_c_ [2] + _s_ [2] _x_ [2] ˜ _P_ ~~_√_~~ _−_ _P_ ( _x/α_ ) _≤_ _ε._

���� _c_ [2] + _s_ [2] _x_ [2] ����



_c_ [2] + _s_ [2] _x_ [2] - _m_ ˜ _P_ - ~~_√_~~ _sx_





_−_ _P_ ( _x/α_ ) _≤_ _ε._
����



_√_
Moreover, _|P_ [˜] ( _z_ ) _| ≤_ 1 for _z_ = _sx/_



_c_ [2] + _s_ [2] _x_ [2]



Moreover, _|P_ [˜] ( _z_ ) _| ≤_ 1 for _z_ = _sx/_ _c_ [2] + _s_ [2] _x_ [2] _∈_ [ _−s, s_ ], and _P_ [˜] has the same parity as _P_ ( _x_ ). We

may consider _P_ [˜] ( _z_ ) as a polynomial in _z/s ∈_ [ _−_ 1 _,_ 1]. Then, by Lemma 2.1, there exists a sequence
of phase angles Φ = ( _ϕ_ 1 _, . . ., ϕm_ ) _∈_ R _[m]_ such that



_m_



_j_ =1




- _P_ ˜ - ~~_√_~~ _sx_ - _∗_

_c_ [2] + _s_ [2] _x_ [2]

_∗_ _∗_







_._ (3.8)





   - _sx_
_e_ [i] _[ϕ][j]_ _[Z]_ _R_ ~~_√_~~

_c_ [2] + _s_ [2] _x_ [2]





   - _sx_
_e_ [i] _[ϕ][j]_ _[Z]_ _R_ ~~_√_~~




- [�]
=



Combining Eqs. (3.6), (3.7) and (3.8), we obtain



 _m/_ 2

 


_j_ =1



_Hi_



_Hi_




  _U_ Φ =


_i∈_ [min( _k,ℓ_ )]


  =


_i∈_ [min( _k,ℓ_ )]


  =


_i∈_ [min( _k,ℓ_ )]


_≈ε_  




- _e_ [i] _[ϕ]_ [2] _[j][−]_ [1] _[Z]_ [ ˜] _R_ ( _σi_ ) _e_ [i] _[ϕ]_ [2] _[j]_ _[Z]_ [ ˜] _R_ ( _σi_ ) 









_m_

 

_j_ =1




 - ~~�~~





_e_ [i] _[ϕ][j]_ _[Z]_ ~~[�]~~



_c_ ~~[2]~~ + _s_ ~~[2]~~ _σi_ ~~[2]~~



_c_ [2] + _s_ [2] _σi_ [2] _· R_ - ~~_√_~~ _sσi_



_Hi_

- [�]




_Hi_




    - _m_    - _[m]_
_c_ [2] + _s_ [2] _σi_ [2]



_Hi_

- [�]




_Hi_




_e_ [i] _[ϕ][j]_ _[Z]_ _R_  - ~~_√_~~ _sσi_

_c_ ~~[2]~~ + _s_ ~~[2]~~ _σi_ ~~[2]~~



_j_ =1


- _Hi_

_._
_Hi_



_i∈_ [min( _k,ℓ_ )]




- _P_ ( _σi/α_ ) _∗_
_∗_ _∗_



Hence


   Π _U_ ΦΠ _≈ε_


_i∈_ [min( _k,ℓ_ )]


This completes the proof.



min( _k,ℓ_ )

 
_P_ ( _σi/α_ ) _|ψi⟩⟨ψi|_ = _|_ 1 _⟩⟨_ 1 _| ⊗_ _P_ ( _H/α_ ) _._

_i_ =1


14




- _P_ ( _σi/α_ ) 0
0 0




- _Hi_

=
_Hi_


We first note that Theorem 3.1 implements polynomial transformations on the singular values
of an arbitrary operator _H_ . In the special case where _H_ is Hermitian, these transformations act
directly on its eigenvalues. From the proof, we see that the phase Φ can be computed using any
of the previous algorithms for QSVT (e.g., [46, 47]), applied to the polynomial _P_ [˜] ( _z_ ) viewed as a
polynomial in _z/s ∈_ [ _−_ 1 _,_ 1]. The parameter _s_ in our construction plays a role analogous to the
normalization factor 1 _/α_ in block encodings (see Definition 2.2), and directly impacts the overall
complexity of the algorithm. Its choice is constrained by QSVT requirements: specifically, we need
( _c_ [2] + _s_ [2] _x_ [2] ) _[m/]_ [2] to remain bounded by a constant for all _x ∈_ [ _−_ 1 _,_ 1]. Under this constraint, our choice
of _s_ is essentially optimal. One might ask whether an alternative construction of _U_ could enable
a significantly larger _s_ and hence reduce complexity further. However, our lower bound analysis
shows that this is impossible in general, establishing the optimality of our approach.
Naturally, the operators _U_ and _U_ Φ from Theorem 3.1 are not unitary in general. To overcome
this, we use randomized constructions of _U_ to recover the desired transformation. Specifically, by
sampling terms _Hk_ of _H_ from the distribution _D_ via importance sampling, we construct the unitary
matrices _Uk_ defined in Eq. (3.3), which satisfy E[ _Uk_ ] = _U_ . We then prove that substituting these
_Uk_ into the alternating phase sequence yields, in expectation, the exact operator _U_ Φ. This key
observation is formalized in the following lemma, stated for the normalized operator _H/λ_ .


**Lemma 3.2.** _Let H be an operator written as a linear combination of unitaries_



_H_ =



_L_


_λkHk,_

_k_ =1



_with_ [�] _k_ _[|][λ][k][|]_ [ = 1] _[. Let][ D]_ [ =] _[ {]_ [(] _[|][λ][k][|][, H][k]_ [) :] _[ k][ ∈]_ [[] _[L]_ []] _[}][ denote the probability distribution that outputs][ H][k]_
_with probability |λk|. Define unitary_




   - _cI_ _sHk_
_Uk_ :=
_sHk_ _[†]_ _−cI_




_._



_Let U_ Φ [(] _[R]_ [)] _be the random circuit obtained by replacing each U in Eq._ (2.2) _with an i.i.d. sample Uk_
_from D. Then_ E[ _U_ Φ [(] _[R]_ [)][] =] _[ U]_ [Φ] _[.]_


_Proof._ Note that E[ _Uk_ ] = _U_ for _k ∈_ [ _L_ ]. Since _Hk_ is sampled independently, for even _m_ we have



E[ _U_ Φ [(] _[R]_ [)][] =]


=



_m/_ 2



_j_ =1


_m/_ 2



_j_ =1




- _e_ [i] _[ϕ]_ [2] _[j][−]_ [1][(2Π] _[−][I]_ [)] E[ _Uk_ _[†]_ _j_ []] _[e]_ [i] _[ϕ]_ [2] _[j]_ [(2][Π][�] _[−][I]_ [)][E][[] _[U][k]_ _j_ _[′]_ []]


- _e_ [i] _[ϕ]_ [2] _[j][−]_ [1][(2Π] _[−][I]_ [)] _U_ _[†]_ _e_ [i] _[ϕ]_ [2] _[j]_ [(2][Π][�] _[−][I]_ [)] _U_



= _U_ Φ _._


The case for odd _m_ is similar.


As a direct corollary of the above lemma, we have the following result.


**Proposition 3.3.** _Let P_ ( _x_ ) _∈_ C[ _x_ ] _be a degree-d polynomial such that |P_ ( _x_ ) _| ≤_ 1 _/_ 2 _for all x ∈_

[ _−_ 1 _,_ 1] _and has parity-_ ( _d_ mod 2) _. Let m, c, s, α be described in_ (3.4) _. Let H_ = [�] _k_ _[L]_ =1 _[λ][k][H][k][ be an]_


15


_LCU decomposition of matrix H ∈_ C _[ℓ][×][ℓ]_ _with_ [�] _k_ _[L]_ =1 _[|][λ][k][|]_ [ = 1] _[. Then, there exists a random quantum]_
_circuit U_ Φ [(] _[R]_ [)] _[, using only one ancilla qubit and][ m][ applications of]_

          -          - _cI_ _sHk_          -          _Uk_ = : _k ∈_ [ _L_ ] _,_
_sHk_ _[†]_ _−cI_


_whose expectation is the circuit U_ Φ _in Theorem 3.1._


_Proof._ This follows directly from Theorem 3.1 and Lemma 3.2.


With these ingredients, we now state our first randomized QSVT algorithm. To implement a
target polynomial _P_ ( _H_ ), we construct a randomized alternating-phase circuit _U_ Φ [(] _[R]_ [)] by drawing _m_ =
_O_ �( _d_ ) i.i.d. samples _Hj_ 1 _, . . ., Hjm_ from _D_, and substituting the corresponding unitaries _Uj_ 1 _, . . ., Ujm_ .
On input _|ψ_ 0 _⟩_, we measure _O_ at the end of each coherent run. Since E[ _U_ Φ [(] _[R]_ [)][] =] _[ U]_ [Φ][, the expected]
measurement outcome is
_⟨ψ_ 0 _|P_ ( _H_ _[′]_ ) _[†]_ _OP_ ( _H_ _[′]_ ) _|ψ_ 0 _⟩,_

where _H_ _[′]_ = _H/_ ( _λα_ ). As each outcome is bounded by _∥O∥_, Hoeffding’s inequality implies that
_O_ (1 _/ε_ [2] ) independent repetitions suffice to obtain an _ε∥O∥_ -additive estimate.


**Algorithm 2** Direct randomization of quantum singular value transformation [Theorem 3.4]


**Input:** An LCU decomposition of _H_ = ~~[�]~~ _k_ _[L]_ =1 _[λ][k][H][k]_ [ with] _[ λ]_ [ =] ~~[�]~~ _k_ _[L]_ =1 _[|][λ][k][|]_ [.]
A quantum state _|ψ_ 0 _⟩_ and an observable _O_ .
A polynomial _P_ ( _x_ ) satisfying conditions stated in Theorem 3.4.
Let _α_ = _[√]_ _m −_ 1 log( _d_ [2] _/ε_ ), _H_ _[′]_ = _[H]_

_λα_ [, and set] _[ T]_ [ = (2] _[/ε]_ [2][) log(2] _[/δ]_ [)] _[.]_
**Output:** An estimate _µ_ such that

_µ −⟨ψ_ 0 _|P_ ( _H_ _′_ ) _†OP_ ( _H_ _′_ ) _|ψ_ 0 _⟩_ _≤_ _ε∥O∥_
��� ���


1: Generate the distribution _D_ = _{_ ( _|λk|/λ, Hk_ ) : _k ∈_ [ _L_ ] _}_ .

2: Construct polynomial _P_ [˜] ( _z_ ) via Proposition A.4 and generate phase Φ _∈_ R _[m]_ via Lemma 2.1

(see Eq. (3.8)).

3: For _j_ = 1 _,_ 2 _, . . ., T_
Generate a random quantum circuit _U_ Φ [(] _[R]_ [)] according to _D_ . [Proposition 3.3]

    - If _P_ ( _x_ ) is even, measure _|_ 1 _⟩⟨_ 1 _| ⊗_ _O_ in the state _U_ Φ [(] _[R]_ [)] _[|]_ [1] _[, ψ]_ [0] _[⟩]_ [and denote the measurement]
outcome as _µj_ .


    - If _P_ ( _x_ ) is odd, measure _|_ 0 _⟩⟨_ 0 _| ⊗_ _O_ in the state _U_ Φ [(] _[R]_ [)] _[|]_ [1] _[, ψ]_ [0] _[⟩]_ [and denote the measurement]
outcome as _µj_ .


4: Output _µ_ = _T_ [1] - _Tj_ =1 _[µ][j]_ [.]


The full procedure is given in Algorithm 2 and its correctness and complexity are analyzed in
the following theorem.


**Theorem 3.4.** _Let P_ ( _x_ ) _∈_ C[ _x_ ] _be a degree-d polynomial such that |P_ ( _x_ ) _| ≤_ 1 _/_ 2 _for all x ∈_ [ _−_ 1 _,_ 1]
_and has parity-_ ( _d_ mod 2) _. Let m, c, s, α be as defined in Eq._ (3.4) _. Let H_ = [�] _k_ _[L]_ =1 _[λ][k][H][k][ be the]_
_LCU decomposition of matrix H ∈_ C _[ℓ][×][ℓ]_ _with λ_ = [�] _k_ _[|][λ][k][|][. Define]_

_H_ _[′]_ = _H/αλ,_


16


_let |ψ_ 0 _⟩_ _a quantum state and O be an observable. Then Algorithm 2, using_


_T_ = _O_ ( _ε_ _[−]_ [2] log(1 _/δ_ )) _,_


_repetitions of the quantum circuit in Proposition 3.3, outputs an estimate µ such that_

_µ −⟨ψ_ 0 _|P_ ( _H_ _′_ ) _†OP_ ( _H_ _′_ ) _|ψ_ 0 _⟩_ _≤_ _ε∥O∥_
��� ���


_with probability at least_ 1 _−_ _δ. Moreover, each coherent run requires circuit depth_ _O_ ( _d_ ) _and uses_

[�]
_only a single ancilla qubit._


_Proof._ We consider the case when _d_ is even. The odd case can be proved similarly. Note that


                       _⟨ψ_ 0 _|P_ ( _H_ _[′]_ ) _[†]_ _OP_ ( _H_ _[′]_ ) _|ψ_ 0 _⟩_ = Tr _O P_ ( _H_ _[′]_ ) _|ψ_ 0 _⟩⟨ψ_ 0 _|P_ ( _H_ _[′]_ ) _[†]_ [�] _,_


which can be viewed as the expectation value of _O_ with respect to the unnormalized state _P_ ( _H_ _[′]_ ) _|ψ_ 0 _⟩_ .
By Theorem 3.1 and Proposition 3.3, we have


          -           E _U_ Φ [(] _[R]_ [)] _[|]_ [1] _[, ψ]_ [0] _[⟩]_ = _U_ Φ _|_ 1 _, ψ_ 0 _⟩≈ε |_ 0 _⟩⊗|G⟩_ + _|_ 1 _⟩⊗_ _P_ ( _H_ _[′]_ ) _|ψ_ 0 _⟩,_


for some garbage state _|G⟩_ . To estimate the desired quantity, randomly generate _T_ quantum
circuits _U_ Φ [(] _[R]_ [1][)] _, . . ., U_ Φ [(] _[R][T]_ [ )] and measure _|_ 1 _⟩⟨_ 1 _| ⊗_ _O_ in the state _U_ Φ [(] _[R][j]_ [)] _|_ 1 _, ψ_ 0 _⟩_ for all _j ∈_ [ _T_ ]. Denote
the measurement outcome as _µj_, and let _µ_ := [�] _j_ _[T]_ =1 _[µ][j][/T]_ [. Since] _[ µ][j][ ∈]_ [[] _[−∥][O][∥][,][ ∥][O][∥]_ [], Hoeffding’s]
inequality yields


Pr _µ −⟨ψ_ 0 _|P_ ( _H_ _′_ ) _†OP_ ( _H_ _′_ ) _|ψ_ 0 _⟩_ _≥_ _ε∥O∥_        - _≤_ 2 exp( _−Tε_ [2] _/_ 2) _._
���� ���


To ensure failure probability at most _δ_, it suffices to choose




[2]  - 2

[log]
_ε_ [2] _δ_



_T ≥_ [2]



_δ_




_._



This method uses only a single ancilla qubit, namely the one used in the construction of _U_ Φ.


Note that in Algorithm 2, _H_ does not need to be Hermitian. In many cases, we are ultimately
interested in estimating expectation values of the form


_⟨ψ_ 0 _|f_ ( _H_ ) _[†]_ _Of_ ( _H_ ) _|ψ_ 0 _⟩,_


where _f_ ( _x_ ) is a target function that can be approximated by a bounded polynomial of degree _d_ and
definite parity. We now show that each coherent run of our algorithm has circuit depth _O_ ( _λ_ [2] _d_ [2] ).

[�]
Let _fd_ ( _x_ ) be a target function we want to approximate, where _d_ denotes its approximate polynomial degree, i.e., the minimum degree of the polynomial approximating _fd_ ( _x_ ). By Theorem 3.4,
our randomized construction does not directly implement _fd_ ( _H_ ), but rather a rescaled version
_fd′_ ( _H_ _[′]_ ) for some _d_ _[′]_ _, H_ _[′]_ . Thus, to recover _fd_ ( _H_ ), one must enlarge the degree parameter so that
_fd′_ ( _H_ _[′]_ ) = _fd_ ( _H_ ). For many functions of interest, this requirement amounts to choosing


_d_ _[′]_

_αλ_ [=] _[ d.]_


17


_√_
Since the scaling factor satisfies _α_ = _O_ ( _d_ _[′]_ ), it follows that _d_ _[′]_ = _O_ ( _λ_ [2] _d_ [2] ). Hence, Algorithm 2

[�] [�]

estimates the desired expectation value using _O_ (1 _/ε_ [2] ) independent repetitions of a circuit of depth


_O_ �( _λ_ [2] _d_ [2] ) _._



This quadratic dependence holds quite generally, as most target functions of interest satisfy this
property. As an illustration, consider Hamiltonian simulation _e_ [i] _[Ht]_ . It is known that sin( _xt_ ) and
cos( _xt_ ) admit polynomial approximation of degree _d_ = Θ( _t_ ) [1, 2]. In our setting, the rescaling
_√_ [�]
factor is _α_ = _O_ ( _t_ log( _t/ε_ )), so the algorithm only approximately implements _e_ [i] _[Ht/]_ [(] _[αλ]_ [)] . To recover



factor is _α_ = _O_ ( _t_ log( _t/ε_ )), so the algorithm only approximately implements _e_ [i] _[Ht/]_ [(] _[αλ]_ [)] . To recover

the true evolution, we must instead simulate with an effective parameter _t_ _[′]_ satisfying
_√_



_t_ _[′]_



_λ_ log( _t_ _[′]_ _/ε_ ) [=] _[ O]_ [(] _[t]_ [)] _[,]_



which implies _t_ _[′]_ = _O_ ( _λ_ [2] _t_ [2] ). Thus, Theorem 3.4 yields a randomized quantum algorithm for Hamil
[�]
tonian simulation: if _|ψt⟩_ = _e_ _[−]_ [i] _[Ht]_ _|ψ_ 0 _⟩_, then Algorithm 2 outputs _µ_ such that


_|µ −⟨ψt|O|ψt⟩| ≤_ _ε∥O∥,_


using _O_ (1 _/ε_ [2] ) repetitions of a quantum circuit of depth _O_ ( _λ_ [2] _t_ [2] ). The same quadratic overhead

[�]
extends to other important tasks. For instance, in quantum linear systems, the target function
_f_ ( _x_ ) = 1 _/κx_ can be approximated by a polynomial of degree _d_ = Θ( _κ_ ) [1]. For matrix powers
_√_ [�]
_f_ ( _x_ ) = _x_ _[t]_, the approximate degree is _d_ = Θ( _t_ ) [48]. In all such cases, setting _d_ _[′]_ = _O_ ( _λ_ [2] _d_ [2] )

[�] [�]

suffices to implement the desired transformation.
In contrast, standard QSVT requires circuit depth _O_ ( _Lλd_ ) for the same task, together with

[�]
_O_ (log _L_ ) ancilla qubits. Our randomized approach, by comparison, requires only a single ancilla
qubit and eliminates the linear dependence on _L_ . Consequently, it is not only more resourceefficient, but also provably faster whenever the polynomial degree is relatively small, i.e., when _λd ≪_
_L_ . This regime naturally arises in many near-term applications, making our method particularly
well-suited for early fault-tolerant quantum devices.
Although Algorithm 2 can be viewed as a direct randomization of standard QSVT, it also
inherits some of its drawbacks. For example, as in the deterministic setting, implementing a real
polynomial requires two additional ancilla qubits. More importantly, in many applications the
ultimate goal is not just to apply _f_ ( _H_ ), but to estimate the expectation value of observables with
respect to the normalized state

_f_ ( _H_ ) _|ψ_ 0 _⟩_
_|ψ⟩_ =
_∥f_ ( _H_ ) _|ψ_ 0 _⟩∥_ _[,]_


that is, the quantity _⟨ψ|O|ψ⟩_ . If the normalization factor is bounded as _∥f_ ( _H_ ) _|ψ_ 0 _⟩∥≥_ _η_, standard
QSVT prepares _|ψ⟩_ using _O_ (1 _/η_ ) rounds of fixed-point amplitude amplification [49], followed by

[�]
_O_ (1 _/ε_ [2] ) repetitions of the resulting circuit to estimate the observable.
In contrast, Algorithm 2 cannot benefit from amplitude amplification. The only option is to
estimate _⟨ψ|O|ψ⟩_ through repeated classical sampling. If we let _ℓ_ = _∥f_ ( _H_ ) _|ψ_ 0 _⟩∥_, the algorithm
effectively outputs _µ/ℓ_ [2] . However, the measurement outcomes are now random variables bounded
in

                     - _−∥O∥/η_ [2] _, ∥O∥/η_ [2][�] _,_


which significantly increases the variance. As a result, although each run still has circuit depth
_O_ �( _λ_ [2] _d_ [2] ), the number of classical repetitions required increases to




  - 1
_T_ = _O_

[�]

_ε_ [2] _η_ [4]


18




_._


Hence, the overall complexity becomes




 - _λ_ 2 _d_ 2
_O_ 
_ε_ [2] _η_ [4]




_,_



which is highly suboptimal compared to what can be achieved by amplitude amplification or estimation in standard QSVT. Notably, this matches the complexity reported in [21, 28]. Thus,
although our randomized construction avoids block encodings and reduces hardware overhead, this
inefficiency is the main bottleneck of the first approach, and overcoming it is the key motivation
for our second randomized algorithm.
For our second algorithm, we take inspiration from [21] and integrate qDRIFT into the generalized QSP framework, considering linear combinations of Hermitian operators. This yields two
key advantages. First, unlike the direct randomization approach, the number of ancilla qubits is
fixed at one, regardless of whether the target polynomial is real or complex [36]. Second, combining qDRIFT with classical extrapolation enables circuits of shorter depth. More importantly, this
approach naturally supports amplitude amplification, allowing us to compute _⟨ψ|O|ψ⟩_ with the
same number of classical repetitions as standard QSVT, thereby eliminating the main inefficiency
of Algorithm 2. Consequently, our second algorithm provides a more powerful and resource-efficient
framework for randomized QSVT.


**3.2** **Randomized QSVT with qDRIFT**


Our second randomized algorithm embeds qDRIFT within the framework of generalized quantum
signal processing (GQSP) [35, 36]. For any Hamiltonian _H_, GQSP (see Sec. 2.3) implements a
Laurent polynomial _P_ ( _e_ [i] _[H]_ ) (bounded on the complex unit circle T) using circuits that alternate
between parametrized _U_ (2) rotations and controlled _e_ [i] _[H]_ (or _e_ _[−]_ [i] _[H]_ ). Unlike standard QSVT, this
framework natively handles both real and complex polynomials without additional ancilla qubits.
Moreover, since Laurent polynomials can approximate (i) most functions of interest and (ii) nearly
any polynomial achievable by QSVT, GQSP has emerged as a versatile framework for polynomial
transformations [21]. Although the procedure requires _O_ ( _d_ ) queries to _e_ [i] _[H]_ (or _e_ _[−]_ [i] _[H]_ ) and only one

[�]
ancilla qubit, its end-to-end efficiency depends critically on how _e_ [i] _[H]_ is realized. Prior work [36]
assumed block-encoding access to _H_, enabling the use of optimal Hamiltonian simulation methods

[2], but at the cost of substantial ancilla overhead, intricate controlled operations, and circuit depth
scaling with _L_ .
In our randomized setting, we replace exact Hamiltonian evolutions with qDRIFT [17], thereby
eliminating both the ancilla overhead and the explicit dependence on _L_ . A direct substitution,
however, would inherit qDRIFT’s 1 _/ε_ depth scaling (see Sec. 2.6), which substantially increases
the overall cost. To address this, we introduce a novel use of Richardson extrapolation that reduces
the scaling to polylog(1 _/ε_ ), dramatically improving efficiency while being resource-efficient.
Building on the framework of [21], we consider a general class of interleaved quantum circuits
composed of Hamiltonian evolutions (possibly of different Hamiltonians) interspersed with arbitrary
unitaries. Formally, let
_H_ [(1)] _, H_ [(2)] _, . . ., H_ [(] _[M]_ [)]


be a family of _M_ Hermitian operators of the same dimension. Each _H_ [(] _[ℓ]_ [)] admits a linear combination
of Hermitian decomposition



_Lℓ_

- _|λ_ [(] _k_ _[ℓ]_ [)] _[|][,]_

_k_ =1



_H_ [(] _[ℓ]_ [)] =



_Lℓ_


_λ_ [(] _k_ _[ℓ]_ [)] _[H]_ _k_ [(] _[ℓ]_ [)] _[,]_ _∥Hk_ [(] _[ℓ]_ [)] _[∥]_ [= 1] _[,]_ _λ_ [(] _[ℓ]_ [)] =
_k_ =1


19


and let
_λ_ := max
_ℓ_ _[{][λ]_ [(] _[ℓ]_ [)] _[}][.]_


Then, the interleaved sequence circuit _W_ is written as follows


_W_ = _V_ 0 _· e_ [i] _[H]_ [(1)] _· V_ 1 _· e_ [i] _[H]_ [(2)] _· · · e_ [i] _[H]_ [(] _[M]_ [)] _· VM_ = _V_ 0



_M_


_e_ [i] _[H]_ [(] _[ℓ]_ [)] _Vℓ,_ (3.9)

_ℓ_ =1



where _{Vℓ}_ _[M]_ _ℓ_ =0 [are arbitrary unitary operators.] Observe that _W_ subsumes GQSP: set _Vj_ =
_Rj_ ( _θj, ϕj, γj_ ) _⊗_ _I_, and _H_ [(] _[j]_ [)] = _H_ [�], where _H_ [�] = diag( _H,_ 0) or diag(0 _, −H_ ) depending on whether
control qubit is 0 or 1. For an _n_ -qubit Hamiltonian, the circuit _W_ uses _n_ + 1 qubits overall.
We establish a general result: for any initial state _|ψ_ 0 _⟩_ and observable _O_, one can estimate


_⟨ψ_ 0 _|W_ _[†]_ _OW_ _|ψ_ 0 _⟩,_


with an additive error at most _ε∥O∥_, using no block encodings, only a single ancilla qubit, and
a circuit depth that scales polylogarithmically in 1 _/ε_ . Specifically, our method requires _O_ ( _ε_ _[−]_ [2] )

[�]
repetitions of a quantum circuit of depth _O_ ( _λ_ [2] _M_ [2] + _M_ ).

[�]
The key idea is to replace the exact Hamiltonian evolutions in _W_ with qDRIFT-based simulations. Our main technical contribution is to show that the time-dependent error in observable
expectation values between this randomized circuit and the exact _W_ can be expressed as a polynomial in the parameters of the qDRIFT channel. This insight enables us to apply Richardson
extrapolation [37] in a novel way to mitigate the error, thereby improving the circuit depth scaling.
Importantly, this analysis does not follow directly from prior extrapolation-based error reduction methods for randomized Hamiltonian simulation [25], nor from [21], where Trotterization was
combined with extrapolation. Instead, we introduce two time-dependent superoperators, one for
the exact _W_ and one for its qDRIFT implementation, and analyze their difference in the interaction
picture. This formulation is crucial for deriving a tight upper bound on the error in expectation
values. For clarity of exposition, we present the arguments below in terms of density operators,
even though our main theorems are stated for pure states.
The error series between the density operator evolved under the parametrized qDRIFT channel
_Es_ [1] _[/s]_ ( _ρ_ ) and the exact evolution _e_ [i ad] _[H]_ ( _ρ_ ) was established in [25] (restated in Lemma 2.11). Our
subsequent results can be seen as a nontrivial generalization of this difference to arbitrary interleaved
sequence _W_ . For any density operator _ρ_, define


_ρ_ 2 _M_ +1 = _N_ 2 _M_ +1( _ρ_ ) := _WρW_ _[†]_ (3.10)


to be the output state of the exact interleaved circuit _W_ . On the other hand, for a family of
Hamiltonians _{H_ [(] _[ℓ]_ [)] _}_ _[M]_ _ℓ_ =1 [, define the corresponding parametrized qDRIFT channel as]


i _sλ_ [(] _[ℓ]_ [)] ad

       - _H_ [(] _[ℓ]_ [)]
_Es_ [(] _[ℓ]_ [)][(] _[ρ]_ [) :=] _p_ [(] _k_ _[ℓ]_ [)] _[e]_ _k_ ( _ρ_ ) _,_

_k_

where _p_ [(] _k_ _[ℓ]_ [)] = _|λ_ [(] _k_ _[ℓ]_ [)] _[|][/λ]_ [(] _[ℓ]_ [)][. The output quantum state from the approximate interleaved circuit (with]
arbitrary unitaries and qDRIFT) is given by




    _ρ_ ˜ _s,_ 2 _M_ +1 := _V_ 0



_M_



_ℓ_ =1




- _EsM_ [(] _[ℓ]_ [)] �1 _/_ ( _sM_ ) _Vℓ_ �( _ρ_ ) _,_ (3.11)



where _Vℓ_ is the unitary channel defined via _Vℓ_ ( _ρ_ ) := _VℓρVℓ_ _[†]_ [. Then we have the following result on]
the difference between density operators output by the two circuits.


20


**Lemma 3.5.** _Let K ∈_ Z _>_ 3 _and assume s ∈_ (0 _,_ 1 _/_ 2 _λM_ ) _, then we have_


        _ρ_ ˜ _s,_ 2 _M_ +1 _−_ _ρ_ 2 _M_ +1 = _s_ _[j]_ [ ˜] _Dj_ ( _ρ_ ) _,_ (3.12)

_j≥_ 1


_where the diamond norm of the superoperators_ _D_ [˜] _j satisfies_



_j_
�� _D_ ˜ _j_ �� _⋄_ _[≤]_ [(8] _[λM]_ [)] _[j]_ 
_ℓ_ =1



(8 _λM_ ) _[ℓ]_

_._
_ℓ_ !



_Proof._ Let _δ_ = _sM <_ 1 _/_ 2 _λ_, then as stated in Lemma 2.10, each channel _Eδ_ [(] _[ℓ]_ [)] has the form



_Eδ_ [(] _[ℓ]_ [)] = _e_ [i] _[s][G]_ [(] _[ℓ]_ [)][(] _[δ]_ [)] _,_ where _G_ [(] _[ℓ]_ [)] ( _δ_ ) = ad _H_ ( _ℓ_ ) +



_∞_


_δ_ _[j]_ _Dj_ [(] _[ℓ]_ +1 [)] _[,]_
_j_ =1



with the superoperators bounded as _∥Dj_ [(] _[ℓ]_ [)] _[∥][⋄]_ _[≤]_ [(4] _[λ]_ [)] _[j]_ [.]
Define two time-dependent superoperators _K_ ( _t_ ) and _K_ [˜] ( _t_ ) as follows:




adlog( _V⌊t⌋/_ 2) if _⌊t⌋_ is even _,_

i _G_ [(] _[⌈][t/]_ [2] _[⌉]_ [)] ( _δ_ ) if _⌊t⌋_ is odd _,_



_K_ ( _t_ ) =




adlog( _V⌊t⌋/_ 2) if _⌊t⌋_ is even _,_ _K_ ˜( _t_ ) =

i ad _H_ ( _⌈t/_ 2 _⌉_ ) if _⌊t⌋_ is odd _,_



for _t ∈_ [0 _,_ 2 _M_ + 1]. Let 1 _A_ be the indicator function of _A_ = _{t ∈_ [0 _,_ 2 _M_ + 1] : _⌊t⌋_ is odd _}_, then we
have



_K_ ˜( _t_ ) _−K_ ( _t_ ) = i1 _A_ ( _t_ )



_∞_


_δ_ _[j]_ _Dj_ [(] _[⌈]_ +1 _[t/]_ [2] _[⌉]_ [)] _._
_j_ =1



Define the corresponding evolution operators _Nt,_ _N_ [˜] _s,t_ as


_∂tNt_ = _K_ ( _t_ ) _Nt,_ _∂tN_ [˜] _s,t_ = _K_ [˜] ( _t_ ) _N_ [˜] _s,t,_


which is consistent with the previous definition of _N_ 2 _M_ +1. For density operator _ρ_, define _ρt,_ ˜ _ρs,t_ as



�� _t_ 
_K_ ˜( _τ_ ) d _τ_ ( _ρ_ ) _._
0



_ρt_ = _Nt_ ( _ρ_ ) = exp _T_


Then we have



�� _t_ 
_K_ ( _τ_ ) d _τ_ ( _ρ_ ) _,_ _ρ_ ˜ _s,t_ = _N_ [˜] _s,t_ ( _ρ_ ) = exp _T_
0



_M_



_ℓ_ =1




    _ρ_ 2 _M_ +1 = _V_ 0



_M_

- - 
_e_ [i ad] _[H]_ [(] _[ℓ]_ [)] _Vℓ_ ( _ρ_ ) _,_ _ρ_ ˜ _s,_ 2 _M_ +1 = _V_ 0

_ℓ_ =1




- _EsM_ [(] _[ℓ]_ [)] �1 _/_ ( _sM_ ) _Vℓ_ �( _ρ_ ) _,_



as in Eqs. (3.10) and (3.11). We can use Lemma 2.7 to provide a series expansion in _δ_ of the
difference between ˜ _ρs,t_ and _ρt_ . Indeed, we have



( _ρ_ )


- - [�]
_Nτ_ _[−]_ _ℓ_ [1][( ˜] _[K]_ [(] _[τ][ℓ]_ [)] _[ −K]_ [(] _[τ][ℓ]_ [))] _[N][τ]_ _ℓ_ ( _ρ_ )







_ρ_ ˜ _s,_ 2 _M_ +1 = _N_ 2 _M_ +1 exp _T_



�� 2 _M_ +1

_Nτ_ _[−]_ [1] ( _K_ [˜] ( _τ_ ) _−K_ ( _τ_ )) _Nτ_ d _τ_
0




 - _τ_ 1



_τ_ 1  - _τj−_ 1

d _τ_ 2 _· · ·_
0 0



d _τj_
0



= _N_ 2 _M_ +1



_∞_


 

_j_ =0




- 2 _M_ +1

d _τ_ 1
0



1



_ℓ_ = _j_



21


_∞_

    = _ρ_ 2 _M_ +1 + 

_j_ =1


_∞_

    = _ρ_ 2 _M_ +1 + 



- _τ_ 1




- 2 _M_ +1

d _τ_ 1
0



_τ_ 1 - _τj−_ 1

d _τ_ 2 _· · ·_
0 0



d _τj_
0



1

- - - _[∞]_ i1 _A_ ( _τℓ_ ) _δ_ _[k]_ _Nτ_ _[−]_ _ℓ_ [1] _[D]_ _k_ [(] _[⌈]_ +1 _[τ][ℓ][/]_ [2] _[⌉]_ [)] _Nτℓ_ - [�] ( _ρ_ )

_ℓ_ = _j_ _k_ =1



_∞_ _∞_

- _δ_ _[k]_ 

_k_ =1 _j_ =1




- _τ_ 1



_τ_ 1 - _τj−_ 1

d _τ_ 2 _· · ·_
0 0




- 2 _M_ +1

d _τ_ 1
0



1



_ℓ_ = _j_




- - [�]
i1 _A_ ( _τℓ_ ) _Nτ_ _[−]_ _ℓ_ [1] _[D]_ _k_ [(] _[⌈]_ _ℓ_ _[τ]_ +1 _[ℓ][/]_ [2] _[⌉]_ [)] _Nτl_ ( _ρ_ )



_j_ =1




 

_k_ 1 _,...,kj_ _≥_ 1
_k_ 1+ _···kj_ = _k_



d _τj_
0



=: _ρ_ 2 _M_ +1 +



_∞_

- _D_ ˜ _k_ ( _ρ_ ) _._


_j_ =1



The diamond norm of _D_ [˜] _k_ can be bounded by




 

_k_ 1 _,...,kj_ _≥_ 1
_k_ 1+ _···kj_ = _k_


 

_k_ 1 _,...,kj_ _≥_ 1
_k_ 1+ _···kj_ = _k_




- _τ_ 1



_τ_ 1 - _τj−_ 1

d _τ_ 2 _· · ·_
0 0




- 2 _M_ +1

d _τ_ 1
0


- 2 _M_ +1

d _τ_ 1
0



_∥D_ [˜] _k∥⋄_ _≤_


_≤_


=



_∞_



_j_ =1


_∞_



_j_ =1



�(4 _λ_ ) _[k]_ [ (4] _[λM]_ [)] _[j]_

_j_ !

_j_ =1



_j_ !



d _τj_
0




- _τ_ 1



_τ_ 1 - _τj−_ 1

d _τ_ 2 _· · ·_
0 0



d _τj_
0



1



_ℓ_ = _j_


1



_ℓ_ = _j_




- 1 _A_ ( _τℓ_ ) _∥Nτ_ _[−]_ _ℓ_ [1] _[∥][⋄][∥D]_ _k_ [(] _[⌈]_ _ℓ_ _[τ]_ +1 _[ℓ][/]_ [2] _[⌉]_ [)] _∥⋄∥Nτl_ _∥⋄_


1 _A_ ( _τℓ_ )(4 _λ_ ) _[k][ℓ]_ [+1][�]



_k_





 

_k_ 1 _,...,kj_ _≥_ 1
_k_ 1+ _···_ + _kj_ = _k_



1



_k_
_≤_ (8 _λ_ ) _[k]_ 

_j_ =1



(8 _λM_ ) _[j]_

_,_
_j_ !



where the second line follows from that _Nt_ and _Nt_ _[−]_ [1] are unitary channels preserving diamond norm,
the third line follows from

       - 2 _M_ +1        - _τ_ 1        - _τj−_ 1 1 _[⊗][ℓ]_ _[ℓ]_




_[A][⊗][ℓ]_ [)]

= _[M]_ _[ℓ]_
_ℓ_ ! _ℓ_ !



_ℓ_ ! _[,]_




- _τ_ 1



1






1 _A_ ( _τℓ_ ) = [vol(] _[A][⊗][ℓ]_ [)]

_ℓ_ !

_ℓ_ = _j_



d _τ_ 1
0



_τ_ 1 - _τj−_ 1

d _τ_ 2 _· · ·_
0 0



d _τj_
0



and the fourth line follows from

      

_k_ 1 _,...,kj_ _≥_ 1
_k_ 1+ _···_ + _kj_ = _k_




 - _k_ + _j −_ 1�
1 = _≤_ 2 _[k]_ [+] _[j]_ _._
_j −_ 1



We can apply the bound obtained in Lemma 3.5 to choose an appropriate parameter _s_ used in
the Richardson extrapolation procedure to obtain the desired accuracy. Formally, we have


**Lemma 3.6.** _Suppose that_ 8 _λM ≥_ 1 _. For any ε ∈_ (0 _,_ 1) _, set m_ = _⌈_ log(1 _/ε_ ) _⌉_ _and_


_s_ = (8 _λM_ ) _[−]_ [2] (4 _C_ log _m/ε_ ) _[−]_ [1] _[/m]_ _,_



_with the constant C defined in Lemma 2.9. Let O be an observable, define the m-th order Richardson_
_estimator as_



_⟨O_ [˜] _m,s⟩_ :=



_m_




_bi_ Tr [ _Oρ_ ˜ _si,_ 2 _M_ +1] _,_
_i_ =1



_where bi, ri, and si_ = 1 _/_ ( _Mri_ ) _are given as in Lemma 2.9 with t_ = 1 _/M_ _. Then, the extrapolation_
_error is bounded by_
_⟨O_ ˜ _m,s⟩−_ Tr [ _Oρ_ 2 _M_ +1] _≤_ _ε∥O∥/_ 2 _,_
��� ���


22


_Proof._ Define the function _f_ ( _x_ ) as


_f_ ( _x_ ) := Tr [ _Oρ_ ˜ _x,_ 2 _M_ +1] for _x ∈_ (0 _,_ 1) _,_


_f_ (0) := Tr [ _Oρ_ 2 _M_ +1] _._


Then for _x ∈_ (0 _,_ 1 _/_ 2 _λM_ ), by Lemma 3.5, we have


       -        -        _f_ ( _x_ ) = _f_ (0) + _x_ _[j]_ Tr _OD_ [˜] _j_ ( _ρ_ ) _._


_j≥_ 1



The _m_ -th order Richardson extrapolation procedure removes all terms up to _O_ ( _s_ _[m][−]_ [1] ) in the series
as shown in Lemma 2.9, which yields


_m_

   
���� _bi_ Tr [ _Oρ_ ˜ _si,_ 2 _M_ +1] _−_ Tr [ _Oρ_ 2 _M_ +1] ���� _≤∥_ **b** _∥_ 1 max _i_ _|Rm_ ( _si_ ) _| ._



_m_






_bi_ Tr [ _Oρ_ ˜ _si,_ 2 _M_ +1] _−_ Tr [ _Oρ_ 2 _M_ +1] ���� _≤∥_ **b** _∥_ 1 max _i_ _|Rm_ ( _si_ ) _| ._
_i_ =1



By Lemma 2.9, we have _si ≤_ _s_ for any _i ∈_ [ _m_ ]. Thus, by Lemma 3.5,



_j_

- 
_s_ _[j]_ (8 _λM_ ) _[j]_

_j≥m_ _ℓ_ =1




   max _|Rm_ ( _si_ ) _| ≤∥O∥_
_i_



_ℓ_ =1



(8 _λM_ ) _[ℓ]_


_ℓ_ !



_j_

- 
_s_ _[j]_ (8 _λM_ ) [2] _[j]_

_j≥m_ _ℓ_ =1



_≤∥O∥_ 


_ℓ_ =1



1

_ℓ_ !



1
= _∥O∥_ ( _s_ (8 _λM_ ) [2] ) _[m]_ [(] _[e][ −]_ [1)]
1 _−_ _s_ (8 _λM_ ) [2]



_ε_
_≤_ 2 _∥O∥_
8 _∥_ **b** _∥_ 1



1
1 _−_ ( _ε/_ 8 _∥_ **b** _∥_ 1) [1] _[/m]_



_≤_ _[ε][∥][O][∥]_

4 _∥_ **b** _∥_ 1



1
1 _−_ ( _ε/_ 8) [1] _[/]_ [ log(1] _[/ε]_ [)] _[≤]_ 2 _[ε]_ _∥_ _[∥]_ **b** _[O]_ _∥_ _[∥]_ 1



Combining all the above, we obtain

_⟨O_ ˜ _m,s⟩−_ Tr [ _Oρ_ 2 _M_ +1] _≤_ _ε∥O∥/_ 2 _._
��� ���


This completes the proof.


Combining Lemma 3.6 with the parameter choice specified in Lemma 2.9, we can estimate the
complexity for computing _⟨O_ [˜] _m,s⟩_ . We summarize this as the main theorem of this section. In the
following, we assume that each _Vℓ_ can be implemented in constant time.


**Theorem 3.7** (Interleaved Hamiltonian evolution with qDRIFT) **.** _For ℓ_ _∈_ [ _M_ ] _, let_



_H_ [(] _[ℓ]_ [)] =



_Lℓ_


_λ_ [(] _k_ _[ℓ]_ [)] _[H]_ _k_ [(] _[ℓ]_ [)]
_k_ =1



_be Hermitian decompositions of Hermitian operators H_ [(] _[ℓ]_ [)] _of the same dimension, where λ_ [(] _[ℓ]_ [)] =

_k_ _[|][λ]_ _k_ [(] _[ℓ]_ [)] _[|][ and][ ∥][H]_ _k_ [(] _[ℓ]_ [)] _[∥]_ [= 1] _[ for all][ ℓ, k][. Let][ λ]_ [ = max] _[ℓ][{][λ]_ [(] _[ℓ]_ [)] _[}][, and][ V]_ [0] _[, . . ., V][M][ be unitaries. Assume]_
_that λM ≥_ 1 _. Define_



_W_ := _V_ 0



_M_


_e_ [i] _[H]_ [(] _[ℓ]_ [)] _Vℓ._

_ℓ_ =1


23


_Suppose ε ∈_ (0 _,_ 1) _is the precision parameter and each evolution e_ [i] _[H]_ _k_ [(] _[ℓ]_ [)] _[τ]_ _can be implemented in_ _O_ (1)

[�]
_time for any τ ∈_ R _. Then there is an algorithm (see Algorithm 3) that, for any observable O and_
_initial state |ψ_ 0 _⟩, estimates_
_⟨ψ_ 0 _|W_ _[†]_ _OW_ _|ψ_ 0 _⟩,_


_with an additive error at most ε∥O∥, with time complexity_


_O_            - �( _λ_ [2] _M_ [2] + _M_ ) _/ε_ [2][�]


_and maximum quantum circuit depth_


_O_            -            - _λ_ [2] _M_ [2] + _M_            - _._


_Proof._ Let _⟨O_ [˜] _m,s⟩_ be the Richardson estimator defined in Lemma 3.6 with _ρ_ = _|ψ_ 0 _⟩⟨ψ_ 0 _|_ and _t_ =
1 _/M_ . As 8 _λM ≥_ 1, by Lemma 3.6, we have

�� _⟨O_ ˜ _m,s⟩−_ Tr[ _O_ ( _W_ _|ψ_ 0 _⟩⟨ψ_ 0 _|W †_ )]�� = �� _⟨O_ ˜ _m,s⟩−⟨ψ_ 0 _|W †OW_ _|ψ_ 0 _⟩_ �� _≤_ _ε∥O∥/_ 2 _._


The Richardson estimator is a linear combination of several terms, _⟨O_ [˜] _m,s⟩_ = [�] _i_ _[b][i]_ [Tr[] _[O][ρ]_ [˜] _[s]_ _i_ _[,]_ [2] _[M]_ [+1][],]
where the coefficient vector **b** satisfies _∥_ **b** _∥_ 1 = _O_ (log _m_ ) = _O_ (log log(1 _/ε_ )) by Lemma 2.9. To
achieve a total additive error of _ε∥O∥/_ 2 for _⟨O_ [˜] _m,s⟩_, we can estimate each individual term




        
         Tr[ _Oρ_ ˜ _si,_ 2 _M_ +1] = Tr _O_ _V_ 0



_M_



_ℓ_ =1




         
- _Es_ [(] _i_ _[ℓ]_ _M_ [)] �1 _/_ ( _siM_ ) _Vℓ_ �( _ρ_ ) _,_



with an additive error at most _ε∥O∥/_ (2 _∥_ **b** _∥_ 1) = _O_ ( _ε∥O∥/_ log log(1 _/ε_ )). From Lemma 2.9, we have


1

_[t]_ = _ri ∈_ Z _._
_siM_ [=] _si_


Therefore, we can prepare ˜ _ρsi,_ 2 _M_ +1 by a quantum circuit of depth _O_ ( _M_ + _M/_ ( _siM_ )) = _O_ ( _M_ + _Mri_ ).
As _∥_ **b** _∥_ 1 = Θ(log( _m_ )), ( _∥_ **b** _∥_ 1) [1] _[/m]_ = Θ(1). Then, we have











1 _/s_ = _O_



_λ_ [2] _M_ [2][ (] _[∥]_ **[b]** _[∥]_ [1][)][1] _[/m]_



_ε_ [1] _[/]_ [ log(1] _[/ε]_ [)]



= _O_ - _λ_ [2] _M_ [2][�] _._



Then we can estimate Tr[ _Oρ_ ˜ _si,_ 2 _M_ +1] with an additive error at most _ε∥O∥/_ (2 _∥_ **b** _∥_ 1), with a success
probability at least 1 _−_ _O_ (1 _/m_ ), by



_O_ - _∥_ **b** _∥_ 21 log _m_ - = _O_ - (log log(1 _/ε_ ))3
_ε_ [2] _ε_ [2]







repeated running of the quantum circuit of depth _O_ ( _M_ + _Mri_ ) and then measure the observable
_O_ . By the union bound, the overall success probability is at least a constant.
From Lemma 2.9, we also have _r_ 1 = _O_ (max _{m_ [3] _, m_ [2] _t/s}_ ), and hence the maximum quantum
circuit depth is


_O_ ( _M_ + _M_ max
_i_ _[{][r][i][}]_ [) =] _[ O]_ [(] _[M]_ [ +] _[ Mr]_ [1][)]

= _O_ �max _{Mm_ [3] _, m_ [2] _/s}_           
= _O_ �max _{λ_ [2] _M_ [2] log [2] (1 _/ε_ ) _, M_ log [3] (1 _/ε_ ) _}_           - _._


24


Constructing the Richardson estimator _⟨O_ [˜] _m,s⟩_ requires estimating all _m_ sample points. Each point
requires _O_ ((log log(1 _/ε_ )) [3] _/ε_ [2] ) runs of a circuit with depth up to _O_ ( _M_ + _Mri_ ). This implies that
the total number of gates is



_m_




( _M_ + _Mri_ )

_i_ =1







_m_ 

_M_ max _{m_ [3] _, m_ [2] _t/s}/i_ [2]

_i_ =1



_O_




(log log(1 _/ε_ )) [3]

_ε_ [2]



= _O_




(log log(1 _/ε_ )) [3]

_ε_ [2]




  - (log log(1 _/ε_ ))3  = _O_ max _{λ_ [2] _M_ [2] log [2] (1 _/ε_ ) _, M_ log [3] (1 _/ε_ ) _}_

_ε_ [2]




  - _λ_ 2 _M_ 2 + _M_
= _O_

[�]

_ε_ [2]




_,_



where the second line follows from [�] _i_ _[m]_ =1 _[i][−]_ [2] _[ ≤]_ _[π]_ [2] _[/]_ [6 =] _[ O]_ [(1).]


To accurately estimate the target expectation value, the algorithm repeatedly executes the
circuit _W_, each time using a different qDRIFT step size _si_ chosen according to Lemma 2.9. Each
run yields an estimate _f_ ( _si_ ), the expectation value of _O_ with respect to the corresponding output
state. The final estimate is then obtained as the linear combination [�] _i_ _[b][i][f]_ [(] _[s][i]_ [), where the coefficients]
_bi_ are specified by Lemma 2.9. The complete procedure in the proof of Theorem 3.7 is summarized
via Algorithm 3.


**Algorithm 3** Interleaved Hamiltonian evolution with qDRIFT [Theorem 3.7]


**Input:** _M_ Hermitian operators _H_ [(] _[ℓ]_ [)] = [�] _k_ _[L]_ =1 _[ℓ]_ _[λ]_ _k_ [(] _[ℓ]_ [)] _[H]_ _k_ [(] _[ℓ]_ [)] in Hermitian decomposition,
with _∥Hk_ [(] _[ℓ]_ [)] _[∥]_ [= 1] _[, λ]_ [(] _[ℓ]_ [)][ =][ �] _k_ _[|][λ]_ _k_ [(] _[ℓ]_ [)] _[|][,]_ [ and] _[ λ]_ [ = max] _[j][{][λ]_ [(] _[ℓ]_ [)] _[}]_ [ for all] _[ ℓ]_ _[∈]_ [[] _[M]_ [].]

_−_ i _sλ_ [(] _[ℓ]_ [)] ad
_H_ [(] _[ℓ]_ [)]
qDRIFT protocol that implements channel _Es_ [(] _[ℓ]_ [)] := [�] _k_ _[p]_ _k_ [(] _[ℓ]_ [)] _[e]_ _k_ . [See Algorithm 1]
A quantum state _|ψ_ 0 _⟩_ and an observable _O_ .
_M_ + 1 unitaries _V_ 0 _, . . ., VM_, with channel _Vℓ_ defined via _Vℓ_ ( _ρ_ ) := _Vℓ_ _[†][ρV][ℓ]_ [.]
_W_ := _V_ 0   - _Mℓ_ =1 _[e]_ [i] _[H]_ [(] _[ℓ]_ [)] _[V][ℓ]_ [.]


**Output:** _⟨ψ_ 0 _|W_ _[†]_ _OW_ _|ψ_ 0 _⟩± ε∥O∥_ .


1: Choose _m_ = _⌈_ log(1 _/ε_ ) _⌉_, _s_ = (8 _λM_ ) _[−]_ [2] (4 _C_ log _m/ε_ ) _[−]_ [1] _[/m]_ with _C_ defined in Lemma 2.9, and
compute _b_ 1 _, . . ., bm_ and _s_ 1 _, . . ., sm_ via Lemma 2.9 with _t_ = 1 _/M_ .

2: **for** _i_ = 1 _, . . ., m_ **do**

3: Estimate _f_ ( _si_ ) := Tr  - _O_  - _V_ 0  - _Mℓ_ =1 [(] _[E]_ _s_ [(] _i_ _[ℓ]_ _M_ [)] [)][1] _[/]_ [(] _[s][i][M]_ [)] _[V][ℓ]_  - ( _|ψ_ 0 _⟩⟨ψ_ 0 _|_ )� with an additive error at most

_∥O∥ε_
2 _∥_ **b** _∥_ 1 [and denote the result by ˆ] _[f][i]_ [.]

4: **end for**

5: **return** [�] _i_ _[m]_ =1 _[b][i]_ [ ˆ] _[f][i]_ [.]


As noted earlier, the generalized QSP circuit in Eq.(2.4) is a special case of the interleaved
structure _W_ . For any Hamiltonian _H_, Theorem 2.6 guarantees that this interleaved circuit of
controlled Hamiltonian evolutions and single-qubit rotations implements a Laurent polynomial
_P_ ( _e_ [i] _[H]_ ), with _|P_ ( _x_ ) _| ≤_ 1 on the unit circle T. By Theorem 3.7, we therefore obtain a procedure
which, given an initial state _|ψ_ 0 _⟩_ and observable _O_, estimates


_⟨ψ_ 0 _|P_ ( _e_ [i] _[H]_ ) _[†]_ _OP_ ( _e_ [i] _[H]_ ) _|ψ_ 0 _⟩,_


25


to additive accuracy _ε∥O∥_ . In this setting, the circuit length satisfies _M_ = _O_ ( _d_ ), where _d_ is the

[�]
degree of the Laurent polynomial. Formally, we have the following result:


**Theorem 3.8** (Generalized QSP with qDRIFT) **.** _Let H_ = [�] _k_ _[L]_ =1 _[λ][k][H][k][ be a Hermitian decom-]_
_position of H, with ∥Hk∥_ = 1 _, and λ_ = max _{_ [�] _k_ _[|][λ][k][|][,]_ [ 1] _[}][. Also, let][ ε][ ∈]_ [(0] _[,]_ [ 1] _[/]_ [2)] _[ be the precision]_
_parameter. Furthermore, suppose P_ ( _z_ ) = [�] _j_ _[d]_ = _−d_ _[a][j][z][j][ is a][ d][-degree Laurent polynomial bounded by]_
1 _on_ T := _{x ∈_ C : _|x|_ = 1 _}. Then there exists a quantum algorithm that, for any observable O and_
_initial state |ψ_ 0 _⟩, estimates_
_⟨ψ_ 0 _|_ ( _P_ ( _e_ [i] _[H]_ ) _[†]_ _OP_ ( _e_ [i] _[H]_ ) _|ψ_ 0 _⟩,_


_with an additive error at most ε∥O∥_ _and constant success probability, using only a single ancilla_
_qubit. The maximum quantum circuit depth is_


_O_             -             - _λ_ [2] _d_ [2][�] _,_ (3.13)


_and the total time complexity is_
_O_             -             - _λ_ [2] _d_ [2] _/ε_ [2][�] _._ (3.14)


_Proof._ Combining Theorems 2.6 and 3.7, set _U_ = _e_ [i] _[H]_ in the GQSP circuit of Eq. (2.4), and use the
parametrized qDRIFT channel to approximate the Hamiltonian evolution. Then the stated results
follow by observing _M_ = _O_ ( _d_ ) and


_O_         -         - _λ_ [2] _M_ [2] + _M_         - = _O_ [�] ( _λ_ [2] _M_ [2] ) = _O_ [�] ( _λ_ [2] _d_ [2] ) _,_


as _λ, M ≥_ 1.


Following Theorem 3.8, we now discuss its application to more general functions and Hamiltonians. While the theorem is stated for a Laurent polynomial _P_ ( _e_ [i] _[H]_ ), which is periodic in the
spectrum of _H_, our method can be applied to approximate a general, potentially non-periodic function _Q_ ( _H_ ) for a Hamiltonian _H_ with a norm bounded by _∥H∥≤_ _B_ for some _B >_ 0. We further
suppose that _λ ≥_ _B_ . A practical choice of _B_ is _B_ = _λ_ .
The strategy is to employ a rescaling of the Hamiltonian. Let _H_ _[′]_ = _H/B_, such that the rescaled
Hamiltonian has a norm _∥H_ _[′]_ _∥≤_ 1. To implement _Q_ ( _H_ ) = _Q_ ( _BH_ _[′]_ ), we need to find a suitable
degree- _d_ _[′]_ Laurent polynomial _P_ ( _z_ ) that approximates the rescaled function _Q_ ( _Bx_ ) for _x ∈_ [ _−_ 1 _,_ 1].
That is, we seek _P_ such that _P_ ( _e_ [i] _[x]_ ) _≈_ _Q_ ( _Bx_ ) for _x ∈_ [ _−_ 1 _,_ 1]. This rescaling maps the spectral
domain of interest of _H_, namely [ _−B, B_ ], onto the interval [ _−_ 1 _,_ 1], which can be embedded within
a single 2 _π_ period of _P_ ( _e_ [i] _[x]_ ). We can then apply Theorem 3.8 to the rescaled Hamiltonian _H_ _[′]_ and
the polynomial _P_ ( _z_ ). The complexity of this procedure is determined by two competing factors
arising from the rescaling:


1. The one-norm of the coefficients of the rescaled Hamiltonian _H_ _[′]_ = [�] _k_ [(] _[λ][k][/B]_ [)] _[H][k]_ [ becomes]
_λ_ _[′]_ = [�] _k_ _[|][λ][k][/B][|]_ [ =] _[ λ/B]_ [.]


2. The degree _d_ _[′]_ of the Laurent polynomial _P_ ( _e_ [i] _[x]_ ) required to approximate _Q_ ( _Bx_ ) on the interval

[ _−_ 1 _,_ 1]. As _B_ increases, the function _Q_ ( _Bx_ ) effectively “compresses” the behavior of _Q_ ( _x_ )
from the larger interval [ _−B, B_ ] into the fixed interval [ _−_ 1 _,_ 1]. This causes the rescaled
function to become more oscillatory or rapidly varying. To capture these features, a higherdegree polynomial is needed. The required degree _d_ _[′]_ typically scales linearly with _B_ (see,
e.g., the examples in [21, Appendix C]). We therefore assume _d_ _[′]_ _∝_ _d · B_, where _d_ is the base
degree for approximating _Q_ on a constant-sized interval.


26


By applying the complexity result from Theorem 3.8 to _H_ _[′]_ and _P_ ( _z_ ), the total time complexity
scales as:
_O_       - �( _λ_ _[′]_ ) [2] ( _d_ _[′]_ ) [2] _/ε_ [2][�] = _O_ [�] �( _λ/B_ ) [2] ( _d · B_ ) [2] _/ε_ [2][�] = _O_ [�]       - _λ_ [2] _d_ [2] _/ε_ [2][�] _._


The dependence on the norm bound _B_ cancels out, and we recover the same complexity scaling
with respect to the one-norm of the coefficients in the decomposition of the original Hamiltonian,
_λ_, and the base degree _d_ required for the function approximation.


**Comparison with prior works:** From Ref. [21], it is known that Laurent polynomials can approximate most functions of interest, and moreover, any _d_ -degree polynomial achievable by QSVT [1]
can also be approximated by a Laurent polynomial of the same degree. This means our framework
effectively implements QSVT: given an initial state _|ψ_ 0 _⟩_ and an observable _O_, we can estimate


_⟨ψ_ 0 _|f_ ( _H_ ) _[†]_ _O f_ ( _H_ ) _|ψ_ 0 _⟩,_


for any function _f_ that admits a bounded polynomial approximation of degree _d_ . Standard QSVT

[1] requires a circuit depth of _O_ ( _Lλd_ ), and _O_ ( _ε_ _[−]_ [2] ) classical repetitions, while using _O_ (log _L_ ) ancilla

[�] [�]
qubits, and sophisticated multi-qubit controlled operations. In contrast, both our algorithms exhibit
no dependence on _L_, use only a single ancilla qubit, and has a shorter circuit depth whenever
_λd ≪_ _L_ . We summarize the ancilla requirement, circuit depth per coherent run, as well as the
number of classical repetitions required for both our randomized algorithms, and the standard
QSVT, in Table 1. Finally, the recent method of [21] implements QSVT without block encodings,

[1]
using only a single ancilla qubit. This approach requires circuit depth _O_ ( _L_ ( _dλ_ ) [1+] 2 _k_ ), using 2 _k_ -th

[�]

order Suzuki–Trotter formulas combined with classical extrapolation. By contrast, our method
eliminates the dependence on _L_ and achieves shorter depth whenever ( _dλ_ ) [1] _[−]_ [1] _[/]_ [(2] _[k]_ [)] _≪_ _L_ . Since
only low-order formulas ( _k_ = 1 _,_ 2) are feasible in near-term devices, this translates into broad
parameter regimes where our randomized method offers an advantage, while using the same ancilla
resources. We also note that the depth of the algorithm in [21] scales with the nested commutator
norm _λ_ comm = _O_ ( _λ_ ); for certain Hamiltonians, it is possible that _λ_ comm _≪_ _λ_, in which case that
approach may be preferable.


Algorithm Ancilla Circuit depth per coherent run Classical repetitions


Standard QSVT [1] _O_ (log _L_ ) _O_      - ( _Ldλ_ ) _O_      - ~~�~~ _ε_ _[−]_ [2] ~~[�]~~

QSVT with Trotterization [21] 1 _O_    -    - _L_ ( _dλ_ ) [1+] _[o]_ [(1)][�] _O_    -    - _ε_ _[−]_ [2][�]


This work (direct randomized QSVT) 1 or 3 _O_  - ~~�~~ _λ_ [2] _d_ [2] ~~[�]~~ _O_  - ~~�~~ _ε_ _[−]_ [2] ~~[�]~~

This work (QSVT with qDRIFT) 1 _O_ �( _λ_ [2] _d_ [2] ) _O_ �( _ε_ _[−]_ [2] )


Table 1: Comparison with the complexities of different approaches to implement QSVT. Consider a Hermitian operator _H_ = [�] _k_ _[L]_ =1 _[λ][k][H][k]_ [, with] _[ λ]_ [ = max] _[{]_ [�] _k_ _[|][λ][k][|][,]_ [ 1] _[}]_ [, and] _[ ∥][H][k][∥]_ [= 1. Then, for any initial state] _[ |][ψ]_ [0] _[⟩]_ [,]

and any observable _O_, each of these algorithms estimates _⟨ψ_ 0 _|f_ ( _H_ ) _[†]_ _Of_ ( _H_ ) _|ψ_ 0 _⟩_ to additive accuracy _ε∥O∥_,
where _f_ ( _H_ ) can be approximated by a _d_ -degree polynomial bounded in the interval [ _−_ 1 _,_ 1]. For our first
randomized algorithm, the number of ancilla qubits required increases when _f_ is approximated by a real
polynomial, much like standard QSVT. Overall, for each procedure, we compare the total number of ancilla
qubits required, the circuit depth per coherent run, and the total number of classical repetitions needed.


From Theorem 3.8, our second randomized algorithm based on qDRIFT requires only a single
ancilla qubit whenever the target function admits a Laurent polynomial approximation. Hence, it


27


uses just one ancilla qubit regardless of whether the polynomial is real or complex. By contrast, our
first randomized algorithm, structurally similar to standard QSVT, requires three ancilla qubits to
implement real polynomials.


**3.2.1** **Expectation value with respect to the normalized quantum state**


Often, for many applications of QSVT, we are interested in estimating the expectation value
_⟨ψ|O|ψ⟩_, where


_P_ ( _e_ [i] _[H]_ ) _|ψ_ 0 _⟩_
_|ψ⟩_ :=
_∥P_ ( _e_ [i] _[H]_ ) _|ψ_ 0 _⟩∥_ _[.]_


is the normalized state. When _∥P_ ( _e_ [i] _[H]_ ) _|ψ_ 0 _⟩∥≥_ _η_, standard QSVT [1] prepares _|ψ⟩_ using _O_ [�] (1 _/η_ )
rounds of fixed-point amplitude amplification [49]. This increases the circuit depth to _O_ ( _Lλd/_ ( _ηε_ )).

[�]
By contrast, as discussed in Sec. 3.1, our first randomized algorithm cannot accommodate this procedure, and estimating the target expectation value instead requires _O_ ( _η_ _[−]_ [4] _ε_ _[−]_ [2] ) classical repetitions.
Our second algorithm, however, integrates fixed-point amplitude amplification seamlessly. Applying this procedure to the output of any interleaved circuit _W_ yields a modified circuit



_W_ - =



_K/_ 2

- _We_ [i] _[ϕ][j]_ _[|]_ [0] _[,ψ]_ [0] _[⟩⟨]_ [0] _[,ψ]_ [0] _[|]_ _W_ _[†]_ _e_ [i] _[θ][j]_ [(] _[|]_ [0] _[⟩⟨]_ [0] _[|⊗][I]_ [)] _,_


_j_ =1



where _θj, ϕj ∈_ [0 _,_ 2 _π_ ] are QSP phase angles prescribed by the fixed point amplitude amplification
algorithm, and _K_ = _O_ ( _η_ _[−]_ [1] log(1 _/ε_ )). Here, _e_ [i] _[ϕ][j]_ _[|]_ [0] _[,ψ]_ [0] _[⟩⟨]_ [0] _[,ψ]_ [0] _[|]_ is a reflection about the initial state _|ψ_ 0 _⟩_,
controlled by a single ancilla qubit. Crucially, _W_ retains the same interleaved structure as _W_, with

[�]
only an increased circuit depth.
Thus, Theorem 3.7 can be extended to incorporate the modified sequence _W_, enabling the

[�]
preparation of _|ψ⟩_ and the subsequent estimation of _⟨ψ|O|ψ⟩_ . Formally we have


**Theorem 3.9** (QSVT with qDRIFT) **.** _Let H_ = [�] _k_ _[L]_ =1 _[λ][k][H][k][ be the Hermitian decomposition of]_
_H, with ∥Hk∥_ = 1 _, and λ_ = max _{_ [�] _k_ _[|][λ][k][|][,]_ [ 1] _[}][. Also let][ ε][ ∈]_ [(0] _[,]_ [ 1] _[/]_ [2)] _[ be the precision parameter.]_
_Suppose P_ ( _z_ ) = [�] _j_ _[d]_ = _−d_ _[a][j][z][j][ is a Laurent polynomial bounded by]_ [ 1] _[ on]_ [ T][ :=] _[ {][x][ ∈]_ [C][ :] _[ |][x][|]_ [ = 1] _[}][ and]_
_∥P_ ( _e_ [i] _[H]_ ) _|ψ_ 0 _⟩∥≥_ _η for some η ∈_ (0 _,_ 1) _. Furthermore, define_


_|ψ⟩_ = _P_ ( _e_ [i] _[H]_ ) _|ψ_ 0 _⟩/∥P_ ( _e_ [i] _[H]_ ) _|ψ_ 0 _⟩∥._


_Then there exists a quantum algorithm that, for any observable O and initial state |ψ_ 0 _⟩, estimates_


_⟨ψ|O|ψ⟩,_


_with an additive error at most ε∥O∥_ _and constant success probability, using two ancilla qubits. The_
_maximum quantum circuit depth is_



_and the total time complexity is_




 - _λ_ 2 _d_ 2
_O_ 
_η_ [2]


 - _λ_ 2 _d_ 2
_O_ 
_η_ [2] _ε_ [2]


28




_,_ (3.15)


_._ (3.16)


_Proof._ By Theorem 2.6, there exists a GQSP circuit, which we denote _Uf_, that prepares the unnormalized state. This circuit takes the form of an interleaved sequence of Hamiltonian evolutions
and single-qubit rotations:


( _⟨_ 0 _| ⊗_ _I_ ) _Uf_ _|_ 0 _⟩|ψ_ 0 _⟩_ = _P_ ( _e_ [i] _[H]_ ) _|ψ_ 0 _⟩._


The length of this interleaved sequence is _M_ = 2 _d_ + 1, involving _d_ applications of (controlled) _e_ [i] _[H]_

and _d_ applications of (controlled) _e_ _[−]_ [i] _[H]_ .
We employ fixed-point amplitude amplification [49] to prepare the normalized state _|ψ⟩_ with an
additive error at most _ε/_ 4. This ensures that the expectation value of _O_ is with an additive error
at most _∥O∥ε/_ 2. Given that the success probability the initial preparation is _∥P_ ( _e_ [i] _[H]_ ) _|ψ_ 0 _⟩∥_ [2] _≥_ _η_ [2],
the amplification procedure requires _O_ (log(1 _/ε_ ) _/η_ ) rounds of _Uf_ and its inverse, interleaved with
reflection operators of the form _e_ [i] _[ϕ][j]_ _[|]_ [0] _[,ψ]_ [0] _[⟩⟨]_ [0] _[,ψ]_ [0] _[|]_ and _e_ [i] _[θ][j]_ [(] _[|]_ [0] _[⟩⟨]_ [0] _[|⊗][I]_ [)] .
The complete quantum circuit for preparing _|ψ⟩_ can be viewed as a single interleaved Hamiltonian evolution sequence. The length of this new sequence, denoted by _M_ _[′]_, is determined by
the length of the GQSP circuit ( _O_ ( _d_ )) and the number of amplification rounds ( _O_ (log(1 _/ε_ ) _/η_ )).

[�]
Therefore, the total length is _M_ _[′]_ = _O_ ( _d/η_ ). The Hamiltonians involved are still simply _H_, so the

[�]
parameter _λ_ remains unchanged.
We can now directly apply Theorem 3.7 to estimate the expectation value _⟨ψ|O|ψ⟩_ . Substituting
_M_ _[′]_ yields the maximum quantum circuit depth of


_O_             -             - _λ_ [2] _d_ [2] _η_ _[−]_ [2][�] _,_


and a total time complexity of
_O_            -            - _λ_ [2] _d_ [2] _η_ _[−]_ [2] _/ε_ [2][�] _._


Let us now analyze the number of ancilla qubits our procedure requires. The GQSP protocol itself
requires a single ancilla qubit. Now, one additional ancilla qubit is needed to implement the multicontrolled reflection operators required for amplitude amplification. So overall, the entire procedure
requires two ancilla qubits. This completes the proof.


**Comparison with prior works:** A wide range of quantum algorithms have been developed for
estimating expectation values of the form _⟨ψ|O|ψ⟩_, where


_f_ ( _H_ ) _|ψ_ 0 _⟩_
_|ψ⟩_ =
_∥f_ ( _H_ ) _|ψ_ 0 _⟩∥_ _[,]_


and _f_ ( _H_ ) is some function of a given Hamiltonian _H_ . These algorithms fall under the umbrella
of quantum linear algebra, since _f_ ( _H_ ) typically represents a transformation of the eigenvalues of
_H_, such as _H_ _[−]_ [1], _e_ _[−][H]_, or _H_ _[t]_ . For standard QSVT, given a block encoding of _H_ with a Hermitian
decomposition into _L_ local terms, any _f_ ( _H_ ) that admits a bounded polynomial approximation of
degree _d_ can be implemented. The expectation value _⟨ψ|O|ψ⟩_ can then be estimated in three ways,
each of which requires a block encoding of _H_, using _O_ (log _L_ ) ancilla qubits, sophisticated controlled
operations, and a circuit depth depending on _L_ . These variants are as follows:


  - _Without quantum amplitude amplification or estimation:_ The QSVT circuit prepares the state


_≈|_ [¯] 0 _⟩⊗_ _f_ ( _H_ ) _|ψ_ 0 _⟩_ + _|_ Φ _⟩_ _[⊥]_ _,_


where ( _|_ [¯] 0 _⟩⟨_ [¯] 0 _| ⊗_ _I_ ) _|_ Φ _⟩_ _[⊥]_ = 0. This requires a circuit depth of _O_ ( _Lλd_ ) and _O_ (log _L_ ) ancillas.

[�]
The estimation proceeds by measuring the first register at the end of each run; whenever it


29


Algorithm Ancilla Circuit depth per coherent run Classical repetitions


Standard QSVT [1] _O_ (log _L_ ) _O_      - ( _Ldλ/η_ ) _O_      - ~~�~~ _ε_ _[−]_ [2] ~~[�]~~

QSVT with Trotterization [21] 2 _O_    -    - _L_ ( _dλ/η_ ) [1+] _[o]_ [(1)][�] _O_    -    - _ε_ _[−]_ [2][�]


This work (direct randomized QSVT) 1 or 3 _O_  - ~~�~~ _λ_ [2] _d_ [2] ~~[�]~~ _O_  - ~~�~~ _ε_ _[−]_ [2] _η_ _[−]_ [4] ~~[�]~~

This work (QSVT with qDRIFT) 2 _O_ �( _λ_ [2] _d_ [2] ) _O_ �( _ε_ _[−]_ [2] )


Table 2: Comparison with the complexities of different approaches to implement QSVT. Consider a Hermitian operator _H_ = [�] _k_ _[L]_ =1 _[λ][k][H][k]_ [, with] _[ λ]_ [ = max] _[{]_ [�] _k_ _[|][λ][k][|][,]_ [ 1] _[}]_ [, and] _[ ∥][H][k][∥]_ [= 1. Then, for initial] _[ |][ψ]_ [0] _[⟩]_ [, and any]

observable _O_, each of these algorithms estimates _⟨ψ|O|ψ⟩_ to additive accuracy _ε∥O∥_, where _f_ ( _H_ ) can be
approximated by a _d_ -degree polynomial bounded in the interval [ _−_ 1 _,_ 1], and _|ψ⟩_ = _f_ ( _H_ ) _|ψ_ 0 _⟩/∥f_ ( _H_ ) _|ψ_ 0 _⟩∥_ .
For our first randomized algorithm, the number of ancilla qubits required increases when _f_ is approximated
by a real polynomial, much like standard QSVT. Overall, for each procedure, we compare the total number
of ancilla qubits required, the circuit depth per coherent run, and the total number of classical repetitions
needed.


is in _|_ [¯] 0 _⟩_, one measures _O_ on the second register. Since this occurs with probability Θ(1 _/η_ [2] ),
one needs _O_ ( _η_ _[−]_ [2] _ε_ _[−]_ [2] ) repetitions. By comparison, our randomized algorithm avoids block
encodings and uses only a single ancilla qubit, with circuit depth _O_ ( _λ_ [2] _d_ [2] ) per run. However,

[�]
it requires _O_ ( _η_ _[−]_ [4] _ε_ _[−]_ [2] ) repetitions. Thus, we achieve shorter circuit depth whenever _λd ≪_ _L_,

[�]
although our total complexity is higher.


  - _With quantum amplitude amplification and classical repetitions:_ Here, fixed-point amplitude
amplification is used to directly prepare _|ψ⟩_, followed by _O_ ( _ε_ _[−]_ [2] ) classical repetitions. The

[�]
circuit depth per coherent run increases to _O_ ( _Lλd/η_ ), with _O_ (log _L_ ) ancillas. In contrast,

[�]
from Theorem 3.7, our randomized algorithm achieves circuit depth _O_ ( _λ_ [2] _d_ [2] _/η_ [2] ) with only

[�]
two ancillas. This yields a depth advantage whenever _λd/η ≪_ _L_ . A detailed side-by-side
comparison is given in Table 2.


  - _Coherent estimation using quantum amplitude estimation (QAE):_ If block encodings of both
_H_ and _O_ are available, one may use QAE to coherently estimate _⟨ψ|O|ψ⟩_, reducing the
dependence on precision from 1 _/ε_ [2] to 1 _/ε_ . However, this comes at the price of exponentially
larger circuit depth. Moreover, for observables of the form



_O_ =



_LO_


_hjOj,_

_j_ =1



the block encoding of _O_ incurs additional cost: ancilla requirements increase to _O_ (log( _L·LO_ )),
and the total depth becomes
_O_           -           - _Lλd_ _[L][O]_           - _._

[+]




_[L][O]_
_εη_ [+] _ε_




_._



_ε_



These overheads make QAE-based approaches impractical for early fault-tolerant architectures, so we do not benchmark against them.


Finally, we compare our randomized algorithm with the recent block-encoding-free QSVT approach based on 2 _k_ -th order Suzuki–Trotter formulas [21]. Their method achieves circuit depth


30


scaling as _O_ ( _L_ ( _dλ/η_ ) [1+1] _[/]_ [(2] _[k]_ [)] ), while our randomized algorithm removes the dependence on _L_ . Con
[�]
sequently, our approach achieves a shorter depth per coherent run whenever


( _dλ/η_ ) [1] _[−]_ [1] _[/]_ [(2] _[k]_ [)] _≪_ _L._


This advantage is particularly pronounced for small Trotter orders ( _k_ = 1 _,_ 2), which are the only
practically feasible choices in early fault-tolerant architectures.
Overall, both our randomized algorithms require a circuit depth that has a quadratic dependence on the degree of the underlying polynomial. In the next section, we show that this is quite
fundamental by proving a matching lower bound for any generic quantum algorithm implementing
polynomial transformations within this access model.

### **4 Lower bounds**


The circuit depth of standard QSVT scales linearly with the degree of the target polynomial,
and this linear dependence is known to be optimal [1, 50]. In contrast, both of our randomized
algorithms exhibit a quadratic dependence on the polynomial degree. This naturally raises the
question: can this scaling be improved? In this section, we show that the answer is negative. Within
the sampling-access model considered here, a quadratic dependence is unavoidable. More precisely,
we establish lower bounds on both the sample complexity and circuit depth of any randomized
quantum algorithm in this model that aims to implement a target function _f_ ( _x_ ). These bounds
demonstrate that our algorithms already achieve optimal scaling in this setting. Interestingly, the
same limitations extend beyond our constructions, applying equally to other randomized approaches
such as Hamiltonian simulation via qDRIFT [17] and qSWIFT [26], as well as the more recent
randomized LCU methods [27, 28].
We focus on the canonical target function _f_ ( _x_ ) = _e_ [i] _[xt]_, for which it is well known that a
polynomial of degree Θ( _t_ ) suffices to approximate the evolution. In the sampling-access model,

[�]
we prove that both the sample complexity and the circuit depth per round of any randomized
quantum algorithm must scale as Ω( _t_ [2] ). This shows that a quadratic dependence on the polynomial
degree is unavoidable for any method, including QSVT, that aims to implement general polynomial
transformations of a Hermitian operator.
To make this concrete, we restrict to operators _H_ that are linear combinations of Pauli strings,
a special but representative subclass of the Hamiltonians considered in this work. In this setting,
we do not have access to the full description of _H_ . Instead, only sampling access to individual
Pauli terms according to their probability weights is available. We refer to this setting as the _Pauli_
_sample access model_, formally defined below.

**Definition 4.1** (Pauli sample access model) **.** Suppose _H_ = [�] _k_ _[L]_ =1 _[λ][k][P][k]_ [ is the Pauli decomposition]
of the Hermitian operator _H_ . In the _Pauli sample access model_, the algorithm does not have access
to the full description of _H_ . Instead, it can only access _H_ by sampling from the distribution


            -             _D_ = ( _|λk|/λ, e_ [i] _[θ][k]_ _Pk_ ) : _k ∈_ [ _L_ ] _,_


where _λ_ = [�] _k_ _[|][λ][k][|]_ [ and] _[ λ][k]_ [ =] _[ e]_ [i] _[θ][k]_ _[|][λ][k][|]_ [.]

As discussed, each query to the distribution _D_ yields a Pauli operator _e_ [i] _[θ][k]_ _Pk_ up to some phase
_e_ [i] _[θ][k]_ with probability _|λk|/λ_ . We treat this distribution as a black box, meaning that the algorithm
may sample from it, but has no direct knowledge of the probabilities themselves. Given a target
function _f_ ( _x_ ) and two states _|ψ_ 0 _⟩, |ψ_ 1 _⟩_, the task is to estimate


_⟨ψ_ 1 _|f_ ( _H_ ) _|ψ_ 0 _⟩,_


31


with an error at most _ε_, while minimizing the number of queries to _D_ . To prove our lower bound,
we establish a connection between this estimation task and a tomography problem, formulated as
follows.


**Lemma 4.2** (Theorem 9.2 of [51]) **.** _Let |ψ⟩_ = [�] _k_ _[L]_ =1 _[x][k][|][k][⟩]_ _[be a unknown quantum state. Suppose]_
_we are given only classical samples obtained from computational-basis measurements of |ψ⟩. Then,_
_in order to estimate all amplitudes up to their magnitudes, i.e. to compute |xk|±δ for every k ∈_ [ _L_ ] _,_
_the sample complexity is lower bounded by_ Ω(1 _/δ_ [2] ) _._


From the proof of Lemma 9.3 of [51], this lower bound continues to hold even in the case where
half of the amplitudes are
_xk_ = ~~�~~ (1 + _η_ ) _/L,_



and the other half are
_xk_ = ~~�~~



(1 _−_ _η_ ) _/L_



_√_
for some small _η_ . Note that the difference between these two quantities is Θ( _η/_



for some small _η_ . Note that the difference between these two quantities is Θ( _η/_ _L_ ). So the error

_√_
in Lemma 4.2 should be set as _δ_ = Θ( _η/_ _L_ ). In what follows, we use this structured setting to

derive two distinct lower bounds on the sample complexity, depending on the target accuracy of
the estimate. In particular, we consider the case _L_ = _O_ (1), in which the sample complexity in
Lemma 4.2 is lower bounded by Ω(1 _/η_ [2] ).



**Theorem 4.3** (Sample complexity lower bound: Arbitrary accuracy) **.** _In the Pauli sample access_
_model, the sample complexity of estimating ⟨ψ_ 1 _|e_ [i] _[Ht]_ _|ψ_ 0 _⟩_ _up to arbitrary accuracy is lower bounded_
_by_ Ω( _t_ [2] ) _._


_Proof._ Consider a quantum state _|ψ⟩_ = [�] _k_ _[L]_ =1 _[x][k][|][k][⟩]_ [, such that half of its amplitudes are]



_xk_ = �(1 + _η_ ) _/L,_


and the other half
_xk_ = �(1 _−_ _η_ ) _/L._


Furthermore, suppose



_H_ =



_L_


_αkXk,_ with _αk_ = _|xk|_ [2] _∈{_ (1 + _η_ ) _/L,_ (1 _−_ _η_ ) _/L},_

_k_ =1



and _Xk_ being the Pauli _X_ acting on the _k_ -th qubit. Consider the distribution


_D_ = _{_ ( _|xk|_ [2] _, Xk_ ) : _k ∈_ [ _L_ ] _}._


Then, measuring _|ψ⟩_ in the computational basis is equivalent to sampling from _D_ . Observe that



_e_ [i] _[Ht]_ =



_L_


_e_ [i] _[α][k][X][k][t]_ _,_

_k_ =1



furthermore,







_e_ [i] _[α][k][X][k][t]_ =




- cos ( _αkt_ ) i sin ( _αkt_ )


i sin ( _αkt_ ) cos ( _αkt_ )



_._ (4.1)



By choosing _t_ = _[L]_




_[L]_ _[π]_

_η_ _[·]_ 4



4 [= Θ(1] _[/η]_ [), we obtain]



32







[1] - _π_

_η_ 4



 cos ��1 + [1]

_η_





_π_ - i sin ��1 + [1]

4 _η_



_π_ 
4






 _,_ if _αk_ = (1 + _η_ ) _/L_



(4.2)




[1] - _π_

_η_ 4



i sin ��1 + [1]



_π_ - cos ��1 + [1]

4 _η_



_π_ 
4




[1] - _π_

_η_ 4




[1] - _π_

_η_ 4



_e_ [i] _[α][k][X][k][t]_ =























[1] - _π_

_η_ 4



 ��

cos 1 _−_ [1]

_η_






[1] - _π_

_η_ 4



_π_ - ��

_−_ i sin 1 _−_ [1]
4 _η_



_π_ 
4






 _,_ if _αk_ = (1 _−_ _η_ ) _/L._


















[1] - _π_

_η_ 4



��

_−_ i sin 1 _−_ [1]



_π_ - ��

cos 1 _−_ [1]
4 _η_



_π_ 
4




[1] - _π_

_η_ 4



The first columns of both matrices form an orthogonal basis, written as



_|α_ + _⟩_ := cos ��1 + _η_ [1]


��
_|α−⟩_ := cos 1 _−_ [1]



_π_ - _|_ 0 _⟩_ + i sin ��1 + [1]

4 _η_


_π_ - ��

_|_ 0 _⟩−_ i sin 1 _−_ [1]
4 _η_



_π_ - _|_ 1 _⟩,_

4

_π_ - _|_ 1 _⟩._

4




[1]  - _π_

_η_ 4




[1] - _π_

_η_ 4




[1] - _π_

_η_ 4


[1] - _π_

_η_ 4



Measuring in the _|α±⟩_ basis tells us whether _αk_ = (1 + _η_ ) _/L_ or _αk_ = (1 _−_ _η_ ) _/L_ . Therefore,
if we could compute _e_ [i] _[Ht]_ _|_ 0 _[L]_ _⟩_, and measure the resulting state, we could estimate every _αk_ and
consequently every _xk_, exactly.
From Lemma 4.2, we know that the sample complexity of computing all _xk_ with an additive
accuracy of Θ( _η_ ) is Ω(1 _/η_ [2] ) when _L_ = _O_ (1). So, the sample complexity lower bound for computing
_e_ [i] _[Ht]_ _|_ 0 _[L]_ _⟩_ is Ω(1 _/η_ [2] ) = Ω( _t_ [2] ). As _L_ = _O_ (1), this lower bound also holds for the task of computing


_⟨ψ_ 1 _|e_ [i] _[Ht]_ _|ψ_ 0 _⟩,_


as we could simply check all _⟨ψ|e_ [i] _[Ht]_ _|_ 0 _[L]_ _⟩_ with _|ψ⟩∈{|α_ + _⟩, |α−⟩}_ _[⊗][L]_ which would return the information about _xk_, for all _k ∈_ [ _L_ ].


It is possible to slightly modify the above proof to show that the sample complexity is lower
bounded by Ω( _t_ [2] _/ε_ [2] ) when the task is to estimate


_⟨ψ_ 1 _|e_ [i] _[Ht]_ _|ψ_ 0 _⟩_


with an error at most _ε_ .


**Theorem 4.4** (Sample complexity lower bound: Fixed accuracy) **.** _In the Pauli sample access_
_model, the sample complexity of estimating ⟨ψ_ 1 _|e_ [i] _[Ht]_ _|ψ_ 0 _⟩_ _up to accuracy ε is lower bounded by_
Ω( _t_ [2] _/ε_ [2] ) _._


_Proof._ We consider the case _L_ = 2. Let _η >_ 0 be a small parameter. Define




~~�~~
_x_ [(+)] :=




~~�~~

1+ _η_ _x_ [(] _[−]_ [)] :=

2 _[,]_




~~�~~

_η_ _x_ [(] _[−]_ [)] :=

2 _[,]_



1 _−η_

2 _[.]_



As in Lemma 4.2, we construct two promise instances with amplitudes ( _x_ [(+)] _, x_ [(] _[−]_ [)] ) and ( _x_ [(] _[−]_ [)] _, x_ [(+)] ),
respectively. Define the operator



_H_ = _α_ 1 _X_ 1 + _α_ 2 _X_ 2 _,_ _α_ 1 _, α_ 2 _∈_ - 1+ _η_




_[−][η]_ - _,_

2



_η_ [1] _[−][η]_

2 _[,]_ 2



and set _t_ = Θ�1 _/_ _[√]_ ~~_η_~~ �. Then, for each _k ∈{_ 1 _,_ 2 _}_,







_e_ [i] _[α][k][X][k][t]_ =




- cos( _αkt_ ) i sin( _αkt_ )


i sin( _αkt_ ) cos( _αkt_ )


33



_._


Let _|ϕ_ 1 _⟩_ denote the first column corresponding to _αk_ = (1 + _η_ ) _/_ 2, and _|ϕ_ 2 _⟩_ the first column for
_αk_ = (1 _−_ _η_ ) _/_ 2. So, we have
_⟨ϕ_ 1 _|ϕ_ 2 _⟩_ = 1 _−_ Θ( _η_ ) _,_


and hence
_∥|ϕ_ 1 _⟩−|ϕ_ 2 _⟩∥_ = Θ( _[√]_ ~~_η_~~ ) _._


Take the input _|ψ_ 0 _⟩_ = _|_ 0 _⟩⊗|_ 0 _⟩_ . Then


_e_ [i] _[Ht]_ _|ψ_ 0 _⟩∈_               - _|ϕ_ 1 _⟩⊗|ϕ_ 2 _⟩, |ϕ_ 2 _⟩⊗|ϕ_ 1 _⟩_               - _._



Define



_|ϕ_ 1 _⟩−|ϕ_ 2 _⟩_
_|τ_ _⟩_ := _|ψ_ 1 _⟩_ := _|τ_ _⟩⊗|_ 0 _⟩._
_∥|ϕ_ 1 _⟩−|ϕ_ 2 _⟩∥_ _[,]_



Consider
_a_ = _⟨ψ_ 1 _|e_ [i] _[Ht]_ _|ψ_ 0 _⟩._


If the time evolved state is _|ϕ_ 1 _⟩⊗|ϕ_ 2 _⟩_, then

_a_ = _⟨ψ_ 1 _|_ ( _|ϕ_ 1 _⟩⊗|ϕ_ 2 _⟩_ ) = _⟨τ_ _|ϕ_ 1 _⟩· ⟨_ 0 _|ϕ_ 2 _⟩_ = Θ( _∥|ϕ_ 1 _⟩−|ϕ_ 2 _⟩∥_ ) = Θ( _[√]_ ~~_η_~~ ) _,_


while if it is _|ϕ_ 2 _⟩⊗|ϕ_ 1 _⟩_, then the value of _a_ is the negative of this. Thus, the two promise instances
yield values of _a_ differing by

∆ _a_ = Θ ( _∥|ϕ_ 1 _⟩−|ϕ_ 2 _⟩∥_ ) = Θ( _[√]_ ~~_η_~~ ) _._


To resolve the two cases, an algorithm must estimate _a_ to additive accuracy

_ε_ = Θ( _[√]_ ~~_η_~~ ) _._

Since _t_ = Θ(1 _/_ _[√]_ ~~_η_~~ ), we equivalently have _η_ = Θ�1 _/t_ [2][�], and _ε_ = Θ(1 _/t_ ). So,

_t_ [2] [= Θ] �1 _/η_ [2][�] _._

_ε_ [2]


By Lemma 4.2, distinguishing the two promise families requires Ω(1 _/η_ [2] ) queries to _D_ . Substituting the relations above gives the claimed lower bound of Ω( _t_ [2] _/ε_ [2] ) queries.


The sample complexity lower bound (Theorem 4.4) also yields a lower bound on the circuit
depth of randomized algorithms in the Pauli sample access model. Consider algorithms of the form


_WQ_ 1 _,...,Qc_ = _U_ 1 _Q_ 1 _U_ 2 _Q_ 2 _· · · UcQcUc_ +1 _,_


where each _Qi_ is generated independently from a constant number _s_ = _O_ (1) of samples drawn from
_D_, and _U_ 1 _, . . ., Uc_ +1 are fixed unitaries independent of the samples. Moreover, we assume that the
depth of each _Qi_ is constant.
Suppose the algorithm executes _R_ independent runs of this circuit and estimates some classical
quantity (e.g. the empirical mean) from the outcomes. Then the total number of oracle queries is
_N_ tot = _R·_ ( _cs_ ). By Hoeffding’s inequality, estimation with additive precision _ε_ requires _R_ = Θ(1 _/ε_ [2] )
repetitions [52], so _N_ tot = Θ( _cs/ε_ [2] ). Since Theorem 4.4 asserts that _N_ tot = Ω( _t_ [2] _/ε_ [2] ), we conclude
that
_c · s_ = Ω( _t_ [2] ) _._


Since each sampled unitary has constant depth, the circuit depth per run is therefore Ω( _t_ [2] ). This
is formally stated as follows.


34


**Corollary 4.5** (Circuit complexity lower bound) **.** _In the Pauli sample access model, assume that_
_the number of classical repetitions is independent of the evolution time t. Then the circuit depth of_
_any randomized quantum algorithm for estimating ⟨ψ_ 1 _|e_ [i] _[Ht]_ _|ψ_ 0 _⟩_ _is lower bounded by_ Ω( _t_ [2] ) _._


Our lower bound results are fundamental. They demonstrate that any generic quantum algorithm within this access model that estimates properties of the state _f_ ( _H_ ) _|ψ_ 0 _⟩_, for any broad class
of functions _f_, must incur circuit depth scaling quadratically with the minimum degree of the polynomial approximating _f_ ( _H_ ). This establishes that both of our randomized algorithms for QSVT
are essentially optimal in their dependence on the polynomial degree. Beyond QSVT, these lower
bounds also apply to recently introduced randomized LCU methods [27,28]. Moreover, they extend
naturally to randomized Hamiltonian simulation techniques such as qDRIFT [17], its higher-order
variant qSWIFT [26], and randomized multiproduct formulas [53]. All of these methods exhibit
a quadratic dependence on the evolution time _t_, and our results show that this scaling is in fact
optimal within this access model. In this sense, our lower bounds delineate the fundamental performance limits of randomized quantum algorithms for implementing _f_ ( _H_ ) under sample access to
_H_, making explicit which trade-offs are unavoidable and providing a benchmark for what future
advances in this framework can realistically achieve. In the next section, we consider concrete
applications of our randomized algorithms for QSVT.

### **5 Applications**


We apply our algorithms to two problems of broad practical interest: (i) solving quantum linear
systems, and (ii) ground state property estimation.


**5.1** **Quantum linear systems**


The quantum linear systems algorithm [54–56] has been a cornerstone of quantum algorithms,
with wide-ranging applications to regression [3,6], machine learning, and the solution of differential
equations [57,58]. Formally, let _A ∈_ C _[N]_ _[×][N]_ is a matrix with operator norm _∥A∥_ = 1, whose singular
values lie in the range [ _−_ 1 _, −_ 1 _/κ_ ] _∪_ [1 _/κ,_ 1], where _∥A_ _[−]_ [1] _∥_ = _κ_ is the condition number of _A_ . Given
efficient access to a state preparation oracle for _|b⟩_, the goal is to estimate the expectation value
_⟨x|O|x⟩_ to additive accuracy _ε_, where


_A_ _[−]_ [1] _|b⟩_
_|x⟩_ =
_∥A_ _[−]_ [1] _|b⟩∥_ _[.]_


The complexity of quantum linear systems algorithms has been refined through successive improvements, with most prior work assuming access to a block encoding _UA_ of matrix _A_ . Algorithms
based on LCU or QSVT typically achieve linear dependence on _κ_ by employing sophisticated subroutines such as variable-time amplitude amplification (VTAA) [3, 55, 59]. An alternative line of
work, inspired by adiabatic quantum computation [56], makes only _O_ ( _κ_ log(1 _/ε_ )) queries to the
block encoded operator, which is optimal, without having to use VTAA.
More recently, Ref. [21] demonstrated that, given the full description of a Pauli decomposition of
_A_, the target expectation value can be estimated using a single interleaved sequence of Hamiltonian
evolutions. This sequence, which combines a discretized adiabatic evolution with an eigenstate
filtering step, takes the form



_W_ := _V_ 0



_M_


_e_ [i] _[H]_ [(] _[ℓ]_ [)] _Vℓ,_

_ℓ_ =1


35


with total length of _M_ = _O_ ( _κ_ ) and acts on a system of log( _N_ ) + 4 qubits. In this construction,

[�]
Hamiltonian evolution is approximated using higher-order Trotterization, yielding a quasi-linear
dependence on _κ_ .
In this work, we develop a randomized quantum linear systems algorithm that builds on the
above framework. Specifically, we estimate the final expectation value by replacing the Hamiltonian evolution operators in _W_ with qDRIFT. In this way, the entire procedure can be viewed
as a particular instance of the operator _W_, and its complexity follows directly by applying the
substitutions prescribed in Theorem 3.7.


**Theorem 5.1** (Randomized Quantum linear systems algorithm) **.** _Let Ax_ = _b be a system of linear_
_equations, where A ∈_ C _[N]_ _[×][N]_ _with ∥A∥_ = 1 _and ∥A_ _[−]_ [1] _∥_ = _κ, and let ε ∈_ (0 _,_ 1 _/_ 2) _be the precision_
_parameter. Let A_ = [�] _k_ _[L]_ =1 _[λ][k][P][k][ be the Pauli decomposition of][ A][. Given a unitary oracle][ U][b][ that]_
_prepares the state |b⟩_ _and an observable O. There exists a randomized quantum algorithm that_
_estimates_
_⟨x|O|x⟩,_


_with an additive error at most ε∥O∥, using only_ log( _N_ ) + 4 _qubits. The maximum quantum circuit_
_depth is_ _O_ [�] ( _λ_ [2] _κ_ [2] ) _, while the total time complexity and the number of queries to Ub and Ub_ _[†]_ _[are]_
_O_ �( _λ_ [2] _κ_ [2] _/ε_ [2] ) _, where λ_ = [�] _k_ _[L]_ =1 _[|][λ][k][|][.]_


_Proof._ Ref. [21] establishes that the quantum linear systems problem can be reduced to estimating
an expectation value for an interleaved Hamiltonian evolution sequence _W_, acting on a space of
log( _N_ ) + 4 qubits. This sequence has a total length of _M_ = _O_ ( _κ_ ). The Hamiltonians _H_ [(] _[ℓ]_ [)] within

[�]
it are constructed from the Pauli decomposition of _A_ such that the norm-sum parameter _λ_ scales
as _O_ ( [�] _[L]_ _k_ =1 _[|][λ][k][|]_ [).]
A key property of this construction is that each Hamiltonian _H_ [(] _[ℓ]_ [)] is a sum of _O_ ( _L_ ) simple

terms, _H_ [(] _[ℓ]_ [)] = [�] _k_ _[H]_ _k_ [(] _[ℓ]_ [)][, where the evolution] _[ e]_ [i] _[H]_ _k_ [(] _[ℓ]_ [)] _[τ]_ under each individual term (for any _τ ∈_ R) can
be implemented efficiently. Specifically, each such evolution, as well as each unitary _Vℓ_, requires a
circuit with polylog( _N_ ) elementary gates and at most two queries to the oracle _Ub_ and its inverse.
This setup is perfectly suited for the qDRIFT-based framework presented in Theorem 3.7.
Substituting the parameters _M_ = _O_ ( _κ_ ) and _λ_ yields a total time complexity and query complexity

[�]
of _O_ ( _λ_ [2] _M_ [2] _/ε_ [2] ) = _O_ (( _λκ/ε_ ) [2] ), and a maximum circuit depth of _O_ ( _λ_ [2] _M_ [2] ) = _O_ ( _λ_ [2] _κ_ [2] ).

[�] [�] [�] [�]


Remarkably, our algorithm requires only four ancilla qubits, avoids block encodings entirely,
and achieves a circuit depth independent of _L_ . We compare this to other works in Table 3.
Standard QSVT requires access to a block encoding of _H_, which, as discussed earlier, is costly
to construct: it demands several ancilla qubits and intricate controlled operations [1]. The resulting
algorithm has circuit depth _O_ [�] ( _λLκ_ [2] ) and uses _⌈_ log2 _L⌉_ +1 ancilla qubits. Moreover, if the observable
_O_ is measured at the end of each run, the entire procedure must be repeated _O_ (1 _/ε_ [2] ) times. In

[�]
contrast, our randomized approach achieves strictly shorter depth whenever _λ ≪_ _L_, while using
only four ancilla qubits.
For QSVT, the dependence on _κ_ can be improved to linear using variable-time amplitude
amplification (VTAA), but this comes at the cost of even more ancilla qubits and sophisticated
controlled operations, making it impractical for early fault-tolerant devices. Similarly, if a block
encoding of _O_ is available, one may employ quantum amplitude estimation to quadratically reduce
the dependence on inverse precision from 1 _/ε_ [2] to 1 _/ε_ . However, this improvement is offset by an
exponential increase, in terms of _ε_, in circuit depth, to _O_ ( _Lλκ_ [2] _/ε_ ) in each round of repetition,

[�]
along with the practical difficulty of implementing amplitude estimation using early fault-tolerant
architectures.


36


Algorithm Ancilla Circuit depth per coherent run Classical repetitions


Standard QSVT [1] _⌈_ log2 _L⌉_ + 1 _O_     - ~~�~~ _Lλκ_ [2] ~~[�]~~ _O_     - ~~�~~ _ε_ _[−]_ [2] ~~[�]~~

State-of-the-art [56] _⌈_ log2 _L⌉_ + 6 _O_      - ( _Lλκ_ ) _O_      -      - _ε_ _[−]_ [2][�]

QSVT with Trotterization [21] 4 _O_   -   - _L_ ( _λκ_ ) [1+] _[o]_ [(1)][�] _O_   -   - _ε_ _[−]_ [2][�]


Other randomized methods [27, 28] 1 _O_ �( _λ_ [2] _κ_ [2] ) _O_  - ~~�~~ _κ_ [4] _ε_ _[−]_ [2] ~~[�]~~

This work (Theorem 5.1) 4 _O_ �( _λ_ [2] _κ_ [2] ) _O_ �( _ε_ _[−]_ [2] )


Table 3: Comparison of the complexities of different quantum linear systems algorithms. Consider a
Hermitian operator _A_ = [�] _k_ _[L]_ =1 _[λ][k][P][k]_ [, with] _[ λ]_ [ =][ �] _k_ _[L]_ =1 _[|][λ][k][|]_ [,] _[ ∥][A][∥]_ [= 1, and] _[ ∥][A][−]_ [1] _[∥]_ [=] _[ κ]_ [.] Then, given a
procedure for preparing the state _|b⟩_, and any observable _O_, each of these algorithms estimates _⟨x|O|x⟩_ to
additive accuracy _ε∥O∥_ . We compare the total number of ancilla qubits required, the circuit depth per
coherent run, and the total number of classical repetitions needed.


The state-of-the-art algorithm by Costa et al. [56] requires a circuit depth of _O_ ( _Lλκ_ ), requiring

[�]
block encoding access to _H_, while incurring an overhead of _⌈_ log2 _L⌉_ + 6 ancilla qubits. Despite
being resource-efficient, our randomized algorithm requires shorter circuit depth whenever _λκ ≪_ _L_ .
Compared to the recent Trotter–extrapolation approach of [21], which achieves a time com
[1]
plexity of _O_ ( _L_ ( _λκ_ ) [1+] 2 _k_ ) using 2 _k_ -th order Suzuki–Trotter formulas and classical extrapolation,

[�]

our method requires a shorter depth whenever ( _λκ_ ) [1] _[−]_ [1] _[/]_ [(2] _[k]_ [)] _≪_ _L_ . Since only low-order formulas ( _k_ = 1 _,_ 2) are practical in near-term settings, there are broad parameter regimes where our
randomized method provides an advantage, while using the same number of ancilla qubits.
Finally, our method provides a polynomial advantage over randomized LCU-based linear systems algorithms [21, 28]. Although the circuit depths are comparable, our approach reduces the
required number of classical repetitions by a factor of _κ_ [4], leading to a substantial overall speedup.


**5.2** **Ground state property estimation**


Consider a Hamiltonian _H_ with spectral decomposition _H_ = [�] _i_ _[ξ][i][|][v][i][⟩⟨][v][i][|]_ [, where the eigenvalues] _[ ξ][i]_
are ordered increasingly. The eigenstate _|v_ 0 _⟩_ corresponding to the smallest eigenvalue _ξ_ 0 is called
the ground state, and _ξ_ 0 is the ground state energy. Preparing the ground state and estimating
its energy are among the most fundamental problems in quantum computing and quantum manybody physics. In full generality, these tasks are QMA-hard [60], but they become efficiently solvable
under additional assumptions. In particular, one typically assumes (i) knowledge of the spectral
gap ∆separating the ground state from the first excited state, and (ii) access to a guess state _|ϕ_ 0 _⟩_
that has at least _γ_ overlap with the ground state, i.e. _|⟨ϕ_ 0 _|v_ 0 _⟩| ≥_ _γ_ .
Furthermore, we assume that any Hamiltonian _H_ of interest can be expressed as a sum of _L_
local terms, namely, _H_ = [�] _k_ _[L]_ =1 _[λ][k][H][k]_ [, with] _[ ∥][H][k][∥]_ [= 1, and] _[ λ]_ [ = max] _[{]_ [�] _k_ _[|][λ][k][|][,]_ [ 1] _[}]_ [. We now formally]
state the ground state property estimation problem:


**Problem 5.2** (Ground state property estimation) **.** _Let H_ = [�] _k_ _[L]_ =1 _[λ][k][H][k][ be a Hamiltonian with]_
_∥Hk∥_ = 1 _and λ_ = max _{_ [�] _k_ _[|][λ][k][|][,]_ [ 1] _[}][. Suppose][ ε][ ∈]_ [(0] _[,]_ [ 1] _[/]_ [2)] _[ and that we can efficiently prepare an]_
_initial guess state |ϕ_ 0 _⟩_ _such that it has an overlap of at least γ with the ground state |v_ 0 _⟩_ _of H,_
_i.e. |⟨ϕ_ 0 _|v_ 0 _⟩| ≥_ _γ, for γ ∈_ (0 _,_ 1) _. Furthermore, assume that there is a spectral gap_ ∆ _separating the_
_ground state energy ξ_ 0 _from the rest of the spectrum. Then, the goal is to compute ⟨v_ 0 _|O|v_ 0 _⟩_ _up to_
_additive error ε∥O∥_ _for any given observable O._


37


We use Theorem 3.9, to obtain the following result.


**Theorem 5.3** (Randomized Ground state property estimation) **.** _Suppose that there is a spectral_
_gap_ ∆ _of H separating the ground state energy ξ_ 0 _from the first excited state energy ξ_ 1 _such that_


_ξ_ 0 _≤_ _µ −_ ∆ _/_ 2 _< µ_ + ∆ _/_ 2 _≤_ _ξ_ 1 _,_


_for some given µ. Then there is a randomized quantum algorithm for the ground state property_
_estimation Problem 5.2 using two ancilla qubits. The maximum circuit depth is_


_O_             - �( _λ/_ ∆ _γ_ ) [2][�] _,_


_and the total time complexity is_
_O_             - �( _λ/_ ∆ _γε_ ) [2][�] _._


_Proof._ We first rescale _H_ to _H_ _[′]_ = _H/λ_ so that _∥H_ _[′]_ _∥≤_ 1. The spectral gap of _H_ _[′]_ is ∆ _[′]_ = ∆ _/λ_ and
the norm-sum parameter _λ_ _[′]_ = _λ/λ_ = 1. The core of the algorithm is to implement an approximate
projection onto the ground state. As shown in [21], this can be done by constructing a Laurent
polynomial _P_ ( _z_ ) that approximates a shifted sign function, which acts as a filter for the ground
state energy. Specifically, there exists a Laurent polynomial _P_ ( _z_ ) bounded by 1 on T, such that
_∥P_ ( _e_ [i] _[H]_ _[′]_ ) _|ϕ_ 0 _⟩−⟨v_ 0 _|ϕ_ 0 _⟩|v_ 0 _⟩∥≤_ _ε/_ (8 _γ_ ), and the degree of _P_ ( _z_ ) is




  - 1
_d_ = _O_



_γε_




_._



1 [1]

[log]
∆ _[′]_ _γε_




- - _λ_
= _O_

[�]

∆



Thus the normalized QSVT state _|ϕ⟩_ := _P_ ( _e_ [i] _[H]_ _[′]_ ) _|ϕ_ 0 _⟩/∥P_ ( _e_ [i] _[H]_ _[′]_ ) _|ϕ_ 0 _⟩∥_ is an ( _ε/_ 4)-approximation of
the ground state _|v_ 0 _⟩_ up to a global phase factor. This ensures that _|⟨ϕ|O|ϕ⟩−⟨v_ 0 _|O|v_ 0 _⟩| ≤_ _ε∥O∥/_ 2.
We can now directly apply Theorem 3.9 to estimate _⟨ϕ|O|ϕ⟩_ with an error at most _ε∥O∥/_ 2,
which yields a total time complexity of




 - ( _λ′_ )2 _d_ 2
_O_ 
_γ_ [2] _ε_ [2]




- - _λ_ [2]
= _O_

[�]

∆ [2] _γ_ [2] _ε_ [2]




_._



and a maximum circuit depth of




 - ( _λ′_ )2 _d_ 2
_O_ 
_γ_ [2]




- - _λ_ 2
= _O_

[�]

∆ [2] _γ_ [2]




_,_



while using two ancilla qubits. This provides an estimate of _⟨v_ 0 _|O|v_ 0 _⟩_ within an error _ε∥O∥_ .


We summarize a detailed comparison of our approach with prior methods in Table 4. The
state-of-the-art algorithm of Lin and Tong [10] constructs a block encoding of _H_ and then applies QSVT together with fixed-point amplitude amplification to prepare the ground state. This
requires _O_ (log _L_ ) ancilla qubits and yields a quantum circuit depth of _O_ ( _Lλ_ ∆ _[−]_ [1] _γ_ _[−]_ [1] ). The target

[�]
expectation value must then be estimated using _O_ (1 _/ε_ [2] ) classical repetitions of this circuit. By

[�]
contrast, our method operates with only two ancilla qubits, completely avoids block encodings,
and achieves a shorter circuit depth whenever _λ ≪_ _L_ ∆ _γ_, while retaining the same _O_ (1 _/ε_ [2] ) clas
[�]
sical repetition cost. As noted earlier, quantum amplitude estimation can, in principle, reduce
the dependence on the precision parameter from 1 _/ε_ [2] to 1 _/ε_ . However, this comes at the price
of an exponential increase in circuit depth, making it unfavorable for early fault-tolerant devices.
Furthermore, implementing amplitude estimation requires block-encoding access to the observable
_O_, which introduces additional ancilla overhead and further complicates the procedure.


38


|Algorithm|Ancilla Circuit depth per coherent run Classical repetitions|
|---|---|
|Lin and Tong [10]<br>QETU [30] with Trotter<br>QSVT with Trotter [21]|_⌈_log2_ L⌉_+ 3<br>e_O_(_Lλ_∆_−_1_γ−_1)<br>e_O_(_ε−_2)<br>2<br>e_O_<br>�<br>_L_<br>�<br>_λ_∆_−_1_γ−_11+_o_(1)_ε−o_(1)<br>e_O_(_ε−_2)<br>2<br>e_O_(_L_<br>�<br>_λ_∆_−_1_γ−_11+_o_(1))<br>e_O_(_ε−_2)|
|QETU [30] with qDRIFT<br>Other randomized methods [27,28]<br>This work (Thm. 5.3)|2<br>e_O_<br>~~�~~<br>_λ_2∆_−_2_γ−_2_ε−_1~~~~<br>e_O_(_ε−_2)<br>1<br>e_O_(_λ_2∆_−_2)<br>e_O_<br>�<br>_ε−_2_γ−_4<br>2<br>e_O_<br>�<br>(_λ_∆_−_1_γ−_1)2<br>e_O_(_ε−_2)|


Table 4: Comparison of the complexities of different algorithms for ground state property estimation. Consider any Hamiltonian _H_ = [�] _k_ _[L]_ =1 _[λ][k][H][k]_ [, with] _[ ∥][H][k][∥]_ [= 1, and spectral gap ∆. Here,]
_λ_ = max _{_ [�] _k_ _[|][λ][k][|][,]_ [ 1] _[}]_ [. Then, given an initial “guess state” with overlap at least] _[ γ]_ [ with the ground]
state _|v_ 0 _⟩_ of _H_, and an observable _O_, these algorithms estimate _⟨v_ 0 _|O|v_ 0 _⟩_ with additive accuracy
_ε∥O∥_ . For each algorithm, we compare the total number of ancilla qubits required, the circuit
depth per coherent run, and the total number of classical repetitions needed.



Several recent works have proposed alternatives that avoid block encodings by assuming oracle
access to the time-evolution operator _U_ = _e_ [i] _[H]_, with complexity measured in terms of the number
of queries to _U_ [30–33, 61]. These approaches typically require only a few ancilla qubits, making
them attractive in principle. However, to implement them as fully end-to-end quantum algorithms
without introducing additional ancilla overhead, one must approximate _U_ using either higher-order
Trotterization or qDRIFT. Both substitutions substantially increase the circuit depth, resulting
in an exponentially worse dependence on the precision parameter compared to our randomized
algorithm.
In Ref. [21], a complementary end-to-end algorithm for ground-state property estimation was
developed. Instead of qDRIFT, the authors employ 2 _k_ -th order Suzuki–Trotter formulas to implement the Hamiltonian evolutions in _W_, together with fixed-point amplitude amplification and
classical extrapolation to estimate the target expectation value. This approach uses three ancilla

[1]
qubits and requires _O_ ( _ε_ _[−]_ [2] ) independent runs of a quantum circuit with depth _O_ ( _L_ ( _λ/_ ∆ _γ_ ) [1+] 2 _k_ ) _._

[�] [�]



qubits and requires _O_ ( _ε_ _[−]_ [2] ) independent runs of a quantum circuit with depth _O_ ( _L_ ( _λ/_ ∆ _γ_ ) [1+] 2 _k_ ) _._

[�] [�]

As discussed earlier, only low-order Trotter formulas are practical in the early fault-tolerant setting. For any order _k_, our randomized algorithm achieves strictly shorter circuit depth whenever
( _λ/_ ∆ _γ_ ) [1] _[−]_ 2 [1] _k_ _≪_ _L._ This condition is often satisfied in realistic regimes, particularly for low Trotter



( _λ/_ ∆ _γ_ ) [1] _[−]_ 2 _k_ _≪_ _L._ This condition is often satisfied in realistic regimes, particularly for low Trotter

orders, allowing our method to provide a clear advantage while also requiring fewer ancilla qubits.
Finally, randomized LCU-based methods for ground-state property estimation [21, 28] require
only a single ancilla qubit, but incur a total cost of _O_ ( _ε_ _[−]_ [2] _γ_ _[−]_ [4] ) runs of a quantum circuit of depth

[�]
_O_ �( _λ_ [2] _/_ ∆ [2] ) to estimate the target expectation value. This leads to a suboptimal dependence on 1 _/γ_,
and, moreover, these methods cannot exploit amplitude amplification to reduce the number of classical repetitions. In contrast, our algorithm achieves matching circuit depth and total complexity
when amplitude amplification is not used. More importantly, Theorem 5.3 shows that fixed-point
amplitude amplification can be seamlessly integrated into _W_, yielding a quadratically improved
dependence on 1 _/γ_ in the overall complexity.
Overall, our randomized algorithms achieve shorter circuit depth across broad parameter regimes,
while remaining fully independent of the number of terms in _H_ . They completely avoid block encodings, require only a small constant number of ancilla qubits, and reduce classical repetition
costs relative to randomized LCU methods. Taken altogether, these features make our approach
especially well-suited for the early fault-tolerant era, where circuit depth and ancilla resources are



39


the dominant bottlenecks.

### **6 Numerical Benchmarking**


We evaluate the practical performance of our randomized QSVT algorithms on the ground-state
property estimation task introduced in Sec. 5.2. In particular, we compare the asymptotic circuit
depth, measured in terms of single- and two-qubit gates, with that of prior approaches. Our
benchmarks include the algorithm of Dong, Lin, and Tong [30], which is suited for early faulttolerant quantum computers, but assumes black box access to the time evolution operator _e_ [i] _[H]_ . To
enable a fair comparison, we explicitly implement this oracle using standard Hamiltonian simulation
techniques, namely the first- and fourth-order Suzuki–Trotter product formulas and the qDRIFT
method. In each case, we report the end-to-end circuit depth required to achieve the target accuracy
in ground state property estimation.
In addition, we compare against recent QSVT algorithms based on Suzuki-Trotter decompositions [21]. As noted previously, only the second- and fourth-order formulas are considered in
practice, since the pre-factor associated with higher-order Trotter methods grows exponentially
and quickly outweighs their asymptotic advantages. Finally, we benchmark our algorithm against
prior randomized approaches [27, 28]. As established in Sec. 5.2, our randomized QSVT enjoys a
quadratic improvement in the overlap parameter _γ_, leading to a provable reduction in overall gate
complexity. We demonstrate this advantage explicitly by comparing total gate counts across the
spin and molecular Hamiltonians studied in the following subsections.
Having outlined the algorithms used for comparison, we now turn to the systems we consider. In
Sec. 6.1, we examine quantum chemistry Hamiltonians, in particular, those of elementary molecules
such as propane, ethane, and carbon dioxide. Following this, in Sec. 6.2, we also explore quantum
spin models with long-range interactions, where the number of terms _L_ grows quadratically with
system size, while _λ_ grows linearly.
Both these systems are particularly well-suited to randomized approaches: although the number
of Pauli terms _L_ is extremely large, the total coefficient sum _λ_ remains moderate, making the
quadratic dependence on _λ_ more favorable than the linear dependence on _Lλ_ that arises in Trotterbased methods and standard QSVT.


**6.1** **Quantum chemistry Hamiltonians**


Electronic structure Hamiltonians provide a natural and practically relevant testing ground for
ground-state property estimation algorithms. These systems have been extensively studied in
the context of Hamiltonian simulation [17, 20, 62–64]. The Hamiltonian of a molecule in second
quantization takes the form



_hpqa_ _[†]_ _p_ _[a][q]_ [+ ][1]

2

_pq_




 _H_ =



2





_hpqrsa_ _[†]_ _p_ _[a][†]_ _q_ _[a][r][a][s][,]_ (6.1)
_pqrs_



where _a_ _[†]_ _p_ [and] _[ a]_ _q_ [are fermionic creation and annihilation operators, and the coefficients] _[ h]_ _pq_ _[, h]_ _pqrs_
are determined by the one- and two-electron integrals of the molecular system. To simulate such
Hamiltonians on a quantum computer, we map the fermionic operators to qubits using the Jordan–Wigner transformation, yielding a weighted sum of Pauli operators.
In our numerical experiments, we study three representative molecules at their ground-state
equilibrium geometries: Propane (C3H8), carbon dioxide (CO2), and ethane (C2H6). For propane,
we construct the molecular orbitals using the minimal STO-3G basis set, while for carbon dioxide


40


|Molecule|Number of qubits (n)|Total number of terms (L)|1-norm of the coefficients (λ)|
|---|---|---|---|
|Propane (STO-3G)|46|390_,_ 441|435_._98|
|Carbon dioxide (6-31G)|54|182_,_ 953|679_._04|
|Ethane (6-31G)|60|301_,_ 718|711_._67|


Table 5: Number of Pauli terms _L_ and 1-norm _λ_ (in Hartree) of the truncated Hamiltonians for
the three molecules.


and ethane we adopt the larger 6-31G basis. These choices specify the set of Gaussian functions
used to represent the atomic orbitals, and therefore determine the size and accuracy of the oneand two-electron integrals entering the electronic structure Hamiltonian.
To enable simulations within reasonable resources and to provide a fair comparison across methods, we apply a systematic truncation procedure to the Pauli decompositions of the Hamiltonians.
Specifically, the terms are sorted by the magnitude of their coefficients, and those with the smallest
magnitudes are discarded, subject to the constraint that the sum of the absolute values of the
removed coefficients does not exceed _ε/_ ( _γ_ ∆). This threshold ensures that the truncation error is
controlled and enables a fair comparison with Trotter-based methods. After truncation, we subtract the identity contribution from each Hamiltonian, since it merely shifts all eigenvalues by a
constant and does not affect ground-state properties. The resulting truncated Hamiltonians have
the number of Pauli terms _L_, as well as the total 1-norm of the coefficients _λ_, reported in Table 5.
Notably, all three systems exhibit extremely large _L_ (hundreds of thousands of terms) but only
moderate _λ_ (a few hundred Hartree). This separation between _L_ and _λ_, makes them particularly
well-suited for randomized approaches since our algorithm uses qDRIFT, which scales with _λ_ [2] (instead of _Lλ_ in Trotter methods or standard QSVT). Moreover, a novel use of extrapolation allows
us to obtain exponentially improved circuit depth as compared to vanilla qDRIFT [17]. In order


Figure 1: Comparison of the circuit depth of the different quantum algorithms for ground state
property estimation when applied to the electronic structure Hamiltonians of propane (in STO-3G
basis), carbon dioxide (in 6-31G basis), and ethane (in 6-31G basis). We assume that the initial
“guess” state has an overlap of _γ_ = 0 _._ 1 with the ground state of the Hamiltonian. We plot the circuit
depth per coherent run as a function of the error tolerance _ε_ . The circuit depth of randomized
QSVT is significantly shorter than the other approaches considered here, for all three molecules.


41


to compare with Trotter-based methods, note that these Hamiltonians do not have structure and
hence commutator bounds are unavailable. We therefore set the commutator prefactor _λ_ _[′]_ comm [=] _[ λ]_
for QETU with Trotter, and the commutator prefactor _λ_ comm = _λ_ for QSVT with Trotter. Here,
_λ_ _[′]_ comm [denotes] _[ C]_ Trotter [1] _[/]_ [(2] _[k]_ [+1)] defined in [30, Appendix C] for 2 _k_ -order Trotterization, so that the complexity of QETU with Trotter scales as _O_ (( _λ_ _[′]_ comm [)][1+1] _[/]_ [2] _[k]_ [). In addition, we fix the spectral gap]
to ∆= 0 _._ 25 Hartree, which serves as a lower bound for the vertical excitation energies of these
molecules, following standard references [65–67]. Finally, all Hamiltonians were generated using
OpenFermion [18] and the PySCF package [68–70], which provide one- and two-electron integral
evaluations and fermion-to-qubit mappings. Figure 1 compares the circuit depth per coherent run


Figure 2: Comparison of the overall gate complexity (total number of single and two-qubit gates
needed) of our method with other randomized methods [27,28] for ground state property estimation
when applied to the electronic structure Hamiltonians of propane (in STO-3G basis), carbon dioxide
(in 6-31G basis), and ethane (in 6-31G basis). We fix the error tolerance _ε_ = 0 _._ 01, and vary _γ_, the
overlap of the initial “guess” state with the ground state of the Hamiltonian. Our method requires
substantially fewer gates than prior randomized methods for all three molecules.


of randomized QSVT with that of competing methods. With the overlap of the initial “guess”
state with the ground states fixed at _γ_ = 0 _._ 1, we vary the error tolerance _ε_ . This choice of _γ_ is
motivated by the fact that for small molecules such as the ones we consider here, there are several
classical and quantum approaches to prepare a state with a constant overlap with the target ground
state [41, 71–73].
Across all three molecular Hamiltonians, our approach consistently achieves significantly lower
depths than the QETU algorithm of Dong, Lin, and Tong [30], whether the required time-evolution
oracle is implemented by Trotterization or by qDRIFT. We also outperform the QSVT-withTrotterization algorithm of Chakraborty et al. [21], even when using fourth-order Suzuki–Trotter
formulas. The quantitative advantage is significant: for _ε_ = 10 _[−]_ [5], randomized QSVT yields depths
shorter by roughly nine orders of magnitude compared to QETU with first-order Trotter, by about
three orders of magnitude compared to QETU with qDRIFT, and by about two orders of magnitude even relative to fourth-order Trotterized QSVT. The advantage is similar with respect to
QSVT using Trotterization.
The circuit depth of the ground-state property estimation algorithm based on randomized LCU
exhibits scaling behavior similar to the variant of our method that does not employ fixed-point
amplitude amplification. However, as discussed in Sec. 5.2, once combined with quantum amplitude
amplification, our approach achieves a quadratically better dependence on the overlap parameter
_γ_ in terms of the overall complexity. This advantage is evident in Fig. 2, which reports the total
gate complexity (i.e., the number of single- and two-qubit gates aggregated over all runs) for the


42


three molecular Hamiltonians. Here we fix the precision to _ε_ = 0 _._ 01, and vary the overlap _γ_ of
the initial guess state. As _γ_ decreases, the gate complexity of randomized LCU [27, 28] increases
sharply, whereas our algorithm scales much more favorably. For example, at _γ_ = 10 _[−]_ [4], our method
requires fewer gates by roughly five orders of magnitude.
Although we do not explicitly plot the circuit depth of ground-state property estimation using
standard block-encoding-based QSVT [10], our method achieves strictly shorter depths for all three
molecular Hamiltonians. The key distinction lies in the scaling: standard QSVT requires circuit
depth proportional to _Lλ_, whereas our randomized approach depends only on _λ_ [2], which is much
smaller in this case as _L ≫_ _λ_ . This comparison already favors our method before accounting for the
additional overhead of decomposing the multi-qubit controlled operations inherent to block encodings into elementary single- and two-qubit gates. Furthermore, block-encoding QSVT necessitates
access to an explicit block encoding of _H_, which itself is resource-intensive: it involves intricate
controlled operations over _O_ (log _L_ ) ancilla qubits. For instance, for propane, this translates to
roughly 21 ancilla qubits and gates controlled across each of them, an overhead entirely avoided by
our approach.
Overall, these results demonstrate that randomized QSVT provides a significant practical advantage for ground-state property estimation on realistic molecular Hamiltonians. By eliminating
the explicit dependence on _L_, avoiding costly block encodings, obtaining improved circuit depths
using classical techniques such as extrapolation, and requiring only a constant number of ancilla
qubits, our approach substantially reduces circuit depth and gate overhead. These features make
randomized QSVT especially well-suited for early fault-tolerant quantum devices, where qubit
counts and coherence times remain limited.


**6.2** **Transverse-field Ising model**


As a complementary benchmark to molecular Hamiltonians, we also evaluate the performance of
ground state property estimation by randomized QSVT on spin-chain models that are central
to quantum many-body physics and quantum simulation experiments. In particular, we study
two one-dimensional systems: (i) the transverse-field Ising chain with algebraically decaying ZZ
interactions and (ii) a hybrid extension that combines short-range nearest-neighbor XX couplings
with additional long-range ZZ terms.
The first model is a classic setting for studying quantum phase transitions, correlation spread,
and anomalous dynamical phenomena in long-range interacting systems [42, 74]; the second is
a natural yet less-explored extension that contains both nearest-neighbor as well as long-range
interactions. Because both types of interactions can be engineered or approximated in several
quantum technological platforms, such as trapped ions [75, 76], and Rydberg atom arrays [77, 78],
these Hamiltonians serve as meaningful testbeds for benchmarking the performance of ground state
property estimation by randomized QSVT, with other methods.


**6.2.1** **Long-range Transverse Ising field Ising chain**


We consider the _n_ -qubit one-dimensional Hamiltonian



_n_


_Xi,_ (6.2)

_i_ =1




  _H_ = _−J_


1 _≤i<j≤n_



_ZiZj_

_[−]_ _[h]_
_|i −_ _j|_ _[α]_



with _J, h >_ 0 and _α >_ 1. This is an extension of the paradigmatic nearest-neighbor transverse-field
Ising model [12], which is of deep theoretical interest: it interpolates between mean-field behavior


43


( _α →_ 0), and short-range neighbor ( _α →∞_ ). Their relevance extends beyond theory, as longrange Ising interactions can be engineered in several experimental platforms. Because trapped
ions naturally mediate spin–spin interactions via phonon modes, with effective coupling exponents
tunable by laser detunings, implementing a long-range Ising Hamiltonian is relatively direct in that
platform, with _α_ varying between 0 and 3 [75, 76, 79]. Similarly, Rydberg atom arrays exhibit van
der Waals ( _α_ = 3) or dipolar ( _α_ = 6) interactions that yield long-range Ising models in one or
two dimensions [77, 78]. Dipolar quantum gases of magnetic atoms and ultracold polar molecules
confined in optical lattices also realize spin Hamiltonians with _α_ = 3 through magnetic or electric
dipole–dipole couplings [80, 81]. Owing to the relevance of such systems, quantum simulation
algorithms for Hamiltonians with power law interactions have been extensively studied [23, 82, 83].
The Hamiltonian _H_ in Eq. (6.2) is already in the desired form, i.e. _H_ = [�] _k_ _[L]_ =1 _[λ][k][P][k]_ [, with the]
number of Pauli terms




   - _n_
_L_ = _n_ +
2




= _[n]_ [2][ +] _[ n]_ = _O_ ( _n_ [2] ) _._

2



The one-norm coefficient of the coefficients of _H_,



_λ_ = _hn_ + _J_



_n−_ 1



_r_ =1



_n −_ _r_

_≤_ ( _h_ + _J ζ_ ( _α_ )) _n_ = Θ( _n_ ) _,_
_r_ _[α]_



whenever the interaction strength _J, h_ are constants. Here, _ζ_ ( _s_ ) = [�] _r_ _[∞]_ =1 _[r][−][s]_ [ is the Riemann zeta]
function, which is a constant when _α >_ 1. Thus the Hamiltonian satisfies _λ ≪_ _L_, a feature that
strongly favors randomized methods.
To benchmark our ground-state property estimation algorithm, it is necessary to assume a
nontrivial bound on the spectral gap ∆. Obtaining an exact analytical estimate of ∆is notoriously
difficult, but in the Appendix B, we show evidence that


∆ _∼_ 2 _|h −_ _J ζ_ ( _α_ ) _|,_


which remains constant for a broad range of parameter values. This scaling is further supported
by numerical calculations up to _n_ = 26 qubits (See Fig. 4 in Appendix B).
For small spin systems, classical methods can be used to efficiently prepare an initial “guess”
state with nontrivial overlap with the ground state, using tools such as tensor networks (especially
matrix product states) [84–86] or variational algorithms [87–89]. As a result, we set _γ_ = 0 _._ 1 in our
experiments. In our setting, we are in fact primarily concerned with how the complexity of our
randomized QSVT algorithm scales with the system size _n_ . Assuming the availability of a “guess”
state with constant (albeit possibly small) overlap with the true ground state, the asymptotic
circuit depth of randomized QSVT is therefore _O_ ( _n_ [2] ). By contrast, the algorithm of Lin and

[�]
Tong [10], which employs block-encoding-based QSVT, scales as _O_ ( _n_ [3] ), while additionally requiring

[�]
_O_ (log _n_ ) ancilla qubits and multi-qubit controlled operations. For comparisons against Trotterbased algorithms, specifically, QSVT with Trotterization [21] and QETU with Trotterization [30],
we must also estimate the commutator pre-factor, _λ_ comm and _λ_ _[′]_ comm [.]
In Appendix B (Lemma B.1), we establish that


             -              _λ_ comm = _O_ _n_ [1] _[/]_ [(2] _[k]_ [+1)][�] _,_ _λ_ _[′]_ comm [=] _[ O]_ _n_ [1] _[/]_ [(2] _[k]_ [+1)][�]


for the 2 _k_ -th order Suzuki–Trotter formula. Our proof provides both upper and lower bounds
through a fine-grained analysis that explicitly tracks constant factors. This level of precision is


44


essential for the subsequent numerical benchmarking, where we compare Trotter-based approaches
with randomized QSVT in regimes where the system size _n_ is only moderately large (on the order
of a few thousand qubits). Importantly, although the asymptotic scaling is similar to prior work
on spin Hamiltonians with power law decay [23,82,83], our derivation does not follow from existing
techniques in these references. To the best of our knowledge, ours is a new method for obtaining
tight commutator pre-factor scalings for spin Hamiltonians with a combination of short and longrange interactions.
Consequently, the circuit depth of the algorithm in [21] scales as _O_ ( _n_ [2+1] _[/]_ [(2] _[k]_ [)] ), while that of [30]

[�]
scales as _O_ ( _n_ [2] ( _n/ε_ ) [1] _[/]_ [(2] _[k]_ [)] ). In practice, only low-order Trotter methods ( _k_ = 1 _,_ 2) are feasible,
making the asymptotic advantage of randomized QSVT especially significant. Finally, we validate
these theoretical findings numerically. As shown in Fig. 3 (left), for representative parameter values
of _H_, randomized QSVT consistently achieves lower circuit depth than all prior approaches, thereby
demonstrating concrete practical advantages in realistic settings.


Figure 3: Comparison of the circuit depth of different quantum algorithms for ground state property
estimation as a function of the number of qubits _n_ for the two Transverse Field Ising Model
Hamiltonians considered in this work. (To the left) Transverse-field Ising model with long-range
interactions, with the Hamiltonian parameters set to _h_ = 3, _J_ = 1, _α_ = 3, _ε_ = 0 _._ 01, _γ_ = 0 _._ 1 (See
Eq. (6.2)). The spectral gap is fixed to ∆= 3. (To the right) Transverse-field Ising model with
hybrid interactions, with the Hamiltonian parameters _h_ = 3, _J_ = 1, _g_ = 0 _._ 1, _α_ = 3, _ε_ = 0 _._ 01,
_γ_ = 0 _._ 1 (See Eq. (6.3)). In both cases, the circuit depth of ground state property estimation by
randomized QSVT is shorter as compared to the other methods.


**6.2.2** **Transverse field Ising model with hybrid XX-ZZ interactions**



The second model we consider is a one-dimensional hybrid spin chain that combines short- and longrange Ising interactions. Consider _n_ qubits on a one-dimensional chain with periodic boundary
conditions. For _α >_ 1 and couplings _h >_ 0, _J >_ 0, _g ≥_ 0, we define the following _n_ -qubit
Hamiltonian



1

_[Z][i][Z][j][.]_ (6.3)
_|i −_ _j|_ _[α]_



_H_ = _−h_



_n_




_Zi −_ _J_

_i_ =1



_n_






_XiXi_ +1 _−_ _[g]_

_n_

_i_ =1



_n_




 

1 _≤i<j≤n_



This “hybrid” Hamiltonian merges ingredients that are each well established in quantum manybody physics: the nearest-neighbor transverse-field Ising chain, which is exactly solvable and serves


45


as a paradigmatic model of quantum phase transitions [12], and the long-range Ising model with
algebraically decaying couplings, which exhibits anomalous criticality and dynamics [42]. While the
exact combination of nearest neighbor XX interactions, transverse field, and long-range ZZ terms
has not been studied as extensively as these limiting cases, it represents a natural and experimentally
motivated extension. Indeed, both short and long-range interactions can be engineered in a variety
of technological platforms, such as ion traps and Rydberg atoms. Even theoretically, a (normalized)
long-range interaction model has been studied [90].
Beyond their physical relevance, our motivation for studying this hybrid model is that it inherits
the desirable structural features of the long-range transverse-field Ising Hamiltonian discussed in
Sec. 6.2.1, while at the same time permitting a rigorous lower bound on the spectral gap. In
particular, the number of Pauli terms scales quadratically with system size, _L_ = Θ( _n_ [2] ), and



_λ_ = _hn_ + _Jn_ + _[g]_

_n_



_n−_ 1



_r_ =1



_n −_ _r_

_≤_ ( _h_ + _J_ ) _n_ + _gζ_ ( _α_ ) = Θ( _n_ ) _,_ (6.4)
_r_ _[α]_



for constant interaction strengths _J, g, h_ . Thus, as in the long-range TFIM, the hybrid Hamiltonian
lies in the favorable regime where _λ ≪_ _L_, making it suitable for randomized QSVT.
For the spectral gap, we exploit the fact that the Hamiltonian can be decomposed as _H_ 0 + _V_,
where



_H_ 0 = _−h_



_n_




_Zi −_ _J_

_i_ =1



_n_




_XiXi_ +1 _,_

_i_ =1



is the standard one-dimensional transverse-field Ising chain, and _V_ contains long-range interactions.
The spectral gap of _H_ 0 is well-known: diagonalizing via a Jordan–Wigner transformation and
minimizing the single-quasiparticle dispersion relation yields ∆0 = 2 _|h −_ _J|_ . The second part, _V_
satisfies



_n−_ 1




_r_ =1



_∥V ∥≤_ _[g]_

_n_






_i<j_



1 _[g]_

[=]
_|i −_ _j|_ _[α]_ _n_



_n −_ _r_

_≤_ _g ζ_ ( _α_ ) _._
_r_ _[α]_



By the min–max (Weyl) inequalities for Hermitian matrices,


∆ _≥_ ∆0 _−_ 2 _∥V ∥_ = 2 _|h −_ _J| −_ 2 _g ζ_ ( _α_ ) _._


In particular, if

_g <_ _[|][h][ −]_ _[J][|]_

2 _ζ_ ( _α_ ) _[,]_


we have ∆ _≥|h−J|_, which is constant whenever _|h−J|_ is. Thus, provided one can prepare a “guess”
state with constant overlap with the ground state, the overall circuit depth of our randomized
QSVT algorithm scales as _O_ ( _n_ [2] ), identical to the scaling in the long-range Ising model analyzed

[�]
in the previous subsection. The asymptotic advantage over standard block-encoding-based QSVT
therefore carries over unchanged to this hybrid setting.
Finally, in Lemma B.1 of Appendix B, we establish that the commutator prefactor scales as
_λ_ comm = Θ( _n_ [1] _[/]_ [(2] _[k]_ [+1)] ), _λ_ _[′]_ comm [= Θ(] _[n]_ [1] _[/]_ [(2] _[k]_ [+1)][) for a 2] _[k]_ [-th order Trotter decomposition.] Consequently, even for the hybrid Hamiltonian considered here, randomized QSVT achieves a concrete
asymptotic advantage over the Trotterized QSVT algorithm of [21] and the QETU-based approach
of [47].
The asymptotic circuit depth of randomized QSVT for the hybrid Hamiltonian is summarized
in Table 6, and the corresponding numerical benchmarking is presented in Fig. 3 (right). For the
simulations, we fix the parameters to _h_ = 3 _, J_ = 1 _, g_ = 0 _._ 1 _, α_ = 3 _, ε_ = 0 _._ 01 and _γ_ = 0 _._ 1.


46


|Algorithm|Ancilla qubits|Circuit depth|
|---|---|---|
|Standard QSVT [10]|_O_(log_ n_)|e_O_(_n_3)|
|QETU with 2_k_-order Trotter [30]|2|e_O_<br>~~�~~<br>_n_2(_n/ε_)1_/_(2_k_)~~~~|
|QETU with qDRIFT [30]|2|e_O_(_n_2_/ε_)|
|QSVT with 2_k_-order Trotter [21]|2|e_O_(_n_2+1_/_(2_k_))|
|This work (Theorem 5.3)|2|e_O_(_n_2)|


Table 6: The circuit depth of different algorithms for estimating the ground state properties of _H_
in Eq. (6.3), for parameter regimes where the spectral gap is constant. We assume that the initial
guess state has a constant overlap with the ground state.


In this parameter regime, the spectral gap of _H_ remains constant. The results clearly show that
randomized QSVT achieves concrete reductions in circuit depth compared to prior approaches, and
that these advantages persist across a practically relevant range of system sizes.

### **7 Discussion**


In this work, we introduced the first randomized quantum algorithms for quantum singular value
transformation (QSVT). Our methods simultaneously address two central bottlenecks of standard
QSVT: the reliance on costly block encodings and the explicit linear dependence on the number of
Hamiltonian terms _L_ . Concretely, given a Hamiltonian _H_ = [�] _k_ _[L]_ =1 _[λ][k][H][k]_ [ written as a linear com-]
bination of unitary (or normalized Hermitian) operators, and an initial state _|ψ_ 0 _⟩_, our algorithms
estimate expectation values with respect to _f_ ( _H_ ) _|ψ_ 0 _⟩_ for any function _f_ that admits a bounded
polynomial approximation of degree _d_ . Both algorithms use a single ancilla qubit and achieve
circuit depth scaling as _O_ ( _λ_ [2] _d_ [2] ), independent of _L_ . These features make them particularly well

[�]
suited to early fault-tolerant devices, where ancilla qubits are scarce, multi-qubit controls remain
expensive, and circuit depth is the most critical resource.
Our first algorithm can be viewed as a direct randomization of standard QSVT [1], preserving
its structure but also inheriting inefficiencies of prior randomized methods [21, 28]. An interesting
open question is whether one can design a randomized variant of QSVT that still permits amplitude
amplification, thereby improving asymptotic performance.
The second algorithm embeds qDRIFT into generalized quantum signal processing (GQSP)
and uses Richardson extrapolation to achieve improved precision scaling. This approach is more
flexible, exhibits superior asymptotic performance, and yields strong advantages in concrete applications. For quantum linear systems and ground-state property estimation, it achieves substantial
polynomial improvements over prior randomized LCU-based methods [27,28]. Beyond these specific
tasks, our techniques open the door to new randomized algorithms for the wide range of problems
accessible via QSVT. One shortcoming of randomized algorithms [17, 21, 26, 28, 53, 61] is their incompatibility with existing variants of quantum amplitude estimation [91,92], making it impossible
to achieve Heisenberg scaling. Reconciling this gap remains an interesting direction for future work.
To complement our theoretical analysis, we numerically benchmarked randomized QSVT on
ground-state property estimation for Hamiltonians from both quantum chemistry and condensed
matter physics. For electronic-structure Hamiltonians of propane, carbon dioxide, and ethane, as
well as Ising Hamiltonians with long-range and hybrid interactions, our algorithm consistently outperforms standard block-encoding-based QSVT, early fault-tolerant methods, and prior randomized
algorithms, often by several orders of magnitude. These simulations confirm that the asymptotic


47


advantages of randomized QSVT translate directly into meaningful reductions in resource requirements across realistic parameter regimes. An important next step will be to refine these benchmarks
into explicit hardware-level resource estimates, including optimized CNOT and T gate counts once
our algorithms are compiled into fault-tolerant circuits. This would facilitate a more direct comparison with different experimental platforms and provide a clearer assessment of the practicality
of randomized QSVT for near-term applications in quantum chemistry and many-body physics.
Alongside these algorithmic contributions, we established a matching lower bound in the Pauli
sample access model. Specifically, we proved that any randomized algorithm for Hamiltonian simulation requires circuit depth Ω( _t_ [2] ). This shows that generic randomized algorithms implementing
polynomial transformations must necessarily incur a quadratic dependence on the polynomial degree. This lower bound establishes the essential optimality of not only our algorithms but also other
randomized Hamiltonian simulation methods [17, 26, 61] and randomized LCU approaches [21, 28].
A key open question in this direction is whether stronger lower bounds can be obtained for broader
classes of functions. One might also ask whether, for any continuous function _f_ ( _x_ ), randomized
quantum algorithms require complexity at least Ω(deg( [�] _f_ ) [2] ), where deg( _f_ ) is the approximate degree

[�]
of _f_ ( _x_ ). Such a result would establish a fundamental complexity-theoretic limitation for randomized

algorithms, in contrast to the linear lower bound Ω(deg( [�] _f_ )) known for standard QSVT [50].
Another promising avenue is to explore structured Hamiltonians. Our bounds apply in the
worst case, and it remains unclear whether properties such as commutativity, sparsity, or geometric
locality can be leveraged to circumvent the quadratic barrier. One intriguing possibility is the
development of hybrid methods that interpolate between block encodings and randomized sampling,
potentially combining the best of both frameworks. Finally, motivated by recent progress showing
that Trotterization and randomization can be fruitfully combined for Hamiltonian simulation [93],
it would be natural to investigate analogous hybrid strategies within QSVT.

### **Acknowledgments**


CS and YZ are supported by the National Key Research and Development Project of China under
Grant No. 2020YFA0712300. SC and SH acknowledge funding from the Ministry of Electronics and
Information Technology (MeitY), Government of India, under Grant No. 4(3)/2024-ITEA. SC also
acknowledges support from Fujitsu Ltd, Japan, and IIIT Hyderabad via the Faculty Seed Grant. TL
and XW were supported by the National Natural Science Foundation of China (Grant Numbers
62372006 and 92365117). XW thanks the University of California, Berkeley, for its hospitality
during his visit, where a part of this work was conducted. We thank Andrew M. Childs and Ronald
de Wolf for valuable feedback on this work.

### **Appendix A Some polynomial approximation results**



**Lemma A.1** (Rectangle function, Lemma 29 of [1]) **.** _Let δ_ _[′]_ _, ε_ _[′]_ _∈_ �0 _,_ [1]



**Lemma A.1** (Rectangle function, Lemma 29 of [1]) **.** _Let δ_ _[′]_ _, ε_ _[′]_ _∈_ �0 _,_ [1] - _and t ∈_ [ _−_ 1 _,_ 1] _. There exist_

2
_an even polynomial P_ _[′]_ _∈_ R[ _x_ ] _of degree O_ �log - 1 - _/δ_ _[′]_ [�] _, such that |P_ _[′]_ ( _x_ ) _| ≤_ 1 _for all x ∈_ [ _−_ 1 _,_ 1] _,_

~~_[′]_~~



_an even polynomial P_ _[′]_ _∈_ R[ _x_ ] _of degree O_ �log - 1 - _/δ_ _[′]_ [�] _, such that |P_ _[′]_ ( _x_ ) _| ≤_ 1 _for all x ∈_ [ _−_ 1 _,_ 1] _,_

_ε_ ~~_[′]_~~
_and_

      - _P_ _[′]_ ( _x_ ) _∈_ [0 _, ε_ _[′]_ ] _for all x ∈_ [ _−_ 1 _, −t −_ _δ_ _[′]_ ] _∪_ [ _t_ + _δ_ _[′]_ _,_ 1]
_._
_P_ _[′]_ ( _x_ ) _∈_ [1 _−_ _ε_ _[′]_ _,_ 1] _for all x ∈_ [ _−t_ + _δ_ _[′]_ _, t −_ _δ_ _[′]_ ]

**Lemma A.2.** _Let f_ ( _z_ ) = (1 _−_ _z_ [2] ) _[n/]_ [2] _with n ∈_ N _, s ∈_ (0 _,_ 1 _/_ _[√]_ ~~_n_~~ ~~)~~ _, and ε >_ 0 _. Define the truncated_
_even polynomial Pk_ ( _z_ ) _by keeping the first k terms of the power series expansion of f_ ( _z_ ) _. Then:_


48


_1. To ensure the approximation error |f_ ( _z_ ) _−_ _Pk_ ( _z_ ) _| ≤_ _ε for all z ∈_ [ _−s, s_ ] _, the truncation order_
_k must satisfy:_
_k_ = Ω(log(1 _/ε_ )) _._


_2. The maximum of |Pk_ ( _z_ ) _| on z ∈_ [ _−_ 1 _,_ 1] _satisfies:_


_M_ = _O_ ( _n_ _[k]_ ) _._


_3. Moreover, there is an even polynomial S_ 1( _z_ ) _of degree O_ ( _[√]_ ~~_n_~~ log(1 _/ε_ ) log( _n_ )) _such that |f_ ( _z_ ) _−_
_S_ 1( _z_ ) _| ≤_ _ε for all z ∈_ [ _−s, s_ ] _and |S_ 1( _z_ ) _| ≤_ 1 _for all z ∈_ [ _−_ 1 _,_ 1] _._


_Proof._ The function _f_ ( _z_ ) = (1 _−_ _z_ [2] ) _[n/]_ [2] can be expanded as:



_f_ ( _z_ ) =



_∞_

- - _n/_ 2

( _−_ 1) _[m]_
_m_
_m_ =0




_z_ [2] _[m]_ _._



The remainder (error) _E_ ( _z_ ) is:


_E_ ( _z_ ) = _f_ ( _z_ ) _−_ _Pk_ ( _z_ ) =


For _z ∈_ [ _−s, s_ ], we have



_∞_

- - _n/_ 2

( _−_ 1) _[m]_
_m_
_m_ = _k_




_z_ [2] _[m]_ _._




- _k_ 1

_k_ ! _[e][ns]_ [2] _[/]_ [2] _[.]_




- _m_ 1



2

1 - _ns_

_m_ ! _[≤]_ 2



2



_s_ 2 _m ≤_
�����



_∞_



_m_ = _k_



2

- _ns_


2



_|E_ ( _z_ ) _| ≤_



_∞_



_m_ = _k_



����




- _n/_ 2

_m_



Taking _k_ = Ω(log(1 _/ε_ )) suffices to bound the truncation error by _ε_ .
Now suppose _k ≤_ _n/_ 4. The maximum value of _|Pk_ ( _z_ ) _|_ for _z ∈_ [ _−_ 1 _,_ 1] can be bounded by



_k−_ 1



_m_ =0




- _n/_ 2

_m_




- - _n/_ 2
_≤_ _k_
_k −_ 1



2 _k_





  - _en_
_≤_ _k_




- _k_
= _O_ ( _n_ _[k]_ ) _._



Finally, we can further reduce the upper bound in Claim 2 to 1 by composing _Pk_ ( _z_ ) with
a rectangle function. More precisely, let _S_ [˜] 1 be the truncated Taylor expansion of _f_ ( _z_ ) over the
interval [ _−_ 2 _s,_ 2 _s_ ], and _R_ ( _z_ ) be the polynomial in Lemma A.1 with


( _ε_ _[′]_ _, t, δ_ _[′]_ ) = ( _O_ ( _n_ _[−]_ [log(1] _[/ε]_ [)] ) _,_ 3 _s/_ 2 _, s/_ 2) _,_

which means deg( _R_ ) = _O_ (log(1 _/ε_ ) log( _n_ ) _/s_ ). Since _s_ = _O_ (1 _/_ _[√]_ ~~_n_~~ ~~)~~, we have


_|S_ [˜] 1( _z_ ) _| ≈|_ (1 _−_ _z_ [2] ) _[n/]_ [2] _| ≤_ 1 _,_


for all _z ∈_ [ _−_ 2 _s,_ 2 _s_ ]. Taking _S_ 1( _z_ ) = _S_ [˜] 1( _z_ ) _R_ ( _z_ ), we observe that _S_ 1( _z_ ) is still an _O_ ( _ε_ )-approximation
of _f_ ( _z_ ) for _z ∈_ [ _−s, s_ ] and is bounded by 1 for _z ∈_ [ _−_ 1 _,_ 1]. The degree of _S_ 1( _z_ ) is

deg( _R_ ) + deg( _S_ [˜] 1) = _O_ ( _[√]_ _n_ log(1 _/ε_ ) log( _n_ )) _._


_z_
**Lemma A.3.** _Let f_ ( _z_ ) = ~~_√_~~ _[,][ s][ ∈]_ [(0] _[,]_ [ 1] _[/]_ [2)] _[, and][ ε >]_ [ 0] _[. Define the truncated odd polynomial]_

1 _−_ _z_ [2]

_S_ 2( _z_ ) _by keeping the first k terms of the power series expansion of f_ ( _z_ ) _. Then:_


49


_1. To ensure the approximation error |f_ ( _z_ ) _−_ _S_ 2( _z_ ) _| ≤_ _ε for all z ∈_ [ _−s, s_ ] _, the truncation order_
_k must satisfy:_

_k ≥_ [log(1] _[/ε]_ [)]

2 log(1 _/s_ ) _[.]_


_2. The maximum of |S_ 2( _z_ ) _| on z ∈_ [ _−_ 1 _,_ 1] _satisfies:_




~~�~~ _k_

_M ≤_ 2

_π_ _[.]_



_z_
_Proof._ The function _f_ ( _z_ ) = ~~_√_~~ [can be expanded as:]

1 _−_ _z_ [2]



_f_ ( _z_ ) =


Note that
(2 _m_ )! [1]

[=]
4 _[m]_ ( _m_ !) [2] 4 _[m]_



_∞_



_m_ =0


�2 _m_

_m_



(2 _m_ )!

_[z]_ [2] _[m]_ [+1] _[.]_
4 _[m]_ ( _m_ !) [2]




- 4 _[m]_ 1
_≤_ [1] ~~_√_~~ ~~_√_~~ _,_

4 _[m]_ ~~_πm_~~ = ~~_πm_~~



so the truncation error for _z ∈_ [ _−s, s_ ] can be bounded by



~~_√_~~



_∞_




~~_√_~~



_πk_



_≤_ _s_ [2] _[k]_ [+1] _._
_k_



_|f_ ( _z_ ) _−_ _S_ 2( _z_ ) _| ≤_



_∞_



_m_ = _k_



_s_ [2] _[m]_ [+1]

~~_√_~~ _≤_ _[s]_ ~~_√_~~ [2] _[k]_ [+1]
~~_πm_~~ _πk_



_s_ [2] _[m]_ [+1]




- _s_ [2] _[m]_ _≤_ _[s]_ ~~_√_~~ [2] _[k]_ [+1]

_k_

_m_ =0



log(1 _/ε_ )
Therefore, taking _k ≥_
2 log(1 _/s_ ) [suffices to make the truncation error bounded by] _[ ε]_ [.]
The maximum value of _S_ 2( _z_ ) in [ _−_ 1 _,_ 1] can be bounded by



_k−_ 1



_m_ =0



1  - _k_
~~_√_~~
~~_πm_~~ _≤_ 0



1 ~~�~~
~~_√_~~ _m_ = 2
~~_πm_~~ d



_k_
_π_ _[.]_



This completes the proof.


The following proposition provides an approximate decomposition of a polynomial under normalization in a certain sense.


**Proposition A.4.** _Let ε ∈_ (0 _,_ 1 _/_ 2) _and P_ ( _x_ ) _be a degree-d polynomial satisfying |P_ ( _x_ ) _| ≤_ 1 _/_ 2 _for_
_any x ∈_ [ _−_ 1 _,_ 1] _. Then there exists a degree-m polynomial_ _P_ ( _x_ ) _and c, s, α ∈_ R _such that_

[�]

_√_

_m_ = Θ� _d_ log [2] ( _d/ε_ ) log [2] (log ( _d/ε_ ))� _,_ _s_ = 1 _/_ _[√]_ _m,_ _c_ = �1 _−_ 1 _/m,_ _α_ = _m −_ 1 log� _d_ [2] _/ε_ - _,_

(A.1)
_and_

         - ~~�~~ _c_ [2] + _s_ [2] _x_ [2]          - _m_          - _P_          - ~~_√_~~ _sx_          - _−_ _P_ ( _x/α_ ) _≤_ _ε_ (A.2)
���� _c_ [2] + _s_ [2] _x_ [2] ����



_m_ = Θ� _d_ log [2] ( _d/ε_ ) log [2] (log ( _d/ε_ ))� _,_ _s_ = 1 _/_ _[√]_ _m,_ _c_ = 


_√_
1 _−_ 1 _/m,_ _α_ =




    - _m_    - _sx_
_c_ [2] + _s_ [2] _x_ [2] - _P_ ~~_√_~~



_c_ [2] + _s_ [2] _x_ [2]





_−_ _P_ ( _x/α_ ) _≤_ _ε_ (A.2)
����



_for all x ∈_ [ _−_ 1 _,_ 1] _. Moreover, if f_ ( _x_ ) _is even or odd, then so is_ _f_ [˜] ( _x_ ) _._


_Proof._ From the choice of _c_, we see that _c_ _[m]_ = (1 _−_ 1 _/n_ ) _[m/]_ [2] _≥_ 1 _/_ 2 when _m ≥_ 2. So we have
_|P_ ( _x_ ) _| ≤_ _c_ _[m]_ in [ _−_ 1 _,_ 1]. Substituting
_sx_
_z_ = ~~_√_~~ _[,]_

_c_ [2] + _s_ [2] _x_ [2]


50


into Eq. (A.2), we obtain

_√_
_P_ �( _z_ ) _−_ [(]
�����



1 _−_ _z_ [2] ) _[m]_



_c_ _z_

~~_√_~~
_αs_ 1



_−_ _z_ [2] ) _[m]_ - _c_

_· P_
_c_ _[m]_



1 _−_ _z_ [2]



_√_

- [�]
(
_≤_
����



1 _−_ _z_ [2] ) _[m]_

_· ε_
_c_ _[m]_



for all _z ∈_ [ _−s, s_ ]. To ensure the above holds, it suffices to find _P_ ( _z_ ) such that for all _z ∈_ [ _−s, s_ ]

[�]
_√_

               -                - [�]

1 _−_ _z_ [2] ) _[m]_ _c_ _z_

_P_ �( _z_ ) _−_ [(] _· P_ ~~_√_~~ _≤_ _ε._
����� _c_ _[m]_ _αs_ 1 _−_ _z_ [2] ����



1 _−_ _z_ [2] ) _[m]_



_c_ _z_

~~_√_~~
_αs_ 1



_−_ _z_ [2] ) _[m]_ - _c_

_· P_
_c_ _[m]_



1 _−_ _z_ [2]




- [�]
_≤_ _ε._
����



_√_ Let _S_ 1( _z_ ) _, S_ 2( _z_ ) _√_ be the two polynomials specified in Lemmas A.2 and A.3, that _ε_ -approximates
( 1 _−_ _z_ [2] ) _[m]_ and _z/_ 1 _−_ _z_ [2] for _z ∈_ [ _−s, s_ ], and is bounded by _M_ 1 = 1 _, M_ 2 = log(1 _/ε_ ) for _z ∈_ [ _−_ 1 _,_ 1],



1 2 _√_

1 _−_ _z_ [2] ) _[m]_ and _z/_



( 1 _−_ _z_ [2] ) _[m]_ and _z/_ 1 _−_ _z_ [2] for _z ∈_ [ _−s, s_ ], and is bounded by _M_ 1 = 1 _, M_ 2 = log(1 _/ε_ ) for _z ∈_ [ _−_ 1 _,_ 1],

respectively. Take

                - _S_ 2( _z_ )                 
_P_ �( _z_ ) := _[S]_ [1][(] _[z]_ [)] _· P_




   
[1][(] _[z]_ [)] _S_ 2( _z_ )

_· P_
_c_ _[m]_ _M_ 2







and _α_ = _cM_ 2 _/s_ = _[√]_ _m −_ 1 log(1 _/ε_ ). Then, we have



_M_ 2



_|P_ [�] ( _z_ ) _| ≤_ _M_ 1 = 1



for all _z ∈_ [ _−_ 1 _,_ 1] since _|S_ 2( _z_ ) _/M_ 2 _| ≤_ 1 and _f_ ( _z_ ) _≤_ _c_ _[m]_ for _|z| ≤_ 1. By the Markov brothers’
inequality, the derivative of _P_ ( _x_ ) is bounded by _d_ [2] _|P_ ( _x_ ) _| ≤_ _d_ [2] _/_ 2 on [ _−_ 1 _,_ 1]. Moreover, for _z ∈_ [ _−s, s_ ]
we have
_√_

          -          - [�]

1 _−_ _z_ [2] ) _[m]_ _c_ _z_

_P_ �( _z_ ) _−_ [(] _· P_ ~~_√_~~
����� _c_ _[m]_ _αs_ 1 _−_ _z_ [2] ����



1 _−_ _z_ [2] ) _[m]_



_c_ _z_

~~_√_~~
_αs_ 1



_−_ _z_ [2] ) _[m]_ - _c_

_· P_
_c_ _[m]_



1 _−_ _z_ [2]




- [�]
����



_−_ _z_ [2] ) _[m]_ - _z_

_· P_ ~~_√_~~
_c_ _[m]_ _M_ 2 1



1 _−_ _z_ [2]



_√_


_−_ [(]



1 _−_ _z_ [2] ) _[m]_




- [�]
����



=


_≤_



_S_ 1( _z_ )

_c_ _[m]_

�����


_S_ 1( _z_ )

_c_ _[m]_

�����



1( _z_ ) - _S_ 2( _z_ )

_· P_
_c_ _[m]_ _M_ 2



_√_

1( _z_ )

_−_ [(]
_c_ _[m]_



1 _−_ _z_ [2] ) _[m]_

_c_ _[m]_



_M_ 2




  - _S_ 2( _z_ )

_·_ _P_
����� ���� _M_ 2




  - _S_ 2( _z_ )

_·_ _P_
����� ���� _M_ 2



+
�����




- - _z_

_−_ _P_ ~~_√_~~
_M_ 2 1 _−_ _z_ [2]



_√_
(
�����



1 _−_ _z_ [2] ) _[m]_

_c_ _[m]_



�����



_d_ [2] _ε_
_≤_ _ε_ +
2 _M_ 2 _· c_ _[m]_

  - _d_ [2]
_≤_ _ε_ 1 +

log(1 _/ε_ )




= _O_ - _εd_ [2][�] _,_



where the second inequality follows from the facts that


_∥P_ _[′]_ ( _x_ ) _∥_ [ _−_ 1 _,_ 1] _≤_ _d_ [2] _/_ 2 _,_

_√_
and _S_ 2( _z_ ) is an _ε_ -approximation of _z/_ 1 _−_ _z_ [2] on [ _−s, s_ ]. To ensure the desired accuracy, we need

to update _ε_ with _ε/d_ [2] .
The degree of _P_ [�] ( _x_ ) is _m_ = _d ·_ deg( _S_ 2) + deg( _S_ 1), which is

_m_ ≳ _[d]_ [ log(] _[d]_ [2] _[/ε]_ [)]

2 log( ~~_[√]_~~ ~~_m_~~ ) [+] _[ √][m]_ [ log(] _[m]_ [) log(] _[d]_ [2] _[/ε]_ [)] _[.]_


This shows that _m_ = Θ( _d_ log [2] ( _d/ε_ ) log [2] (log( _d/ε_ ))).


51


### **Appendix B Properties of the Transverse-Field Ising Model Hamil-** **tonian**

In this section, we derive two results about the Hamiltonians of the transverse-field Ising chains we
considered in Sec. 6.2.


**B.1** **Spectral gap of the Transverse-field Ising Hamiltonian with long-range in-**
**teractions**


Consider the one-dimensional long-range transverse-field Ising model on a chain of _n_ spins with
Hamiltonian (defined in Eq. (6.2))




_−_ _J_ 

1 _≤i<j≤n_



1

_[Z][i][Z][j]_
_|i −_ _j|_ _[α]_



_H_ = _−h_



_n_


_Xi_

_i_ =1




~~�~~ ~~��~~ _H_ 0




~~�~~ ~~��~~ ~~�~~
_V_



where _J, h >_ 0 and _α >_ 1. We argue using first-order perturbation theory, based on the decomposition _H_ = _H_ 0 + _V_, that the spectral gap is bounded below by


∆ _≥_ 2( _h −_ _Jζ_ ( _α_ )) _,_


when _h/J > ζ_ ( _α_ ). While this result is not a rigorous proof for the full Hamiltonian _H_, as contributions from higher-order perturbation terms have not been bounded, it provides strong evidence for
the existence of a large gap, independent of the system size. Standard perturbation theory suggests
that for a sufficiently large ratio _h/J_, where _V_ is demonstrably a small perturbation to _H_ 0, the
true spectral gap is expected to remain open and close to this first-order estimate.


Figure 4: Spectral gap of the one-dimensional long-range transverse-field Ising model with _J_ = 1,
_h_ = 3, and _α_ = 3, as a function of the number spins _n_ .


The spectrum of _H_ 0 is determined by the eigenstates of the Pauli _X_ operator. The ground
state _|ψ_ 0 [(0)] _[⟩]_ [=][ �] _i_ _[n]_ =1 _[|]_ [+] _[⟩][i]_ [ has all spins polarized in the +] _[x]_ [ direction with energy] _[ E]_ 0 [(0)] = _−nh_ .
For any integer _m ∈{_ 1 _, . . ., n}_, the _m_ -th excited subspace _Hm_ is spanned by the - _mn_ - states
formed by flipping exactly _m_ spins from _|_ + _⟩_ to _|−⟩_ . These states are degenerate with energy
_Em_ [(0)] [=] _[ −]_ [(] _[n][ −]_ [2] _[m]_ [)] _[h]_ [.]


52


We apply first-order degenerate perturbation theory to a general _m_ -excited subspace _Hm_ for
any _m ≥_ 1. The first-order energy corrections are the eigenvalues _λ_ [(] _[m]_ [)] of the - _n_ - _×_ - _n_ - matrix
_m_ _m_

_M_ [(] _[m]_ [)] with elements _Mkj_ [(] _[m]_ [)] = _⟨ψk_ [(] _[m]_ [)] _|V |ψj_ [(] _[m]_ [)] _⟩_ . The diagonal elements


_Mkk_ [(] _[m]_ [)] = _⟨ψk_ [(] _[m]_ [)] _|V |ψk_ [(] _[m]_ [)] _⟩_ = 0 _,_


since _⟨±|Z|±⟩_ = 0. The eigenvalues _λ_ [(] _[m]_ [)] are bounded by the Gershgorin Circle Theorem, which
implies _|λ_ [(] _[m]_ [)] _| ≤_ max _k_ - _j̸_ = _k_ _[|][M]_ _kj_ [(] _[m]_ [)] _[|]_ [. An off-diagonal element] _[ M]_ _kj_ [(] _[m]_ [)] is non-zero if _|ψj_ [(] _[m]_ [)] _⟩_ is reachable

from _|ψk_ [(] _[m]_ [)] _⟩_ by a _ZaZb_ operator, which requires swapping a _|_ + _⟩_ spin at site _a_ with a _|−⟩_ spin at
site _b_ . For any state _|ψk_ [(] _[m]_ [)] _⟩_ with _m_ flipped spins, the row sum is bounded by:


_̸_


_̸_



_̸_


 

_̸_ _a_ unflipped in _k_

_b_ flipped in _k_





_̸_



_̸_


_J_
_|a −_ _b|_ _[α]_

_̸_





_̸_



_̸_


max
_k_

_̸_


_̸_



_̸_


- _|Mkj_ [(] _[m]_ [)] _[|]_ [ = max]

_k_
_j̸_ = _k_


_̸_



_̸_


_̸_


_≤_ 

_b_ flipped in _k_ _̸_



_̸_


_̸_


 [�]


_a̸_ = _b_



_̸_


_̸_


_J_
_|a −_ _b|_ _[α]_

_̸_



_̸_


_̸_




_̸_



_̸_


_̸_


_̸_


       _<_ 2 _Jζ_ ( _α_ ) = 2 _mJζ_ ( _α_ ) _._


_b_ flipped in _k_


This uniform bound _|λ_ [(] _[m]_ [)] _| <_ 2 _mJζ_ ( _α_ ) holds for all _m ≥_ 1. Thus, the first-order corrected energies
_Em_ _[′]_ [for the] _[ m]_ [-th excited subspace lie in the band [] _[E]_ _m_ [(0)] _[−]_ [2] _[mJζ]_ [(] _[α]_ [)] _[, E]_ _m_ [(0)] [+ 2] _[mJζ]_ [(] _[α]_ [)]. The lowest]
energy in this band is bounded below by


_Em,_ _[′]_ min _[≥−]_ [(] _[n][ −]_ [2] _[m]_ [)] _[h][ −]_ [2] _[mJζ]_ [(] _[α]_ [)] _[.]_


To establish a lower bound on the true spectral gap, we use the variational principle for the
ground state energy, _E_ 0 _≤⟨ψ_ 0 [(0)] _[|][H][|][ψ]_ 0 [(0)] _[⟩]_ [=] _[ −][nh]_ [. The gap between the bottom of the] _[ m]_ [-th excited]
band and the upper bound on the ground state energy is therefore


_Em,_ _[′]_ min _[−]_ _[E]_ [0] _[≥]_ [(] _[−]_ [(] _[n][ −]_ [2] _[m]_ [)] _[h][ −]_ [2] _[mJζ]_ [(] _[α]_ [))] _[ −]_ [(] _[−][nh]_ [)]

= 2 _m_ ( _h −_ _Jζ_ ( _α_ )) _._


This holds for all _m ≥_ 1. The overall first-order spectral gap ∆ _[′]_ is bounded by the minimum of
these gaps over all _m_ :
∆ _[′]_ _≥_ min
_m≥_ 1 _[{]_ [2] _[m]_ [(] _[h][ −]_ _[Jζ]_ [(] _[α]_ [))] _[}][.]_


Provided _h/J > ζ_ ( _α_ ), the term in the parenthesis is positive, and the minimum is attained at
_m_ = 1. Thus, the spectral gap is governed by the first excited subspace, with a lower bound of
∆ _[′]_ _≥_ 2( _h −_ _Jζ_ ( _α_ )). This ensures that no excited energy crosses the ground state energy at first
order.
Our numerical computation of the spectral gap for systems up to _n_ = 26 is presented in Fig. 4.
The data shows that the gap converges to an asymptotic value that is slightly below the first-order
theoretical prediction of 2( _h −_ _Jζ_ ( _α_ )). This suggests that while first-order theory provides a very
good estimate, the net effect of higher-order perturbative corrections in this regime is to lower the
spectral gap slightly.


53


**B.2** **Pre-factor scaling of higher order Trotterization for Ising Hamiltonians**
**with hybrid interactions**


In this section, we derive _λ_ comm and _λ_ _[′]_ comm [for the Hamiltonians of the spin models considered]
in this work. We explicitly derive a lower and an upper bound for _H_ defined in Eq. (6.3). The
derivation is similar for the standard long-range Ising Hamiltonian in Eq. (6.2). Formally, we state
the following lemma


**Lemma B.1.** _Fix h, J >_ 0 _, g ≥_ 0 _, and α >_ 1 _. For n ≥_ 3 _consider the n-qubit Hamiltonian_



_n_






_XiXi_ +1 _−_ _[g]_

_n_

_i_ =1



1

_[Z][i][Z][j][,]_
_|i −_ _j|_ ~~_[α]_~~



_H_ = _−h_



_n_


_Zi −_ _J_

_i_ =1



_n_




 

1 _≤i<j≤n_



_with periodic boundary conditions and let S be the fine-grained set of its Pauli-string summands,_


_S_ = _{hZi_ : 1 _≤_ _i ≤_ _n} ∪{J XiXi_ +1 : 1 _≤_ _i ≤_ _n} ∪_   - _ng_ _[|][i][−][j][|][−][α][ Z][i][Z][j]_ [ : 1] _[ ≤]_ _[i < j][ ≤]_ _[n]_   - _._


_For a fixed integer k ≥_ 1 _, define the (universal)_ (2 _k_ +1) _-fold commutator prefactor_


_α_ comm [(2] _[k]_ [+1)] [=]    - _∥_ ad _S_ 1 _◦· · · ◦_ ad _S_ 2 _k_ ( _S_ 2 _k_ +1) _∥_ _,_ ad _A_ ( _B_ ) := [ _A, B_ ] _._

( _S_ 1 _,...,S_ 2 _k_ +1) _∈S_ [2] _[k]_ [+1]


_Then there exist constants C_ 1 _, C_ 2 _, independent of n, such that_


_nC_ 1 _≤_ _α_ comm [(2] _[k]_ [+1)] _[≤]_ _[nC]_ [2] _[,]_ (B.1)


_for all n ≥_ 3 _. So,_


                  - �1 _/_ (2 _k_ +1)
_λ_ comm = Θ( _n_ [1] _[/]_ [(2] _[k]_ [+1)] ) _,_ _λ_ _[′]_ comm [=] _α_ comm [(2] _[k]_ [+1)] = Θ( _n_ [1] _[/]_ [(2] _[k]_ [+1)] ) _._


_Proof._ By definition of _λ_ _[′]_ comm [, we have]


                 - �1 _/_ (2 _k_ +1)
_λ_ _[′]_ comm [=] _α_ comm [(2] _[k]_ [+1)] _._


The fact that
_λ_ comm = _O_ ( _n_ [1] _[/]_ [(2] _[k]_ [+1)] ) _,_


follows from Eq. (B.1) and [21, Remark 3.2]. Ref. [21, Remark 3.2] also shows that


                 - �1 _/_ (2 _k_ +1)
_λ_ comm _≥_ _α_ comm [(2] _[k]_ [+1)] _._


Thus, all we need to prove is Eq. (B.1). This is what we will show in the subsequent steps of this
proof.
For simplicity, let us define


_ZaZb_

_Ai_ := _hZi,_ _Bi_ := _JXiXi_ +1 _,_ _Cab_ := _[g]_ (1 _≤_ _a < b ≤_ _n_ ) _,_

_n_ _[·]_ _|a −_ _b|_ _[α]_


so that we have


_S_ = _{Ai_ : 1 _≤_ _i ≤_ _n} ∪{Bi_ : 1 _≤_ _i ≤_ _n} ∪{Cab_ : 1 _≤_ _a < b ≤_ _n}._


54


So, using elementary Pauli algebra, we immediately obtain,


[ _Ai, Aj_ ] = 0 _,_ [ _Bi, Bj_ ] = 0 for all _i, j,_ [ _Aℓ, Cab_ ] = 0 for all _ℓ, a, b,_ (B.2)


and

[ _Cab, Bi_ ] _̸_ = 0 _⇐⇒_ _|{a, b} ∩{i, i_ + 1 _}|_ = 1 _,_ (B.3)


while [ _Cab, Ccd_ ] = 0 always. Moreover,


[ _Ai, Bi_ ] = 2 _ihJ YiXi_ +1 _,_ [ _Ai_ +1 _, Bi_ ] = 2 _ihJ XiYi_ +1 _,_ (B.4)


and [ _Aj, Bi_ ] = 0 for _j /∈{i, i_ + 1 _}_ . By definition, we have


_α_ comm [(2] _[k]_ [+1)] [=]    - _∥_ ad _S_ 1 _◦· · · ◦_ ad _S_ 2 _k_ ( _S_ 2 _k_ +1) _∥_ _,_ ad _A_ ( _B_ ) = [ _A, B_ ] _,_

( _S_ 1 _,...,S_ 2 _k_ +1) _∈S_ [2] _[k]_ [+1]


is a sum of norms of (2 _k_ +1)-fold nested commutators over _all_ ordered (2 _k_ +1)-tuples from _S_ . We
prove a lower bound of order _n_ by exhibiting _n_ explicit ordered tuples whose contributions are
strictly positive and identical up to the constant 2 [2] _[k]_ min _{h_ _[k]_ [+1] _J_ _[k]_ _, h_ _[k]_ _J_ _[k]_ [+1] _}_, and then we prove an
upper bound of order _n_ by showing that every nonzero nested commutator is _anchored_ on a unique
bond and contributes at most a bond-dependent constant independent of _n_ .


_Lower bound._ Fix a bond index _i ∈{_ 1 _, . . ., n}_ . Consider the two alternating words of length 2 _k_ +1


**w** _i,k_ [(] _[A]_ [)] [= (] _[A][i][, B][i][, A][i][, B][i][, . . ., A][i][, B][i][, A][i]_ [)] _[,]_ **w** _i,k_ [(] _[B]_ [)] [= (] _[B][i][, A][i][, B][i][, A][i][, . . ., B][i][, A][i][, B][i]_ [)] _[,]_ (B.5)


in which _Ai_ and _Bi_ alternate and the first/last entries are as indicated. Define the associated nested
commutators


_L_ [(] _i,k_ _[A]_ [)] [:= ad] _[A][i]_ _[◦]_ [ad] _[B][i]_ _[◦· · · ◦]_ [ad] _[A][i]_ [(] _[B][i]_ [)] _[,]_ _L_ [(] _i,k_ _[B]_ [)] [:= ad] _[B][i]_ _[◦]_ [ad] _[A][i]_ _[◦· · · ◦]_ [ad] _[B][i]_ [(] _[A][i]_ [)] _[,]_


where the number of ad’s is 2 _k_ in each case. We claim that, for every _k ≥_ 1,


�� _L_ ( _i,kA_ ) ���= 22 _khk_ +1 _J_ _k,_ ��� _L_ ( _i,kB_ )�� = 22 _khkJ_ _k_ +1 _._ (B.6)


We prove Eq. (B.6) by induction on _k_ . For _k_ = 1, using Eq. (B.4) and [ _Zi, Yi_ ] = _−_ 2 _iXi_ we compute


[ _Ai, Bi_ ] = 2 _ihJ YiXi_ +1 _,_ [ _Ai,_ [ _Ai, Bi_ ]] = 2 _ihJ_ [ _Zi, Yi_ ] _Xi_ +1 = 2 _ihJ ·_ ( _−_ 2 _i_ ) _XiXi_ +1 = 4 _h_ [2] _J XiXi_ +1 _,_


whence _∥L_ [(] _i,_ _[A]_ 1 [)] _[∥]_ [= 4] _[h]_ [2] _[J]_ [ = 2][2] _[ h]_ [2] _[J]_ [. Similarly, using [] _[X][i][, Y][i]_ [] = 2] _[iZ][i]_ [,]


[ _Bi,_ [ _Bi, Ai_ ]] = [ _JXiXi_ +1 _, −_ 2 _ihJ YiXi_ +1] = _−_ 2 _ihJ_ [2] [ _XiXi_ +1 _, YiXi_ +1] = _−_ 2 _ihJ_ [2] [ _Xi, Yi_ ] = 4 _hJ_ [2] _Zi,_


so _∥L_ [(] _i,_ _[B]_ 1 [)] _[∥]_ [= 4] _[hJ]_ [2][ = 2][2] _[ hJ]_ [2][. This establishes Eq. (][B.6][) for] _[ k]_ [ = 1.]

Assume Eq. (B.6) holds for some _k ≥_ 1. Consider _L_ [(] _i,k_ _[A]_ [)] +1 [. By definition,]


_L_ [(] _i,k_ _[A]_ [)] +1 [= ad] _[A][i]_ _[◦]_ [ad] _[B][i]_            - _L_ [(] _i,k_ _[A]_ [)]            - _._


By the induction hypothesis, _L_ [(] _i,k_ _[A]_ [)] [is, up to a phase, a single Pauli string supported on] _[ {][i, i]_ [ + 1] _[}]_
with norm 2 [2] _[k]_ _h_ _[k]_ [+1] _J_ _[k]_ . The commutator with _Bi_ = _JXiXi_ +1 acts nontrivially only on site _i_ (the
site _i_ +1 Pauli in _L_ [(] _i,k_ _[A]_ [)] [is either] _[ X][i]_ [+1][ or] _[ Z][i]_ [+1][, but [] _[X][i]_ [+1] _[, X][i]_ [+1][] = 0 and [] _[Z][i]_ [+1] _[, X][i]_ [+1][] = 2] _[iY][i]_ [+1][ gives]


55


again a single-site Pauli), and in any case _∥_ [ _Bi, ·_ ] _∥_ = 2 _J∥· ∥_ because the commutator of _Xi_ with
the site- _i_ Pauli flips _Xi ↔_ _Yi_ (or _Xi ↔_ _Zi_ ) and contributes a factor 2, while the _Xi_ +1 factor either
commutes or also flips, contributing a factor of 1 in norm. Thus,

���ad _Bi_                  - _L_ [(] _i,k_ _[A]_ [)] ���� = 2 _J_ ��� _L_ ( _i,kA_ )��� = 22 _k_ +1 _hk_ +1 _J_ _k_ +1 _._


Applying next ad _Ai_ multiplies the norm by a factor 2 _h_ for the same reason, hence
��� _L_ ( _i,kA_ )+1��� = ���ad _Ai ◦_ ad _Bi_            - _L_ [(] _i,k_ _[A]_ [)] ���� = 2 _h ·_ 22 _k_ +1 _hk_ +1 _J_ _k_ +1 = 22( _k_ +1) _h_ ( _k_ +1)+1 _J_ _k_ +1 _._


This proves the first identity in Eq. (B.6) for _k_ + 1. The proof for _L_ [(] _i,k_ _[B]_ +1 [)] [= ad] _[B][i]_ _[◦]_ [ad] _[A][i]_ [(] _[L]_ [(] _i,k_ _[B]_ [)][) is]
identical upon exchanging the roles of _Ai_ and _Bi_ ; one obtains


_∥L_ [(] _i,k_ _[B]_ +1 [)] _[∥]_ [= 2] _[J][ ·]_ [ (2] _[h]_ [)] _[ ∥L]_ [(] _i,k_ _[B]_ [)] _[∥]_ [= 2][2(] _[k]_ [+1)] _[h][k]_ [+1] _[J]_ [(] _[k]_ [+1)+1] _[.]_


This completes the induction and proves Eq. (B.6) for all _k ≥_ 1.
Since _α_ comm [(2] _[k]_ [+1)] is a sum over _all_ ordered (2 _k_ +1)-tuples from _S_, the two words **w** _i,k_ [(] _[A]_ [)] [and] **[ w]** _i,k_ [(] _[B]_ [)]
appear among the summands for each bond _i_ . Therefore,



_α_ comm [(2] _[k]_ [+1)] _≥_



_n_


min _{∥L_ [(] _i,k_ _[A]_ [)] _[∥][,][ ∥L]_ _i,k_ [(] _[B]_ [)] _[∥}]_ [ = 2][2] _[k]_ [ min] _[{][h][k]_ [+1] _[J]_ _[k][, h][k][J]_ _[k]_ [+1] _[}][ n.]_ (B.7)
_i_ =1



This yields the desired lower bound with _C_ 1 = 2 [2] _[k]_ min _{h_ _[k]_ [+1] _J_ _[k]_ _, h_ _[k]_ _J_ _[k]_ [+1] _}_ .


_Upper bound._ We show that every nonzero (2 _k_ +1)-fold nested commutator in the sum is _anchored_
on a unique nearest-neighbor bond and contributes at most a bond-dependent constant. Let


_T_ := ad _S_ 1 _◦· · · ◦_ ad _S_ 2 _k_ ( _S_ 2 _k_ +1) _,_ _Sℓ_ _∈S,_


be such that _T ̸_ = 0. If none of the _Sℓ_ is a bond operator _Bi_, then all _Sℓ_ are _Z_ -type strings ( _Ai_ or
_Cab_ ), which commute by Eq. (B.2), and hence _T_ = 0, a contradiction. Thus some _Bi_ must appear.
Choose one such _Bi_ and call _i_ the _anchor index_ . We claim the following support property: for each
depth _d_ = 0 _,_ 1 _, . . .,_ 2 _k_, if we define recursively


_T_ 0 := _S_ 2 _k_ +1 _,_ _Td_ +1 := [ _Sd_ +1 _, Td_ ] _,_


then _Td_ is either 0 or a single Pauli string supported in the set _{i, i_ +1 _}∪Jd_, where _Jd_ is a subset of
_{_ 1 _, . . ., n} \ {i, i_ + 1 _}_ consisting of those indices that appear as the _far_ endpoint in _Cab_ ’s that touch
exactly one of the anchor sites at the steps 1 _, . . ., d_ . Moreover, if _Sd_ +1 is a local operator among
_{Ai, Ai_ +1 _, Bi}_, then _Sd_ +1 must act nontrivially on at least one of the anchor sites and anticommute
there with the site-Pauli of _Td_ for the commutator not to vanish; if _Sd_ +1 is long-range of the form
_Cab_, then necessarily _|{a, b}∩{i, i_ +1 _}|_ = 1 (cf. Eq. (B.3)), and its far endpoint _j ∈{a, b}\{i, i_ +1 _}_
is adjoined to _Jd_ to produce _Jd_ +1.
The support claim follows by induction on _d_ . For _d_ = 0 it is obvious. Assume it holds at depth
_d_, so _Td_ is a Pauli string supported on _{i, i_ + 1 _} ∪Jd_ . If _Sd_ +1 _∈{As_ : 1 _≤_ _s ≤_ _n}_, then [ _As, Td_ ] _̸_ = 0
only if _s ∈{i, i_ + 1 _}_ (since _As_ commutes with any _Z_ on sites in _Jd_ and with any _X_ or _Y_ off site
_s_ ), and moreover the commutator is nonzero only if the site- _s_ Pauli in _Td_ anticommutes with _Zs_ ;
in that case [ _As, Td_ ] is again a single Pauli string supported on _{i, i_ + 1 _} ∪Jd_ . If _Sd_ +1 = _Bi_, then

[ _Bi, Td_ ] _̸_ = 0 only if at least one of the site- _i_ or site-( _i_ +1) Paulis in _Td_ anticommutes with _X_ ; in that
case [ _Bi, Td_ ] is again a Pauli string supported on _{i, i_ + 1 _} ∪Jd_ (the _Xi_ +1 factor commutes through


56


any _Zj_, _j ∈Jd_ ). If _Sd_ +1 = _Cab_, then [ _Cab, Td_ ] _̸_ = 0 only if _|{a, b} ∩{i, i_ + 1 _}|_ = 1 by Eq. (B.3), and
then the far endpoint _j ∈{a, b} \ {i, i_ + 1 _}_ is appended to the set of remote indices: [ _Cab, Td_ ] is
again a single Pauli string supported on _{i, i_ + 1 _} ∪_ ( _Jd ∪{j}_ ). This proves the induction step and
hence the support property.
As a consequence, every nonzero nested commutator is _localized_ at a unique anchor bond _i_ and
can be generated by an ordered word of length 2 _k_ +1 in which each letter is either _local_ ( _Ai_, _Ai_ +1,
or _Bi_ ) or _long-range_ of the form _Ci,j_ or _Ci_ +1 _,j_ with _j /∈{i, i_ + 1 _}_ . Let us upper bound the total
contribution of all such words anchored at bond _i_ .
For a fixed anchor _i_, consider first purely local words (no long-range letters). For any such
word **u** = ( _U_ 1 _, . . ., U_ 2 _k_ +1) with _Uℓ_ _∈{Ai, Ai_ +1 _, Bi}_, repeated application of the Pauli commutators
shows that the nested commutator _T_ ( **u** ) := ad _U_ 1 _◦· · ·◦_ ad _U_ 2 _k_ ( _U_ 2 _k_ +1) is either zero or (when nonzero)
a single Pauli string on _{i, i_ + 1 _}_ multiplied by a scalar of the form 2 [2] _[k]_ _h_ _[p]_ _J_ [2] _[k]_ [+1] _[−][p]_ for some _p ∈_
_{_ 0 _,_ 1 _, . . .,_ 2 _k_ + 1 _}_ (each bracket by _A_ multiplies by 2 _h_ and each bracket by _B_ multiplies by 2 _J_ in
norm). Therefore

    - �� _T_ ( **u** )�� _≤_ 32 _k_ +1 22 _k_ max _{h, J}_ 2 _k_ +1 =: _Ck_ loc [(] _[h, J]_ [)] _[,]_ (B.8)

**u** _∈{Ai,Ai_ +1 _,Bi}_ [2] _[k]_ [+1]


a constant depending only on _k, h, J_ .
Next consider words that contain exactly _m ≥_ 1 long-range letters. Any such letter must
be either _Ci,j_ or _Ci_ +1 _,j_ with _j /∈{i, i_ + 1 _}_ by the support property. The coefficient of _Ci,j_ is
( _g/n_ ) _|i −_ _j|_ _[−][α]_ ; summing this over all admissible _j_ yields


_̸_



1 
[+]
_r_ _[α]_

_̸_ _r≥_ 1



1
_r_ _[α]_

_̸_





 _≤_ [2] _n_ _[g]_ _[ζ]_ [(] _[α]_ [)] _[.]_

_̸_





 [�]

_̸_ _r≥_ 1






_j̸_ = _i,i_ +1



_g_ 1

_[≤]_ _[g]_
_n_ _|i −_ _j|_ _[α]_ _n_

_̸_



_̸_


Thus, after summing over all allowed choices of the far endpoints for the _m_ long-range letters in
positions where they yield a nonzero commutator, the total weight contributed by the long-range
coefficients is bounded by

             - 2 _g_             - _m_

_._
_n_ _[ζ]_ [(] _[α]_ [)]



_̸_


The remaining 2 _k_ +1 _−_ _m_ letters are local and contribute a factor bounded by 2 [2] _[k]_ max _{h, J}_ [2] _[k]_ [+1] _[−][m]_

in norm, exactly as in the local case. The number of operator-type patterns with exactly _m_ longrange letters is at most �2 _k_ +1� _·_ 3 [2] _[k]_ [+1] _[−][m]_ (choose the _m_ positions and fill the rest with three local
_m_
choices). Hence the total contribution of all words with exactly _m_ long-range letters anchored at
bond _i_ is bounded by

�2 _k_ + 1�         - 2 _g_         - _m_

3 [2] _[k]_ [+1] _[−][m]_ 2 [2] _[k]_ max _{h, J}_ [2] _[k]_ [+1] _[−][m]_ _._

_m_ _n_ _[ζ]_ [(] _[α]_ [)]



_̸_


_g_ - _m_

_._
_n_ _[ζ]_ [(] _[α]_ [)]



_̸_


- - 2 _g_
3 [2] _[k]_ [+1] _[−][m]_ 2 [2] _[k]_ max _{h, J}_ [2] _[k]_ [+1] _[−][m]_



_̸_


Summing over _m ≥_ 1 and using the binomial theorem we obtain the bound



_̸_





_̸_


     _∥T_ ( _·_ ) _∥≤_ 2 [2] _[k]_ 3 max _{h, J}_ + [2] _[g]_



_̸_


words anchored at _i_
with _m≥_ 1 long-range letters



_̸_


[2] _[g]_ �2 _k_ +1 _−_ _Ck_ [loc][(] _[h, J]_ [) =:] _[ C]_ _k_ [lr][(] _[h, J, g, α]_ [;] _[ n]_ [)] _[,]_

_n_ _[ζ]_ [(] _[α]_ [)]



_̸_


(B.9)
where _Ck_ [lr][(] _[h, J, g, α]_ [;] _[ n]_ [) is bounded as the term involving (2] _[g/n]_ [)] _[ζ]_ [(] _[α]_ [) vanishes as] _[ n][ →∞]_ [and the]
difference subtracts the purely local part already counted in Eq. (B.8).


57


In particular, there exists a constant _Ck_ [lr][(] _[h, J, g, α]_ [) such that] _[ C]_ _k_ [lr][(] _[h, J, g, α]_ [;] _[ n]_ [)] _[ ≤]_ _[C]_ _k_ [lr][(] _[h, J, g, α]_ [)]
for all _n_ . Then, combining Eq. (B.8) and Eq. (B.9), the total contribution of all words anchored at
a fixed bond _i_ is at most
_Ck_ [loc][(] _[h, J]_ [) +] _[ C]_ _k_ [lr][(] _[h, J, g, α]_ [)] _[,]_


a constant independent of _n_ . Finally, summing over the _n_ anchor bonds yields


_α_ comm [(2] _[k]_ [+1)] _≤_ _n Ck_ [loc][(] _[h, J]_ [) +] _[ n]_ [ sup] _k_ [(] _[h, J, g, α]_ [;] _[ n]_ [)] _[ ≤]_ _[C]_ [2] _[n.]_ (B.10)
_n_ _[C]_ [lr]


The lower bound (B.7) and the upper bound (B.10) together imply that _α_ comm [(2] _[k]_ [+1)] [= Θ(] _[n]_ [). This]
completes the proof.

### **Appendix C Randomized QSVT for density operators**


We prove a result analogous to Theorem 3.4, but for density operators. Formally, we state the
following result:


**Theorem C.1.** _Consider the same assumptions as in Theorem 3.4. Let O be an observable and_
_ρ be a density operator. Then there is a procedure using T_ = _O_ ( _ε_ _[−]_ [2] log(1 _/δ_ )) _repetitions of the_
_quantum circuit in Proposition 3.3, outputs µ such that_

                  ��� _µ −_ Tr _O P_ ( _H_ _[′]_ ) _ρ P_ ( _H_ _[′]_ ) _[†]_ [���]                                                             - _≤_ _ε∥O∥_


_with probability at least_ 1 _−_ _δ. Each repetition has circuit depth_ _O_ ( _d_ ) _and uses two ancilla qubits._

[�]

_Proof._ We consider the case when _P_ ( _x_ ) is an even polynomial. Denote _ρ_ _[′]_ = _|_ 1 _⟩⟨_ 1 _|⊗_ _ρ_ . [4] Also denote
_ρ_ ˜ = _|_ + _⟩⟨_ + _| ⊗_ _ρ_ _[′]_ . Let
_U_ ˜Φ [(] _[R]_ [)] = _|_ 0 _⟩⟨_ 0 _| ⊗_ _U_ Φ [(] _[R]_ [0][)] + _|_ 1 _⟩⟨_ 1 _| ⊗_ _U_ Φ [(] _[R]_ [1][)] _,_

be a random quantum circuit with two independent applications of _U_ Φ [(] _[R]_ [)][. Then it is easy to check]
that


1
_U_ ˜Φ [(] _[R]_ [)] _ρ_ ˜ ( _U_ [˜] Φ [(] _[R]_ [)][)] _[†]_ = Φ _ρ_ _[′]_ ( _U_ Φ [(] _[R]_ [0][)] ) _[†]_ + [1] Φ _ρ_ _[′]_ ( _U_ Φ [(] _[R]_ [1][)] ) _[†]_
2 _[|]_ [0] _[⟩⟨]_ [0] _[| ⊗]_ _[U]_ [(] _[R]_ [0][)] 2 _[|]_ [0] _[⟩⟨]_ [1] _[| ⊗]_ _[U]_ [(] _[R]_ [0][)]



+ [1]




[1] 2 _[|]_ [1] _[⟩⟨]_ [0] _[| ⊗]_ _[U]_ Φ [(] _[R]_ [1][)] _ρ_ _[′]_ ( _U_ Φ [(] _[R]_ [0][)] ) _[†]_ + 2 [1]



2 _[|]_ [1] _[⟩⟨]_ [1] _[| ⊗]_ _[U]_ Φ [(] _[R]_ [1][)] _ρ_ _[′]_ ( _U_ Φ [(] _[R]_ [1][)] ) _[†]_ _._



Denote _O_ _[′]_ = _|_ 1 _⟩⟨_ 1 _| ⊗_ _O_, then we have




  Tr ( _X ⊗_ _O_ _[′]_ ) _U_ [˜] Φ [(] _[R]_ [)] _ρ_ ˜ ( _U_ [˜] Φ [(] _[R]_ [)][)] _[†]_ [�] = [1]




  2 [Tr] _O_ _[′]_ _U_ Φ [(] _[R]_ [1][)] _ρ_ _[′]_ ( _U_ Φ [(] _[R]_ [0][)] ) _[†]_ [�] _._



2 [1] [Tr] - _O_ _[′]_ _U_ Φ [(] _[R]_ [0][)] _ρ_ _[′]_ ( _U_ Φ [(] _[R]_ [1][)] ) _[†]_ [�] + 2 [1]



This means

         -         -         -         E Tr ( _X ⊗_ _O_ _[′]_ ) _U_ [˜] Φ [(] _[R]_ [)] _ρ_ ˜ ( _U_ [˜] Φ [(] _[R]_ [)][)] _[†]_ [��] = E Tr _O_ _[′]_ _U_ Φ [(] _[R]_ [0][)] _ρ_ _[′]_ ( _U_ Φ [(] _[R]_ [1][)] ) _[†]_ [��]

= Tr                     - _O_ _[′]_ _U_ Φ _ρ_ _[′]_ _U_ Φ�


                       -                        - _∗_ _∗_
_≈ε_ Tr _O_ _[′]_
_∗_ _P_ ( _H_ _[′]_ ) _ρ P_ ( _H_ _[′]_ ) _[†]_


                          _≈ε_ Tr _O P_ ( _H_ _[′]_ ) _ρ P_ ( _H_ _[′]_ ) _[†]_ [�] _._



��



4When _f_ ( _x_ ) is odd, we cannot directly assume _ρ′_ = _|_ 0 _⟩⟨_ 1 _| ⊗_ _ρ_ as it is not a density operator. However, we can
multiply _U_ Φ by _X ⊗_ _I_ to change the position of _P_ ( _H_ _[′]_ ) so that we can now use _ρ_ _[′]_ = _|_ 0 _⟩⟨_ 0 _| ⊗_ _ρ_ .


58


Now we can apply Hoeffding’s inequality to estimate the above mean value to obtain the claimed
result by a similar argument to the proof of Theorem 3.4. The trace can be computed by measuring
( _X ⊗_ _O_ _[′]_ ) on the state _U_ [˜] Φ [(] _[R]_ [)] _ρ_ ˜ ( _U_ [˜] Φ [(] _[R]_ [)][)] _[†]_ [, so there is no need to introduce a new ancilla. In total, 2]
ancilla qubits are used.

### **References**


[1] Andr´as Gily´en, Yuan Su, Guang Hao Low, and Nathan Wiebe. Quantum singular value
transformation and beyond: exponential improvements for quantum matrix arithmetics. In
_Proceedings of the 51st Annual ACM SIGACT Symposium on Theory of Computing_, pages
193–204, 2019.


[2] Guang Hao Low and Isaac L. Chuang. Hamiltonian simulation by qubitization. _Quantum_,
3:163, 2019.


[3] Shantanav Chakraborty, Andr´as Gily´en, and Stacey Jeffery. The power of block-encoded
matrix powers: Improved regression techniques via faster hamiltonian simulation. In _46th_
_International Colloquium on Automata, Languages, and Programming (ICALP 2019)_, volume
132 of _Leibniz International Proceedings in Informatics (LIPIcs)_, pages 33:1–33:14, Dagstuhl,
Germany, 2019.


[4] Guang Hao Low and Isaac L. Chuang. Optimal Hamiltonian simulation by quantum signal
processing. _Physical Review Letters_, 118, 2017.


[5] Lin Lin and Yu Tong. Optimal polynomial based quantum eigenstate filtering with application
to solving quantum linear systems. _Quantum_, 4:361, 2020.


[6] Shantanav Chakraborty, Aditya Morolia, and Anurudh Peduri. Quantum regularized least
squares. _Quantum_, 7:988, 2023.


[7] Simon Apers, Andr´as Gily´en, and Stacey Jeffery. A unified framework of quantum walk
search. In _38th International Symposium on Theoretical Aspects of Computer Science (STACS_
_2021)_, volume 187 of _Leibniz International Proceedings in Informatics (LIPIcs)_, pages 6:1–6:13,
Dagstuhl, Germany, 2021.


[8] Fernando G.S.L. Brand˜ao, Amir Kalev, Tongyang Li, Cedric Yen-Yu Lin, Krysta M. Svore, and
Xiaodi Wu. Quantum SDP solvers: Large speed-ups, optimality, and applications to quantum
learning. In _Proceedings of the 46th International Colloquium on Automata, Languages, and_
_Programming (ICALP 2019)_, volume 132 of _Leibniz International Proceedings in Informatics_
_(LIPIcs)_, pages 27:1–27:14, 2019.


[9] Joran van Apeldoorn and Andr´as Gily´en. Improvements in Quantum SDP-Solving with Applications. In _46th International Colloquium on Automata, Languages, and Programming (ICALP_
_2019)_, volume 132 of _Leibniz International Proceedings in Informatics (LIPIcs)_, pages 99:1–
99:15, Dagstuhl, Germany, 2019.


[10] Lin Lin and Yu Tong. Near-optimal ground state preparation. _Quantum_, 4:372, 2020.


[11] John M Martyn, Zane M. Rossi, Andrew K. Tan, and Isaac L. Chuang. Grand unification of
quantum algorithms. _PRX Quantum_, 2(4):040203, 2021.


59


[12] Subir Sachdev. _Quantum Phase Transitions_ . Cambridge University Press, 2nd edition, 2011.


[13] Subir Sachdev and Jinwu Ye. Gapless spin-fluid ground state in a random quantum Heisenberg
magnet. _Physical Review Letters_, 70(21):3339, 1993.


[14] Juan Maldacena and Douglas Stanford. Remarks on the Sachdev-Ye-Kitaev model. _Physical_
_Review D_, 94(10):106002, 2016.


[15] Ryan Babbush, Dominic W. Berry, and Hartmut Neven. Quantum simulation of the sachdevye-kitaev model by asymmetric qubitization. _Physical Review A_, 99:040301, Apr 2019.


[16] Yudong Cao, Jonathan Romero, Jonathan P. Olson, Matthias Degroote, Peter D. Johnson,
M´aria Kieferov´a, Ian D. Kivlichan, Tim Menke, Borja Peropadre, Nicolas P. D. Sawaya, Sukin
Sim, Libor Veis, and Al´an Aspuru-Guzik. Quantum chemistry in the age of quantum computing. _Chemical Reviews_, 119(19):10856–10915, 2019. PMID: 31469277.


[17] Earl Campbell. Random compiler for fast Hamiltonian simulation. _Physical Review Letters_,
123(7):070503, 2019.


[18] Jarrod R. McClean, Nicholas C. Rubin, Kevin J. Sung, Ian D. Kivlichan, Xavier BonetMonroig, Yudong Cao, Chengyu Dai, E. Schuyler Fried, Craig Gidney, Brendan Gimby, Pranav
Gokhale, Thomas H¨aner, Tarini Hardikar, Vojtˇech Havliˇcek, Oscar Higgott, Cupjin Huang,
Josh Izaac, Zhang Jiang, Xinle Liu, Sam McArdle, Matthew Neeley, Thomas O’Brien, Bryan
O’Gorman, Isil Ozfidan, Maxwell D. Radin, Jhonathan Romero, Nicolas P. D. Sawaya, Bruno
Senjean, Kanav Setia, Sukin Sim, Damian S. Steiger, Mark Steudtner, Qiming Sun, Wei Sun,
Daochen Wang, Fang Zhang, and Ryan Babbush. OpenFermion: the electronic structure
package for quantum computers. _Quantum Science and Technology_, 5(3):034014, 2020.


[19] Yuan Su, Dominic W. Berry, Nathan Wiebe, Nicholas Rubin, and Ryan Babbush. Faulttolerant quantum simulations of chemistry in first quantization. _PRX Quantum_, 2:040332,
Nov 2021.


[20] Ryan Babbush, Nathan Wiebe, Jarrod McClean, James McClain, Hartmut Neven, and Garnet
Kin-Lic Chan. Low-depth quantum simulation of materials. _Physical Review X_, 8:011044, Mar
2018.


[21] Shantanav Chakraborty, Soumyabrata Hazra, Tongyang Li, Changpeng Shao, Xinzhao Wang,
and Yuxin Zhang. Quantum singular value transformation without block encodings: Nearoptimal complexity with minimal ancilla. _arXiv:2504.02385_, 2025.


[22] Seth Lloyd. Universal quantum simulators. _Science_, 273(5278):1073–1078, 1996.


[23] Andrew M. Childs, Yuan Su, Minh C. Tran, Nathan Wiebe, and Shuchen Zhu. Theory of
Trotter error with commutator scaling. _Physical Review X_, 11(1):011020, 2021.


[24] Andrew M. Childs and Nathan Wiebe. Hamiltonian simulation using linear combinations of
unitary operations. _Quantum Information & Computation_, 12(11-12):901–924, 2012.


[25] James D. Watson. Randomly compiled quantum simulation with exponentially reduced circuit
depths. _arXiv:2411.04240_, 2024.


[26] Kouhei Nakaji, Mohsen Bagherimehrab, and Al´an Aspuru-Guzik. High-Order Randomized
Compiler for Hamiltonian Simulation. _PRX Quantum_, 5:020330, 2024.


60


[27] Shantanav Chakraborty. Implementing any linear combination of unitaries on intermediateterm quantum computers. _Quantum_, 8:1496, 2024.


[28] Samson Wang, Sam McArdle, and Mario Berta. Qubit-efficient randomized quantum algorithms for linear algebra. _PRX Quantum_, 5(2):020324, 2024.


[29] Songqinghao Yang and Jin-Peng Liu. Circuit-efficient randomized quantum simulation of
non-unitary dynamics with observable-driven and symmetry-aware designs. _arXiv preprint_
_arXiv:2509.08030_, 2025.


[30] Yulong Dong, Lin Lin, and Yu Tong. Ground-state preparation and energy estimation on early
fault-tolerant quantum computers via quantum eigenvalue transformation of unitary matrices.
_PRX Quantum_, 3(4):040305, 2022.


[31] Ruizhe Zhang, Guoming Wang, and Peter Johnson. Computing ground state properties with
early fault-tolerant quantum computers. _Quantum_, 6:761, 2022.


[32] Lin Lin and Yu Tong. Heisenberg-limited ground-state energy estimation for early faulttolerant quantum computers. _PRX Quantum_, 3:010318, 2022.


[33] Guoming Wang, Daniel Stilck Fran¸ca, Ruizhe Zhang, Shuchen Zhu, and Peter D. Johnson.
Quantum algorithm for ground state energy estimation using circuit depth with exponentially
improved dependence on precision. _Quantum_, 7:1167, 2023.


[34] Amara Katabarwa, Katerina Gratsea, Athena Caesura, and Peter D. Johnson. Early faulttolerant quantum computing. _PRX Quantum_, 5:020101, 2024.


[35] Youle Wang, Lei Zhang, Zhan Yu, and Xin Wang. Quantum phase processing and its applications in estimating phase and entropies. _Physical Review A_, 108(6):062413, 2023.


[36] Danial Motlagh and Nathan Wiebe. Generalized quantum signal processing. _PRX Quantum_,
5(2):020368, 2024.


[37] Guang Hao Low, Vadym Kliuchnikov, and Nathan Wiebe. Well-conditioned multiproduct
Hamiltonian simulation. _arXiv:1907.11679_, 2019.


[38] James D. Watson and Jacob Watkins. Exponentially reduced circuit depths using Trotter
error mitigation. _PRX Quantum_, 6(3):030325, 2025.


[39] Jacob Watkins, Nathan Wiebe, Alessandro Roggero, and Dean Lee. Time-dependent Hamiltonian simulation using discrete-clock constructions. _PRX Quantum_, 5:040316, 2024.


[40] Chi-Fang Chen, Hsin-Yuan Huang, Richard Kueng, and Joel A. Tropp. Concentration for
random product formulas. _PRX Quantum_, 2(4):040305, 2021.


[41] Sam McArdle, Suguru Endo, Al´an Aspuru-Guzik, Simon C. Benjamin, and Xiao Yuan. Quantum computational chemistry. _Rev. Mod. Phys._, 92:015003, Mar 2020.


[42] Nicolo Defenu, Tobias Donner, Tommaso Macri, Guido Pagano, Stefano Ruffo, and Andrea Trombettoni. Long-range interacting quantum systems. _Review of Modern Physics_,
95(3):035002, Aug 2023.


61


[43] Dominic W. Berry, Andrew M. Childs, Richard Cleve, Robin Kothari, and Rolando D. Somma.
Simulating Hamiltonian dynamics with a truncated Taylor series. _Physical Review Letters_,
114:090502, 2015.


[44] John Day Dollard and Charles N. Friedman. _Product Integration with Applications to Differ-_
_ential Equations_ . Encyclopedia of Mathematics and its Applications. Cambridge University
Press, 1984.


[45] Pegah Mohammadipour and Xiantao Li. Reducing circuit depth in lindblad simulation via
step-size extrapolation. _arXiv preprint arXiv:2507.22341_, 2025.


[46] Rui Chao, Dawei Ding, Andras Gilyen, Cupjin Huang, and Mario Szegedy. Finding angles for
quantum signal processing with machine precision. _arXiv preprint arXiv:2003.02831_, 2020.


[47] Yulong Dong, Xiang Meng, K Birgitta Whaley, and Lin Lin. Efficient phase-factor evaluation
in quantum signal processing. _Physical Review A_, 103(4):042419, 2021.


[48] Sushant Sachdeva and Nisheeth K. Vishnoi. Faster algorithms via approximation theory.
_Foundations and Trends® in Theoretical Computer Science_, 9(2):125–210, 2014.


[49] Theodore J. Yoder, Guang Hao Low, and Isaac L. Chuang. Fixed-point quantum search with
an optimal number of queries. _Physical Review Letters_, 113:210501, 2014.


[50] Ashley Montanaro and Changpeng Shao. Quantum and classical query complexities of functions of matrices. In _Proceedings of the 56th Annual ACM Symposium on Theory of Computing_
_(STOC)_, pages 573–584, 2024.


[51] Joran van Apeldoorn, Arjan Cornelissen, Andr´as Gily´en, and Giacomo Nannicini. Quantum
tomography using state-preparation unitaries. In _Proceedings of the 2023 Annual ACM-SIAM_
_Symposium on Discrete Algorithms (SODA)_, pages 1265–1318. SIAM, 2023.


[52] Ran Canetti, Guy Even, and Oded Goldreich. Lower bounds for sampling algorithms for
estimating the average. _Information Processing Letters_, 53(1):17–25, 1995.


[53] Paul K. Faehrmann, Mark Steudtner, Richard Kueng, Maria Kieferova, and Jens Eisert. Randomizing multi-product formulas for Hamiltonian simulation. _Quantum_, 6:806, September
2022.


[54] Aram W. Harrow, Avinatan Hassidim, and Seth Lloyd. Quantum algorithm for linear systems
of equations. _Physical Review Letters_, 103(15):150502, 2009.


[55] Andrew M. Childs, Robin Kothari, and Rolando D. Somma. Quantum algorithm for systems
of linear equations with exponentially improved dependence on precision. _SIAM Journal on_
_Computing_, 46(6):1920–1950, 2017.


[56] Pedro C.S. Costa, Dong An, Yuval R. Sanders, Yuan Su, Ryan Babbush, and Dominic W.
Berry. Optimal scaling quantum linear-systems solver via discrete adiabatic theorem. _PRX_
_Quantum_, 3(4):040303, 2022.


[57] Andrew M Childs and Jin-Peng Liu. Quantum spectral methods for differential equations.
_Communications in Mathematical Physics_, 375(2):1427–1457, 2020.


[58] Hari Krovi. Improved quantum algorithms for linear and nonlinear differential equations.
_Quantum_, 7:913, 2023.


62


[59] Andris Ambainis. Variable time amplitude amplification and quantum algorithms for linear algebra problems. In Christoph D¨urr and Thomas Wilke, editors, _29th International Symposium_
_on Theoretical Aspects of Computer Science (STACS 2012)_, volume 14 of _Leibniz Interna-_
_tional Proceedings in Informatics (LIPIcs)_, pages 636–647, Dagstuhl, Germany, 2012. Schloss
Dagstuhl – Leibniz-Zentrum f¨ur Informatik.


[60] Julia Kempe, Alexei Kitaev, and Oded Regev. The complexity of the local Hamiltonian
problem. _SIAM Journal on Computing_, 35(5):1070–1097, 2006.


[61] Kianna Wan, Mario Berta, and Earl T. Campbell. Randomized quantum algorithm for statistical phase estimation. _Physical Review Letters_, 129:030503, 2022.


[62] James D. Whitfield, Jacob Biamonte, and Al´an Aspuru-Guzik. Simulation of electronic structure hamiltonians using quantum computers. _Molecular Physics_, 109(5):735–750, 2011.


[63] Mario Motta, Erika Ye, Jarrod R McClean, Zhendong Li, Austin J Minnich, Ryan Babbush,
and Garnet Kin-Lic Chan. Low rank representations for quantum simulation of electronic
structure. _npj Quantum Information_, 7(1):83, 2021.


[64] Jakob G¨unther, Freek Witteveen, Alexander Schmidhuber, Marek Miller, Matthias Christandl,
and Aram Harrow. Phase estimation with partially randomized time evolution. _arXiv preprint_
_arXiv:2503.05647_, 2025.


[65] Hiroshi Nakatsuji. Cluster expansion of the wavefunction, valence and rydberg excitations,
ionizations, and inner-valence ionizations of co2 and n2o studied by the sac and sac ci theories.
_Chemical Physics_, 75(3):425–441, 1983.


[66] Adolf Richartz, Robert J Buenker, and Sigrid D Peyerimhoff. Calculation of the vertical
electronic spectrum of propane. _Chemical Physics_, 31(2):187–196, 1978.


[67] Kenneth E Johnson, Kangjin Kim, David B Johnston, and Sanford Lipsky. Electron impact
spectra of methane, ethane, and neopentane. _The Journal of Chemical Physics_, 70(5):2189–
2197, 1979.


[68] Qiming Sun. Libcint: An efficient general integral library for g aussian basis functions. _Journal_
_of computational chemistry_, 36(22):1664–1671, 2015.


[69] Qiming Sun, Timothy C Berkelbach, Nick S Blunt, George H Booth, Sheng Guo, Zhendong Li,
Junzi Liu, James D McClain, Elvira R Sayfutyarova, Sandeep Sharma, et al. Pyscf: the pythonbased simulations of chemistry framework. _Wiley Interdisciplinary Reviews: Computational_
_Molecular Science_, 8(1):e1340, 2018.


[70] Qiming Sun, Xing Zhang, Samragni Banerjee, Peng Bao, Marc Barbry, Nick S Blunt, Nikolay A
Bogdanov, George H Booth, Jia Chen, Zhi-Hao Cui, et al. Recent developments in the pyscf
program package. _The Journal of chemical physics_, 153(2), 2020.


[71] Dave Wecker, Bela Bauer, Bryan K. Clark, Matthew B. Hastings, and Matthias Troyer. Gatecount estimates for performing quantum chemistry on small quantum computers. _Phys. Rev._
_A_, 90:022305, Aug 2014.


[72] Markus Reiher, Nathan Wiebe, Krysta M. Svore, Dave Wecker, and Matthias Troyer. Elucidating reaction mechanisms on quantum computers. _Proceedings of the National Academy of_
_Sciences_, 114(29):7555–7560, 2017.


63


[73] Ryan Babbush, Jarrod McClean, Dave Wecker, Al´an Aspuru-Guzik, and Nathan Wiebe.
Chemical basis of trotter-suzuki errors in quantum chemistry simulation. _Phys. Rev. A_,
91:022311, Feb 2015.


[74] Philipp Hauke and Luca Tagliacozzo. Spread of correlations in long-range interacting quantum
systems. _Physical Review Letters_, 111:207202, Nov 2013.


[75] Rainer Blatt and Christian F. Roos. Quantum simulations with trapped ions. _Nature Physics_,
8(4):277–284, 2012.


[76] Christopher Monroe, Wesley C. Campbell, Luming Duan, Zhe-Xuan Gong, Alexey V. Gorshkov, Paul W. Hess, Rajibul Islam, Kihwan Kim, Norbert M. Linke, Guido Pagano, Philip
Richerme, Crystal Senko, and Norman Y. Yao. Programmable quantum simulations of spin
systems with trapped ions. _Rev. Mod. Phys._, 93:025001, Apr 2021.


[77] Johannes Zeiher, Rick Van Bijnen, Peter Schauß, Sebastian Hild, Jae-yoon Choi, Thomas Pohl,
Immanuel Bloch, and Christian Gross. Many-body interferometry of a Rydberg-dressed spin
lattice. _Nature Physics_, 12(12):1095–1099, 2016.


[78] Antoine Browaeys and Thierry Lahaye. Many-body physics with individually controlled Rydberg atoms. _Nature Physics_, 16(2):132–142, 2020.


[79] Jiehang Zhang, Guido Pagano, Paul W. Hess, Antonis Kyprianidis, Patrick Becker, Harvey
Kaplan, Alexey V. Gorshkov, Z.-X. Gong, and Christopher Monroe. Observation of a manybody dynamical phase transition with a 53-qubit quantum simulator. _Nature_, 551(7682):601–
604, 2017.


[80] Bo Yan, Steven A. Moses, Bryce Gadway, Jacob P Covey, Kaden R.A. Hazzard, Ana Maria
Rey, Deborah S. Jin, and Jun Ye. Observation of dipolar spin-exchange interactions with
lattice-confined polar molecules. _Nature_, 501(7468):521–525, 2013.


[81] Aur´elie de Paz, Arijit Sharma, Amodsen Chotia, Etienne Mar´echal, John H. Huckans, Paolo [´]
Pedri, Luis Santos, Olivier Gorceix, Laurent Vernac, and Bruno Laburthe-Tolra. Nonequilibrium quantum magnetism in a dipolar lattice gas. _Physical Review Letters_, 111:185305, Oct
2013.


[82] Minh C. Tran, Andrew Y. Guo, Yuan Su, James R. Garrison, Zachary Eldredge, Michael FossFeig, Andrew M. Childs, and Alexey V. Gorshkov. Locality and digital quantum simulation
of power-law interactions. _Phys. Rev. X_, 9:031006, Jul 2019.


[83] Jeongwan Haah, Matthew B. Hastings, Robin Kothari, and Guang Hao Low. Quantum algorithm for simulating real time evolution of lattice Hamiltonians. _SIAM Journal on Computing_,
52(6):FOCS18–250–FOCS18–284, 2023.


[84] Steven R. White. Density matrix formulation for quantum renormalization groups. _Physical_
_Review Letters_, 69(19):2863, 1992.


[85] Ulrich Schollw¨ock. The density-matrix renormalization group. _Reviews of Modern Physics_,
77(1):259–315, 2005.


[86] Frank Verstraete, Valentin Murg, and J. Ignacio Cirac. Matrix product states, projected entangled pair states, and variational renormalization group methods for quantum spin systems.
_Advances in Physics_, 57(2):143–224, 2008.


64


[87] William Huggins, Piyush Patil, Bradley Mitchell, K Birgitta Whaley, and E. Miles Stoudenmire. Towards quantum machine learning with tensor networks. _Quantum Science and Tech-_
_nology_, 4(2):024001, 2019.


[88] James Dborin, Fergus Barratt, Vinul Wimalaweera, Lewis Wright, and Andrew G. Green.
Matrix product state pre-training for quantum machine learning. _Quantum Science and Tech-_
_nology_, 7(3):035014, 2022.


[89] Manuel S. Rudolph, Jacob Miller, Danial Motlagh, Jing Chen, Atithi Acharya, and Alejandro
Perdomo-Ortiz. Synergistic pretraining of parametrized quantum circuits via tensor networks.
_Nature Communications_, 14(1):8367, 2023.


[90] Michael Kastner. Diverging equilibration times in long-range quantum spin models. _Physical_
_Review Letters_, 106:130601, Mar 2011.


[91] Dmitry Grinko, Julien Gacon, Christa Zoufal, and Stefan Woerner. Iterative quantum amplitude estimation. _npj Quantum Information_, 7(1):52, 2021.


[92] Patrick Rall and Bryce Fuller. Amplitude Estimation from Quantum Signal Processing. _Quan-_
_tum_, 7:937, March 2023.


[93] Andrew M Childs, Aaron Ostrander, and Yuan Su. Faster quantum simulation by randomization. _Quantum_, 3:182, 2019.


65


