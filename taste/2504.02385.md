## Quantum singular value transformation without block encodings: Near-optimal complexity with minimal ancilla

Shantanav Chakraborty [∗][1], Soumyabrata Hazra [†][1], Tongyang Li [‡][2,3], Changpeng Shao [§][4],
Xinzhao Wang [¶][2,3], and Yuxin Zhang [‖][4]


1CQST and CSTAR, International Institute of Information Technology Hyderabad, Telangana, India
2Center on Frontiers of Computing Studies, Peking University, Beijing, China
3School of Computer Science, Peking University, Beijing, China
4SKLMS, Academy of Mathematics and Systems Science, Chinese Academy of Sciences, Beijing, China


September 4, 2025


Abstract


We develop new algorithms for Quantum Singular Value Transformation (QSVT), a unifying framework that encapsulates most known quantum algorithms and serves as the foundation
for new ones. Existing implementations of QSVT rely on block encoding, incurring an intrinsic O(log L) ancilla overhead and circuit depth O [�] (Ldλ) for polynomial transformations of a
Hamiltonian H = [�][L] k=1 [H][k][, where][ d][ is the polynomial degree and][ λ][ =][ �] k
We introduce a simple yet powerful approach that utilizes only basic Hamiltonian simulation [∥][H][k][∥][.]
techniques, namely, Trotter methods, to: (i) eliminate the need for block encoding, (ii) reduce
the ancilla overhead to only a single qubit, and (iii) still maintain near-optimal complexity.
Our method achieves a circuit depth of O [�] (L(dλcomm) [1+][o][(1)] ), without requiring any complicated
multi-qubit controlled gates. Moreover, λcomm depends on the nested commutators of the terms
of H and can be substantially smaller than λ for many physically relevant Hamiltonians, a feature
absent in standard QSVT. To achieve these results, we make use of Richardson extrapolation in a
novel way, systematically eliminating errors in any interleaved sequence of arbitrary unitaries and
Hamiltonian evolution operators, thereby establishing a general framework that encompasses
QSVT but is more broadly applicable.
As applications, we develop end-to-end quantum algorithms for solving linear systems and
estimating ground state properties of Hamiltonians, both achieving near-optimal complexity
without relying on oracular access. Overall, our results establish a new framework for quantum
algorithms, significantly reducing hardware overhead while maintaining near-optimal performance, with implications for both near-term and fault-tolerant quantum computing.


∗shchakra@iiit.ac.in
†soumyabrata.hazra@research.iiit.ac.in
‡tongyangli@pku.edu.cn
§changpeng.shao@amss.ac.cn
¶wangxz@stu.pku.edu.cn
‖zhangyuxin@amss.ac.cn


### Contents

1 Introduction 3
1.1 Brief overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.2 Main results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.2.1 Interleaved sequences of unitaries and Hamiltonian evolution . . . . . . . . . 4
1.2.2 QSVT using higher-order Trotterization . . . . . . . . . . . . . . . . . . . . . 6
1.2.3 Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.3 Comparison with prior work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15


2 Preliminaries 15
2.1 Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
2.2 Brief overview of quantum singular value transformation . . . . . . . . . . . . . . . . 16
2.3 Generalized quantum signal processing . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.4 Hamiltonian simulation by Trotter methods . . . . . . . . . . . . . . . . . . . . . . . 19
2.5 Richardson extrapolation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21


3 Interleaved sequence of unitaries and Hamiltonian evolution operators 22


4 QSVT using higher order Trotterization 33


5 Applications 38
5.1 Quantum linear systems via discrete adiabatic theorem without block encodings . . 38
5.1.1 A brief overview of the discrete adiabatic theorem . . . . . . . . . . . . . . . 39
5.1.2 The adiabatic Hamiltonian for quantum linear systems . . . . . . . . . . . . . 41
5.1.3 Our algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
5.2 Ground state property estimation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
5.2.1 Prior work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
5.2.2 Our algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47


6 Discussion and open problems 50


A Lower bound on the number of ancilla qubits required for block encoding 51


B Distance between two quantum states 54


C Functions approximated by Laurent polynomials 55


2


### 1 Introduction

1.1 Brief overview


Quantum singular value transformation (QSVT) [1, 2] has emerged as one of the most powerful
paradigms in quantum computing. The strength of QSVT lies in its ability to directly implement
polynomial transformations on the singular values of an operator A, provided A is embedded in
the top-left block of a unitary UA, known as the block encoding of A [3, 4]. By making queries to
the block encoding, QSVT realizes an arbitrary polynomial transformation with query complexity
scaling linearly in the polynomial degree, all while using only a single ancilla qubit. This versatility
makes QSVT a powerful tool for designing quantum algorithms, allowing a wide range of problems
to be formulated as polynomial transformations of block-encoded operators.
However, the reliance on block encoding is a fundamental obstacle to the practical and theoretical efficiency of QSVT-based algorithms. Constructing a block encoding for a general (Hermitian)
operator — particularly one expressed as a linear combination of local terms — incurs significant
overhead. This typically incurs circuit depth O(L) for an operator composed of L terms, along
with O(log L) additional ancilla qubits and sophisticated controlled operations. Given the limitations of current quantum devices and the importance of QSVT, reducing ancilla usage while
preserving shallow circuit depth is crucial to making QSVT-based methods feasible in near- and
intermediate-term quantum devices.
In this work, we overcome this fundamental drawback by developing new quantum algorithms
that implement QSVT without block encodings, using only the simplest Hamiltonian simulation
techniques, based on product formulas, also known as Trotterization [5,6]. More precisely, consider
any Hermitian operator H expressed as H = [�][L] k=1 [H][k][,][ where][ H][k][ can be local operators (acting]
non-trivially on a small subset of qubits). Almost all physical systems in nature are described
by Hamiltonians of this form, such as the transverse field Ising model, the quantum Heisenberg
model, and the Hubbard model. Such Hamiltonians are also widely studied in problems related to
quantum computing, including Hamiltonian learning [7, 8] and thermal state preparation [9]. Our
algorithm implements a polynomial of degree d to any such H, using only a single ancilla qubit and
QSVT in terms ofa circuit of depth O d [�] (, whereL(dλcomm λ =) [1+][�][o][(1)] k ), [1] which nearly matches the O [�] (Ldλ) complexity of standard
norm of the sum of nested commutators of [∥][H][k][∥] H [. Moreover, the prefactor] k, can be significantly smaller than [ λ][comm][, which scales with the] λ for a wide range
of physical systems, leading to a better dependence than standard QSVT. Thus, our method offers
a practical and resource-efficient alternative for applying polynomial transformations in quantum
algorithms, while retaining near-optimal asymptotic complexity.
To achieve our goals, we consider a highly general quantum circuit architecture: any circuit
composed of an interleaved sequence of arbitrary unitaries and Hamiltonian evolution operators.
This encompasses generalized quantum signal processing (GQSP) [10] as well as QSVT, where
the unitaries are single-qubit rotations, but extends well beyond them. Our central insight is
that quantum algorithms based on such circuits can achieve near-optimal complexity even when
Hamiltonian evolution operators are implemented via basic higher-order Trotter-Suzuki formulas,
arguably the simplest Hamiltonian simulation technique. This is surprising, as Trotterization is
typically considered suboptimal due to its poor scaling with inverse precision, which can increase
the circuit depth required to achieve high accuracy.
The key technical contribution enabling this result is a novel analytic framework, in which we
prove that the expectation value of any observable, evaluated on the final quantum state prepared
by such a circuit, can be expressed as a power series in the Trotter step sizes. This structure enables


1Throughout this article, we use �O(·) to hide polylogarithmic factors.


3


the use of classical extrapolation [11] to systematically eliminate Trotter errors and extrapolate to
the zero-step-size limit, thereby recovering near-optimal asymptotic circuit depth. Importantly, our
method is compatible with two optimal strategies for estimating the desired expectation value: (i)
incoherent estimation: measure the observable in each run using a total of 1/ε [2] independent classical
repetitions of the circuit; and (ii) coherent estimation: apply the iterative amplitude estimation
technique of [12] to achieve a 1/ε dependence in the overall circuit depth. [2]

As concrete applications of our framework, we design end-to-end quantum algorithms for two
fundamental tasks: (i) solving quantum linear systems and (ii) estimating properties of ground
states of Hamiltonians. To the best of our knowledge, these are the first algorithms for either
problem that simultaneously achieve:


1. No oracular assumptions on access to the Hamiltonian H.


2. Constant ancilla overhead, and


3. Near-optimal end-to-end complexity, in terms of both circuit depth and total gate count.


Moreover, both algorithms are simply based on Hamiltonian simulation via Trotterization, along
with classical extrapolation. Despite its simplicity, the quantum linear systems algorithm achieves
near-linear scaling on the condition number of the underlying operator and polylogarithmic dependence on the inverse precision, nearly matching the complexity of state-of-the-art algorithms –
without relying on Szegedy-type quantum walks [13] or complicated subroutines such as variabletime amplitude amplification [14,15]. The ground state property estimation algorithm also achieves
Heisenberg-limited scaling, which is optimal.
Overall, our methods provide a unified framework for developing resource-efficient, end-to-end
quantum algorithms with near-optimal complexity for a wide range of problems.


1.2 Main results


In this section, we summarize the main contributions of this work and provide pointers to the
corresponding sections of the manuscript where formal statements and detailed derivations can be
found.


1.2.1 Interleaved sequences of unitaries and Hamiltonian evolution


We begin by introducing a novel framework for developing quantum algorithms that encompasses
QSVT and also extends to a broader class of problems. This framework enables efficient estimation
of expectation values of the form ψ0 W [†] OW ψ0, for any initial state ψ0, where W is a structured
⟨ | | ⟩ | ⟩
quantum circuit built from an interleaved sequence of arbitrary unitary operations and Hamiltonian
evolutions. Our main result establishes a near-optimal complexity for implementing such circuits
with only higher-order Trotterization, eliminating the need for block encoding, while using no
ancilla qubits. As mentioned previously, the expectation value can be estimated, either by directly
measuring O (incoherent estimation) or by using iterative quantum amplitude estimation (coherent
estimation). We now formally state the problem addressed in this work:

Problem 1.1. Let H [(1)], H [(2)], . . ., H [(][M] [)] be Hermitian operators of the same dimension, where



H [(][j][)] =



�Γj

Hγ [(][j][)][,] (1.1)
γ=1



2We use the terms “incoherent” and “coherent” estimation throughout the article to distinguish between these
two methods of expectation value estimation.


4


is a decomposition of H [(][j][)] into terms Hγ [(][j][)][, such that each][ e][i][H] γ [(][j][)] can be efficiently implemented (in
constant time). Then define the interleaved quantum circuit W as follows:



W := V0 · e [i][H] [(1)] - V1 · e [i][H] [(2)] - · · e [i][H] [(][M] [)] - VM = V0



�M

e [i][H] [(][j][)] Vj, (1.2)
j=1



where {Vj}j [M] =0 [are arbitrary unitaries. Then, for any observable][ O][, and initial state][ |][ψ][0][⟩][, estimate]
the expectation value ψ0 W [†] OW ψ0 to within an additive precision of ε O .
⟨ | | ⟩ ∥ ∥

We can directly replace each e [i][H] [(][j][)] by a p-th order staged product formula [6] (See Sec. 2.4).
However, this results in a circuit with depth scaling as 1/ε [1][/p], which is sub-optimal. We prove
that for any quantum circuit W, the precision dependence can be improved to polylog(1/ε) with
the help of classical extrapolation techniques. In fact, our core technical contribution is to prove
that the error between the true expectation value ψ0 W [†] OW ψ0 and our approximation, which
⟨ | | ⟩
is obtained by replacing each e [i][H] [(][j][)] with a p-th order Trotterization, can be expressed succinctly
as a power series in the Trotter step sizes. This allows us to extrapolate to the zero-error limit via
Richardson extrapolation [11] and subsequently obtain an exponentially better scaling.
Our result can be seen as a non-trivial generalization of recently used methods that make use
of extrapolation to mitigate errors in particular Hamiltonian simulation algorithms [11, 16, 17].
Crucially, a direct multiplicative combination of the expansions of error series from prior work [16]
does not yield a controllable bound in our (more general) framework. Instead, we reinterpret the
entire interleaved sequence circuit as being governed by a time-dependent (Floquet-like) effective
Hamiltonian. This allows us to control the time-dependent error between the true expectation
value and our approximation.
Thus, the overall algorithm uses high-order Trotter methods to implement the Hamiltonian
evolution with decreasing Trotter step sizes, estimates the observable at each step size, and extrapolates the measurement results to the zero-step-size limit, corresponding to the true value. The
main results are proven in Theorem 3.4 and Theorem 3.6. Here, we state the complexity of our
algorithm via the following theorem:

Theorem 1.2 (Informal version of Thms. 3.4 and 3.6). Consider Hamiltonians {H [(][j][)] : j ∈ [M ]}
that can be written as in Eq. (1.1). Define Γavg := [�][M] j=1 [Γ][j][/M] [, and suppose][ {][V][j][}] j [M] =0 [are unitaries]
with circuit depth τj in the circuit W defined in Eq. (1.2). Furthermore, let p ∈ N, τsum = [�][M] j=0 [τ][j][,]
and ε ∈ (0, 1) be the precision parameter. Then there exists a quantum algorithm that, for any
observable O and efficiently preparable initial state ψ0, computes ψ0 W [†] OW ψ0 ε O .
| ⟩ ⟨ | | ⟩± ∥ ∥
If O is measured incoherently, the maximum quantum circuit depth is

��               - �1+1/p               O Γavg Mλcomm + τsum,


while the time complexity is [3]

��                
             O Γavg(Mλcomm) [1+1][/p] + τsum /ε [2][�] .


On the other hand, if the expectation value is coherently estimated, the time complexity and the
maximum quantum circuit depth are

���              - �1+1/p              -              O Γavg Mλcomm + τsum /ε .


3Throughout this article, the time complexity of an algorithm refers to the number of elementary (single and
two-qubit) gates required to implement it.


5


Here λcomm, which is formally defined in Eq. (3.12), scales with the nested commutators of
terms H [(][j][)], and can be upper bounded as (see Remark 3.2)



λcomm 4 max
≤ j∈[M ]



�Γj

Hγ [(][j][)] (1.3)
γ=1 ∥ [∥][.]



As in standard Hamiltonian simulation via Trotterization, the dependence of the complexity on
the Trotter order p scales as O(p · 5 [p] ). Hence, for sufficiently large choices of p (e.g. p ∼
log log(Mλcomm)), this dependence can be absorbed into the O [�] ( ) notation. Moreover, the de
                                                     pendence of the complexity on M is nearly linear M [1+][o][(1)] .
Observe that there is a trade-off between the maximum circuit depth per coherent run and
the total complexity. If O is directly measured (incoherent estimation), we need independent
classical runs of a shorter-depth circuit, which may be preferable in the intermediate term. The
total time complexity, however, scales as 1/ε [2] . On the other hand, iterative quantum amplitude
estimation [12] can also be applied to estimate the expectation value (coherent estimation). This
quadratically reduces the dependence on precision, at the cost of increasing the circuit depth.
However, if O is, in general, non-unitary, quantum amplitude estimation would need access to a
block encoding of O, which might involve additional ancilla qubits. Unless otherwise specified, for
the results we state here, coherent estimation is always possible, leading to linear scaling in inverse
precision.
To see why circuit W is extremely general, observe that there are no restrictions on the unitaries
V0, . . ., VM — each could represent an entirely different quantum algorithm. As such, any quantum
procedure that invokes Hamiltonian evolution as a subroutine, even with different Hamiltonians at
each step, can be cast as a special case of our interleaved circuit architecture. Our findings thus
significantly expand the scope of classical extrapolation techniques and their potential to reduce
circuit depth in generic quantum algorithms.
Indeed, we shall soon show that GQSP [10] is a particular instance of the circuit in Eq. (1.2),
with each Vj being a single-qubit phase rotation, and each H [(][j][)] = H. Incorporating time-evolution
operators of different Hamiltonians {H [(][j][)] } enables us to construct a framework that goes beyond
QSP or even QSVT. This becomes crucial for significantly simplifying recently developed optimal
quantum linear systems algorithms inspired by adiabatic quantum computing [13,18]. Unlike in [13],
where a block encoding of the underlying matrix is used to implement Szegedy’s quantum walk, we
obtain a near-linear dependence on the condition number by directly simulating the Hamiltonians
along the discretized adiabatic path via a high-order Trotter method. This is followed by a projection step implemented using QSVT. The entire procedure fits naturally within our interleaved
circuit framework, making it a specific instance of W . Besides the applications considered here,
simulation of time-dependent Hamiltonians [19, 20], the recently introduced framework of linear
combination of Hamiltonian simulation [21–23], and variational algorithms [24] can also be seen as
particular instances of W : it is possible to use our framework to develop simple resource-efficient
quantum algorithms with near-optimal complexity, using only basic Trotterization, no oracular
assumptions, and minimal ancilla overhead.


1.2.2 QSVT using higher-order Trotterization


We begin by stating the problem we intend to solve.


6


Problem 1.3. Consider a Hermitian operator H that is a sum of local operators, expressed as



�L

Hj . (1.4)
∥ ∥
j=1



H =



�L

Hj, with λ =
j=1



For any observable O and initial state ψ0, accurately estimate the expectation value
| ⟩

ψ0 f (H) [†] Of (H) ψ0 (1.5)
⟨ | | ⟩

for any function f (x) that is approximated by a bounded polynomial of degree d.



As discussed earlier, QSVT provides a unified framework for obtaining such an estimate. The
standard approach [1,2] achieves this by assuming access to the unitary (which is known as a block
encoding of H)




   H/λ
UH = ∗
∗ ∗




,



which encodes H/λ in its top-left block. From the polynomial that approximates f (x), one can find
a sequence of single-qubit phase rotations Vj = e [i][φ][j] [Z], such that an interleaved product of Vj and
UH is close to a block encoding of f (H/λ). Typically, the complexity is measured in terms of the
number of queries made to UH. However, as argued before, constructing UH is expensive, which
affects the implementability of QSVT. For instance, when Hj are weighted unitaries, the block
encoding UH can be constructed using the Linear Combination of Unitaries (LCU) technique [25].
Such a construction uses O(log L) ancilla qubits, involves complicated controlled logical operations,
and results in a quantum circuit of depth O(L). [4] Then QSVT outputs an ε∥O∥-accurate estimate of
the desired expectation value, using: (i) O(1/ε [2] ) repetitions of a quantum circuit of depth O [�] (λdL),
for incoherent estimation, and (ii) a circuit depth of O [�] (λdL/ε), if the expectation value is coherently
measured using amplitude estimation.
One might argue that frugal constructions of block encodings for such Hamiltonians H are
possible. After all, LCU is merely one method to construct UH. Unfortunately, in Appendix A,
we prove that Ω(log L) ancilla qubits are necessary to construct such a block encoding, for a quite
general class of quantum circuits, including LCU as a special case. Formally, we prove:

Theorem 1.4 (Lower bound of ancillas for LCU). Assume that H = [�][L] j=1 [λ][j][P][j][ is a linear com-]
bination of unitaries. Let


U = (V1 I)c0-P1(V2 I)c0-P2 (VL I)c0-PL(VL+1 I),
⊗ ⊗            - · · ⊗ ⊗

where V1, . . ., VL+1 act on some m ancilla qubits and c0-Pj are controlled unitaries with control
qubit 0. If U is an exact block encoding of H, that is,

                -                 -                 -                 ⟨0 [⊗][m] | ⊗ I U |0 [⊗][m] ⟩⊗ I = H,

then the number of ancilla qubits, m, satisfies m = Ω(log L).


The substantial ancilla overhead required to block encode H underscores why standard QSVT
is impractical for near-term quantum computers. So, to implement QSVT with minimal ancilla
usage, there are broadly two potential strategies. The first is to construct an approximate block
encoding of H using O(1) ancilla qubits, while ensuring that the gate complexity of such a block


4When only the Hermitian decomposition of H is given, the LCU technique cannot be used directly, and the
construction of block encodings of H is more difficult.


7


encoding scales polylogarithmically with the dimension of H and inverse precision. However, to the
best of our knowledge, no such constructions are currently known. The second approach, taken in
this work, is to bypass block encoding altogether and develop alternative methods for implementing
QSVT without relying on block encodings.
To this end, we consider a formulation of QSVT as an interleaved sequence of single-qubit
phase rotations and controlled Hamiltonian evolution operators, a recently introduced framework
known as generalized quantum signal processing (GQSP) [10,26]. Given access to the Hamiltonian
evolution operator e [i][H], this method implements polynomial transformations of e [i][H] by an interleaved sequence of general single-qubit rotations and controlled-e [i][H] operations. The advantage
of GQSP is that, unlike the standard QSVT, this does not treat real and complex polynomials
separately. Overall, if the end-to-end complexity of the method in [10] is considered, the optimal
circuit depth (matching standard QSVT) is attained by assuming a block encoding access to H,
involving O(log L) ancilla qubits. We show that this framework is also a particular instance of the
interleaved unitaries circuit of Eq. (1.2), and develop an end-to-end quantum algorithm (without
block encoding) for estimating ψ0 f (H) [†] Of (H) ψ0 while using only a single ancilla qubit.
⟨ | | ⟩
A brief review of GQSP is provided below, with additional details in Sec. 2.3. Let

                 -                 e [i(][γ][+][φ][)] cos(θ) e [i][φ] sin(θ)
R(θ, φ, γ) = I
e [i][γ] sin(θ) cos(θ) ⊗

                


correspond to a single-qubit rotation of the ancilla qubit, parametrized by (θ, φ, γ). Motlagh and
Wiebe [10] showed that there exists an interleaved sequence of R(θj, φj, 0) and c0-e [i][H] (controlled
on 0), c1-e [−][i][H] (controlled on 1) of length 2d + 1, that can implement a block encoding of degreed Laurent polynomials (polynomials with both positive and negative powers) P (e [i][H] ) such that,
|P (x)| ≤ 1 for all x ∈ T = {z ∈ C : |z| = 1}. This framework allows for implementing the block
encoding of any f (H) that can be approximated by P (e [i][H] ).
However, instead of assuming access to a block encoding of H, we can directly implement
c0-e [i][H] and c1-e [−][i][H], obtaining a circuit that is an instance of W considered in Sec. 1.2.1. Indeed,
a simple way to see this is that we can rewrite the controlled Hamiltonian evolution as e [i ˜] H with
H˜ = diag(H, 0) or diag(0, −H) depending on the control qubit being 0 or 1. That is, if H is an
n-qubit Hamiltonian, then there exist θj j=0 [,][ {][φ][j] [}][2] j=0 [d]
{ } [2][d] [∈] [R][2][d][+1][, and][ γ][ ∈] [R][ such that:]




P (eiH ) ∗
∗ ∗




- - �d
=



�d

R (θj, φj, 0) c0-e [i][H][�] R (θ0, φ0, γ),
j=1



�d �d

R (θd+j, φd+j, 0) c1-e [−][i][H][��]
j=1 j=1



where the LHS is now an (n + 1)-qubit unitary. Thus, all we need is to implement e [i ˜] H using p-th
order Trotterization and mitigate the errors using Richardson extrapolation to obtain an improved
dependence on precision. In order to obtain a specific instance of the circuit in Eq. (1.2), we simply
set each Vj = R(θj, φj, γj) ⊗ I, and H [(][j][)] = H [˜], with Γavg = L. Moreover, each Vj can now be
implemented in constant time, and M is replaced by the degree d of the polynomial.
This framework is already general enough to incorporate many problems that can be solved
by standard QSVT. In fact, we significantly expand its applicability by rigorously finding the
conditions under which any function f (x) can be approximated by Laurent polynomials in e [i][x] of
degree d. We prove that any function f (x) that can be approximated in the interval [−1, 1] by a
polynomial that remains bounded in an extended interval [−1 - δ, 1+ δ] (e.g., δ ∈ (0, 1/2]), can also
be approximated by an appropriate Laurent polynomial in e [i][x] for x ∈ [−1, 1]. Overall, we obtain
the following theorem, proven in Sec. 4:


8


Theorem 1.5 (QSVT with Trotterization, informal version of Thm. 4.1). Let ε ∈ (0, 1), p ∈ N,
B ∈ (1, π], and H be a Hermitian operator that is a sum of L local terms (or a linear combination of
strings of Pauli operators) such that ∥H∥≤ B. Suppose that f (x) can be approximated by a Laurent
polynomial in e [i][x], P (e [i][x] ), on [−B, B] satisfying |P (y)| ≤ 1 for all y ∈ T = {z ∈ C : |z| = 1}, of
degree at most d, with additive precision ε/6. Furthermore, let ψ0 be an efficiently preparable initial
| ⟩
state and O be an observable. Then there exists an algorithm that estimates ψ0 f (H) [†] Of (H) ψ0
⟨ | | ⟩
with an additive accuracy ε∥O∥ and constant success probability. The algorithm uses only a single
ancilla qubit and has an overall time complexity

               
               -               - �1+o(1) 2 [�]
O L dλcomm /ε (1.6)


with the maximum quantum circuit depth

               
                     - �1+o(1) [�]

               O L dλcomm . (1.7)


Here, λcomm scales with the nested commutators of the local terms of H and can be upper bounded
by λ, as given in Eqs. (1.3) and (1.4).

The condition ∥H∥≤ B ensures that the spectrum of H lies within a single period of P (e [i][x] ),
but this does not limit the scope of the method. For any general Hamiltonian, we can apply our
theorem to its rescaled operator H [′] = H/∥H∥, approximating the function f (x∥H∥). Although
the approximation degree d of f (x∥H∥) scales linearly with ∥H∥ in general, this is canceled by
the inverse scaling of the λcomm term for H [′] . As a result, the overall complexity, governed by
the product dλcomm, remains independent of the operator norm and instead depends only on the
commutator structure of H. This ensures that our approach remains efficient even for Hamiltonians
with ∥H∥ - π.


Algorithm Ancilla Circuit depth per coherent run Classical repetitions

                                                Standard QSVT [1] ⌈log2 L⌉ + 1      - O� (Ldλ) O� �ε [−][2][�]

QSVT with Trotterization (Thm. 1.5) 1 O� L(dλcomm) [1+][o][(1)][�] O� ε [−][2][�]


Table 1: Comparison of the complexity of standard QSVT with our algorithm for solving Problem 1.3.


Theorem 1.5 provides a general framework to implement polynomial transformations (irrespective of whether it is real or complex) of a Hermitian operator, without using block encodings,
while using only a single ancilla qubit. Table 1 compares the complexity of Theorem 1.5 with
standard QSVT with block encoding. Note that despite requiring only a single ancilla qubit and
without assuming any oracular access to H, we obtain near-optimal time complexity. If H is nonHermitian, Theorem 1.5 would use an additional ancilla qubit. In some specific cases, it is possible
to keep the total number of ancilla qubits to one, even when H is non-Hermitian. This can be
achieved by implementing complex polynomials using Hamiltonian Singular Value Transformation
(HSVT) [27, 28]. While this framework is also subsumed by the circuit in Eq. (1.2) and does not
require implementing controlled Hamiltonian simulations, finding appropriate complex polynomials
is challenging. For certain odd real polynomials, HSVT can be implemented using only one ancilla
qubit by employing symmetric phase factors [29]. However, in general, implementing HSVT with
real polynomials uses two ancilla qubits, even when H is Hermitian. [5]


5See the arXiv version of this paper [30] for a more detailed discussion.


9


Finally, in several applications, we are often interested in finding the expectation value of O with
respect to the normalized quantum state output by QSVT. We can define the problem formally as:

Problem 1.6. Consider a Hermitian operator H that is a sum of local operators, H = [�][L] j=1 [H][j]
with λ = [�][L] j=1

[∥][H][j][∥][.][ For any observable][ O][ and initial state][ |][ψ][0][⟩][, estimate the expectation value]

⟨ψ|O|ψ⟩± ε∥O∥,



where



f (H) ψ0
ψ = | ⟩ (1.8)
| ⟩ f (H) ψ0
∥ | ⟩∥ [,]



for any function f (x) that is approximated by a bounded polynomial of degree d.



In such a case, Theorem 1.5 can be easily adapted to estimate ψ O ψ . If f (H) ψ0 η,
⟨ | | ⟩ ∥ | ⟩∥≥
there are three ways in which this expectation value in Problem 1.6 can be estimated, just like in
standard QSVT, with the circuit depth and the overall time complexity also scaling similarly. We
list them here, with the detailed costs summarized in Table 2:


  - First, it is possible to directly measure O incoherently as before. Applying Hoeffding’s inequality, one can show that the expectation value with respect to the normalized state can
be estimated with O [�] (ε [−][2] η [−][2] ) classical repetitions.


  - Second, it is possible to adapt the interleaved sequence W to incorporate quantum amplitude
amplification. For an initial state ψ0, this leads to a modified interleaved sequence circuit:
| ⟩




W =



K/�2

We [i][φ][j][|][0][,ψ][0][⟩⟨][0][,ψ][0][|] W [†] e [i][θ][j] [(][|][0][⟩⟨][0][|⊗][I][)], (1.9)

j=1



where φj, θj [0, 2π] are specified by the fixed-point amplitude amplification algorithm [31]
∈
and K = O(η [−][1] log(1/ε)). The unitary e [i][φ][j][|][0][,ψ][0][⟩⟨][0][,ψ][0][|] helps implementing a reflection about
the initial state ψ0, controlled on a single ancilla qubit. The new circuit W [�] is still an instance
| ⟩
of Eq. (1.2), and we can again use Richardson extrapolation to mitigate the errors at the end.
The circuit depth of each run, as well as the total running time, now increases by a factor of
η [−][1][−][1][/p] as compared to Theorem 1.5.


  - Finally, it is also possible to estimate ⟨ψ|O|ψ⟩ using iterative quantum amplitude estimation

[12]. The time complexity scales as O [�] (L(dλcomm/η) [1+][o][(1)] /ε), but requires block encoding
access to O.


Note that for all three methods in Table 2, we provide end-to-end complexities for estimating
the required expectation value. Both the circuit depth per coherent run as well as the total time
complexity nearly match the optimal complexity of standard QSVT, despite requiring significantly
fewer resources.


1.2.3 Applications


We apply our general algorithms for implementing QSVT without block encodings, to two problems
of practical interest: (i) solving quantum linear systems, and (ii) ground state property estimation.


Quantum linear systems without block encodings: The quantum linear systems algorithm


10


Algorithm Variant Ancilla Circuit depth Classical repetitions
per coherent run

                                            Without QAA or QAE O (log L) O� (Ldλ) O� ε [−][2] η [−][2][�]



Standard QSVT [1]


This work




                                QAA O(log L) O� (Ldλ/η) O� ε [−][2][�]

QAE O (log L) O� (Ldλ/ηε) 



                -                QAA 2 O� L(dλcomm/η) [1+][o][(1)][�] O� ε [−][2][�]




                     -                     Without QAA or QAE 1 O� L(dλcomm) [1+][o][(1)][�] O� ε [−][2] η [−][2][�]




                 Iterative QAE 3 O� L(dλcomm/η) [1+][o][(1)] ε [−][1][�] 
                                           


Table 2: Comparison between standard QSVT and our method to solve Problem 1.6. The table compares
the number of ancilla qubits, the circuit depth per coherent run, and the total number of classical repetitions.
There are three ways the expectation value can be estimated, both for standard QSVT and our method. The
first approach measures O directly at the end of each run. The second technique uses quantum amplitude
amplification (QAA) to prepare the normalized state, followed by incoherent measurements. Note that
our method runs an interleaved sequence circuit W [�] which incorporates fixed point quantum amplitude
amplification (See Eq. (1.9)) but still measures O at the end of each run incoherently. The third approach
is to measure the desired expectation value using quantum amplitude estimation (QAE). In our method, we
use the iterative quantum amplitude estimation scheme of [12].


has been quite fundamental for developing quantum algorithms for regression [4,32], machine learning, and solving differential equations [33–35]. Suppose A ∈ C [N] [×][N] is a matrix with ∥A∥ = 1, with
singular values in the interval [−1, −1/κ] ∪ [1/κ, 1], where ∥A [−][1] ∥ = κ is the condition number.
Given a procedure to efficiently prepare the quantum state |b⟩, the goal is to estimate the expectation value ⟨x|O|x⟩ with ε-additive accuracy, where |x⟩ = A [−][1] |b⟩/∥A [−][1] |b⟩∥. The complexity
of this algorithm has been improved over the years, with broadly two approaches (both of which
assume access to a block encoding UA of matrix A): The first one makes use of quantum linear
algebra techniques such as Linear Combination of Unitaries [4, 15], QSVT [1, 32, 36], along with
a complicated technique known as variable-time amplitude amplification (VTAA) [14] to obtain a
complexity that depends linearly on κ and logarithmically in κ/ε.
Recently, an approach that is quite distinct from these has gained prominence, as it avoids using
VTAA. These methods [18, 37, 38] are inspired by adiabatic quantum computation: they consider
a time-dependent Hamiltonian H(s) (which is related to A), with s ∈ [0, 1]. The algorithm starts
from an easy-to-prepare 0-eigenstate of H(0) and evolves adiabatically to the 0-eigenstate of H(1),
which encodes |x⟩. The algorithm of Costa et al. [13] achieves an optimal query complexity of
O(κ log(1/ε)), in terms of the number of queries to the block encoding of A. The underlying idea
is to construct a quantum walk operator Q(s) (from a block encoding of A) for different values of
s ∈{k/T } [T] k=0 [−][1][, to discretize the adiabatic computation. They show that the discretized adiabatic]
evolution by Q(s) approximates the ideal adiabatic evolution under H(s) (up to a constant) for
T = O(κ), and the resulting state at this point has a constant overlap with |x⟩. The optimal
dependence on precision is attained by employing the eigenstate filtering technique of [38].
Despite achieving optimal query complexity, block encoding of A can be expensive in practice.
Suppose A is expressed as a linear combination of L Pauli operators of n-qubits, i.e. H = [�] j [λ][j][P][j][,]
where Pj I, X, Y, Z, and λ = [�] j
∈{ } [⊗][n] [|][λ][j][|][. The circuit depth of the state-of-the-art algorithm [][13][],]

to estimate ⟨x|O|x⟩ to ε∥O∥-additive accuracy is O [�] (Lλκ), while making O [�] (1/ε [2] ) classical repetitions. Moreover, the method uses ⌈log2 L⌉ + 6 ancilla qubits in all. On the other hand, quantum


11


Algorithm Ancilla Circuit depth per coherent run Classical repetitions

                                          
                       -                        State-of-the-art [13] ⌈log2 L⌉ + 6 O (Lλκ) O ε [−][2][�]

                                          
                       -                        Near-term methods [39, 40] 1 O(λ [2] κ [2] ) O κ [4] ε [−][2][�]

                           -                            
                      -                      This work (Thm. 1.7) 4 O L(λκ) [1+][o][(1)][�] O ε [−][2][�]


Table 3: Comparison of the complexity of quantum linear systems algorithms. Our complexity is nearoptimal while requiring fewer ancilla qubits.


algorithms tailored to early fault-tolerant quantum computers have recently been developed [39,40].
These randomized algorithms are hardware friendly (requiring only a single ancilla qubit), but are
sub-optimal with a total time complexity scaling as O [�] (λ [2] κ [6] /ε [2] ).
We present a fully end-to-end algorithm that entirely eliminates the need for (i) block encoding
of the Hamiltonian, and (ii) the construction of quantum walk unitaries from the interpolating
Hamiltonian H(s). At the same time, (iii) our approach achieves near-optimal complexity while
significantly reducing the number of ancilla qubits required (to a constant). The adiabatic Hamiltonian H(s), constructed from A and Ub (the unitary preparing the state |b⟩), is an n + 2 qubit
operator and also admits a natural decomposition as a linear combination of Pauli operators and
low rank projectors. Subsequently, we proceed by simulating the time-dependent Hamiltonian H(s)
at discrete values of s, i.e.,



B(s) =



sT�−1

e [i][H][(][m/T] [)] .

m=0



This naturally fits into the interleaved circuit structure of Eq. (1.2), where each H [(][j][)] = H(j/T ),
and Vj = I. We can simulate each time-evolution operator using higher-order Trotterization. This
works fine because the eigenvalue gap of the quantum walk unitary is asymptotically the same as
the eigenvalue gap of e [i][H][(][s][)] .
The operator B(s) is then combined with a second interleaved circuit, that implements a trigonometric polynomial (Laurent polynomial in e [i][x] ) carefully chosen to approximate the filtering function introduced in [38]. This filtering procedure effectively projects the evolved state onto the
zero-eigenstate of H(1), and can again be implemented using Theorem 1.5. Altogether the entire algorithm becomes a particular instance of the interleaved unitary sequence W, followed by
the extrapolation of the measurement results to the zero-error limit. This gives us the following
theorem:


Theorem 1.7 (Quantum linear systems without block encodings, informal version of Thm. 5.2).
Suppose A = [�][L] j=1 [λ][j][P][j][ is a matrix with][ ∥][A][∥] [= 1][, with singular values in][ [][−][1][,][ −][1][/κ][]][ ∪] [[1][/κ,][ 1]][ and]
∥A [−][1] ∥ = κ. Let ε ∈ (0, 1) be the precision parameter. Then, there exists an algorithm that, for
any observable O, estimates ⟨x|O|x⟩ to within an additive error of at most ε∥O∥, with a constant
success probability, using only four ancilla qubits. Moreover, the algorithm has total time complexity
of O [�] (L(λκ) [1+][o][(1)] /ε [2] ), and a maximum circuit depth O [�] (L(λκ) [1+][o][(1)] ).

The maximum circuit depth is O [�] (L(λκ) [1+][o][(1)] ), which is nearly optimal: (i) the dependence on
the condition number κ is quasi-linear, and (ii) we also have a polylogarithmic dependence on inverse precision using only a few ancilla qubits, and just higher order Trotterization. As before, the
desired expectation value can also be estimated using iterative quantum amplitude estimation with
a quadratically reduced dependence on precision, resulting in a time complexity O [�] (L(λκ) [1+][o][(1)] /ε).


12


Table 3 compares our methods with [13, 39, 40] in detail. More analysis is given in Sec. 5.



Ground state property estimation: Consider a Hamiltonian H which is a sum of L local
terms, with unknown ground state v0 . The goal is to estimate the expectation value v0 O v0,
| ⟩ ⟨ | | ⟩
with arbitrary additive accuracy, provided we have (i) prior knowledge of the spectral gap ∆of H,
and (ii) access to an initial (guess) state φ0 with an overlap of at least γ with the ground state.
| ⟩
A particular instance of this problem is the estimation of the ground state energy ξ0 of H. Both of
these problems are highly relevant and have applications in many areas of physics. Almost all prior
work on developing quantum algorithms for these problems (both for near-term quantum devices
and fully fault-tolerant quantum computers), assume some form of oracular access to H [27,41–43].
The state-of-the-art quantum algorithm by Lin and Tong [41], solves this problem while assuming access to a block encoding of H. The overall time complexity (using quantum amplitude
estimation) is




 Lλ

O



∆γε




.



However, the algorithm requires O(log L) ancilla qubits and sophisticated multi-qubit controlled
gates, making it impractical to implement on near-term or early fault-tolerant quantum devices
due to its significant resource overhead.
As a result, several quantum algorithms have been proposed that are specifically designed for
early fault-tolerant quantum devices. Notably, recent randomized techniques [39, 40] assume that
the Hamiltonian H is expressed as a linear combination of strings of Pauli operators, defined as
H = [�] j [λ][j][P][j][, where now][ λ][ =][ �] j
them hardware-friendly, but suffer from sub-optimal complexity scaling: [|][λ][j][|][. These approaches require only a single ancilla qubit, making]




 λ [2]

O



∆ [2] γ [4] ε [2]




.



In fact, any method that relies on sampling the Pauli terms Pj, according to their weight λj/λ, is
fundamentally limited to worse scaling [30].
Another line of recent work [27, 42, 43] has developed near-term quantum algorithms assuming
oracular access to the Hamiltonian evolution operator e [i][H] . For instance, [27] applies Hamiltonian
Singular Value Transformation (HSVT) to achieve near-optimal query complexity using only a
single ancilla qubit. Their circuit consists of an interleaved sequence of single-qubit rotations and
Hamiltonian evolutions—precisely a special case of our general circuit structure W . However, in
practice, implementing e [i][H] via higher-order Trotterization incurs a cost scaling as 1/ε [1+][o][(1)], which
degrades the ideal Heisenberg scaling guaranteed under exact oracular access.
Building on this framework, we remove the oracle assumption and instead construct e [i][H] explicitly using higher-order Trotterization. Moreover, we apply Richardson extrapolation to effectively
reduce the Trotter error. Thus, our general setting allows us to develop end-to-end quantum algorithms for this problem without assuming any oracular access and using only O(1) ancilla qubits.
We show that the shifted sign function can be well-approximated by a Laurent polynomial in e [i][x], as
presented in Lemma C.2, which allows us to use Theorem 1.5 to estimate v0 O v0 to the desired
⟨ | | ⟩
precision.
Our algorithm achieves an exponential reduction in circuit depth compared to the incoherent
ground state estimation approach of [27]. Furthermore, by leveraging iterative quantum amplitude
estimation, we preserve Heisenberg scaling in precision, yielding a polynomial speedup over even
the coherent variant of their algorithm. Remarkably, both our total runtime and maximum circuit
depth closely approach the optimal complexity established by Lin and Tong [41]. We summarize
the result as follows, with the detailed proofs in Sec. 5.2:


13


Theorem 1.8 (Ground state property estimation, informal version of Thm. 5.4). Given a Hamiltonian H = [�][L] j=1 [H][j][, whose spectrum is contained in][ [][−][1][,][ 1]][. Suppose there exists a procedure]
to efficiently prepare the state φ0 such that φ0 v0 γ for γ (0, 1), and there is a spec| ⟩ |⟨ | ⟩| ≥ ∈
tral gap ∆ separating the ground state energy from the rest of the spectrum. Let ε ∈ (0, 1) be
the precision parameter. Then there exists a quantum algorithm that estimates v0 O v0 within
⟨ | | ⟩
an additive accuracy of ε∥O∥, using only two ancilla qubits and with constant success probability.
The algorithm has a maximum circuit depth of O [�] (L(λcomm/∆γ) [1+][o][(1)] ) and total time complexity of

O(ε [−][2] L(λcomm/∆γ) [1+][o][(1)] ). If we have coherent access to the observable O, then we can reduce the
time complexity to O [�] (ε [−][1] L(λcomm/∆γ) [1+][o][(1)] ) using one additional ancilla qubit.


Yet another advantage of using higher-order Trotterization is that for many physical Hamiltonians, λcomm λ, which offers room for even more practical advantages. This includes broad classes
≪
of Hamiltonians, such as k-local Hamiltonians and the Heisenberg model, Hamiltonians with power
law interactions, electronic structure Hamiltonians, and cluster Hamiltonians [6, 44]. Despite removing the oracular assumption, the resulting quantum algorithms achieve asymptotic complexity
comparable to the best-known results.


Algorithm Variant Ancilla Circuit depth per coherent run Classical repetitions



Lin and Tong [41] QAE ⌈log2 L⌉ + 4 O�(Lλ∆ [−][1] γ [−][1] ε [−][1] ) 



                           -                           Dong et al. [27] 2 O� L λ [′] comm [∆][−][1][γ][−][1][�][1+][o][(1)][ε][−][o][(1)][�] O�(ε [−][2] )
QAA        - [�]



QAA         
This work (Thm. 1.8) 2 O�(L λcomm∆ [−][1] γ [−][1][�][1+][o][(1)] ) O�(ε [−][2] )




                          -                           Dong et al. [27] 3 O� L λ [′] comm [∆][−][1][γ][−][1][�][1+][o][(1)][ε][−][1][−][o][(1)][�]
Iterative QAE          - [�]          


Iterative QAE            
This work (Thm. 1.8) 3 O�(L λcomm∆ [−][1] γ [−][1][�][1+][o][(1)] ε [−][1] )

                             


Table 4: Comparison of different algorithms for ground state property estimation.


Finally, in Table 4 we compare our results with previous state-of-the-art results:


- The state-of-the-art algorithm of Lin and Tong [41] obtains optimal complexity at the cost
of using several ancilla qubits, and sophisticated multi-qubit controlled operators needed to
construct the block encoding of H. In comparison, our method (using iterative QAE) attain
Heisenberg scaling of 1/ε, and nearly matches the state-of-the-art time complexity.


- In order to estimate the desired expectation value, one possibility is to measure O directly,
after each run of the algorithm. As compared to this variant of the Dong et al. [27] algorithm,
the circuit depth of our algorithm is also reduced by a factor of ε [−][o][(1)], yielding an exponential
speedup. The incoherent algorithms achieve shorter quantum circuits and one fewer ancilla
qubit. Although the overall cost of these algorithms is higher, they are more suitable for
intermediate quantum devices.


- We can estimate the expectation value using iterative quantum amplitude estimation. As
compared to Dong et al. [27], the use of extrapolation, results in a shorter circuit depth (by
a factor of ε [−][o][(1)] ), yielding a polynomial speedup.


- Another advantage of our method over [41] is that λcomm λ. Note that this prefactor
≪
for [27], λ [′] comm [, is different from][ λ][comm] [but scales similarly. See Sec.][ 5.2.2][ for details.]


14


1.3 Comparison with prior work


Since QSVT unifies a wide range of quantum techniques [2], it has been central to the development
of many fundamental algorithms, including Hamiltonian simulation [3, 45], quantum linear system
solvers [1,32,38], ground state preparation [41], quantum semidefinite program solvers [46,47], and
quantum walks [1, 40, 48].
Recent efforts have focused on designing quantum algorithms that minimize resource requirements, motivated by the practical limitations of emerging small-scale quantum hardware—such as
constrained circuit depth and limited availability of ancilla qubits [24,49]. Many of these near-term
algorithms are either heuristic in nature [24], lacking rigorous guarantees, or tailored to specific
problems [42, 43]. A promising development in this direction is the randomized LCU framework
introduced in [39,40], which leverages a single ancilla qubit to construct resource-efficient quantum
algorithms for tasks such as quantum linear system solving and ground state property estimation.
However, these approaches still suffer from sub-optimal circuit depth and overall complexity.
In contrast, our approach provides the first fully end-to-end implementation of quantum singular
value transformation (QSVT) that eliminates oracular assumptions and requires only a single ancilla
qubit, while retaining near-optimal asymptotic complexity. As a result, when applied to problems of
practical interest, such as solving quantum linear systems or estimating ground state properties, our
framework yields quantum algorithms that are provably efficient, hardware-friendly, and practically
scalable on early fault-tolerant quantum computers.
Error mitigation via extrapolation has been extensively explored in the context of Hamiltonian
simulation, particularly for algorithms such as Trotterization [16], qDRIFT [17], and multi-product
formulas [11, 44]. These techniques are inspired by earlier strategies developed for suppressing
errors in near-term quantum circuits [50,51]. Recently, classical post-processing techniques such as
Chebyshev interpolation have been proposed to reduce Trotter errors more efficiently [16, 52, 53].
In particular, [53] examined the mitigation of Trotter errors in circuits composed of interleaved
unitaries and Hamiltonian evolutions. To avoid fractional queries to Hamiltonian evolution, they
applied separate cardinal sine interpolation to each segment, which results in sub-optimal scaling
for sequence lengths M ≥ 2.
In contrast, our work advances extrapolation-based error mitigation by integrating it as a fundamental design principle for constructing near-optimal quantum algorithms, tailored to both nearterm and fully fault-tolerant quantum architectures, and significantly expanding the scope and
efficacy of extrapolation beyond prior techniques.

### 2 Preliminaries


In this section, we first clarify the notation used throughout the article. Next, we provide a concise
overview of the foundational concepts pertinent to this work. Each subsection is self-contained and
does not depend on others, allowing readers to navigate the content flexibly. For those already
familiar with specific topics, some subsections may be skipped without losing continuity. Our goal
is to provide a thorough yet accessible overview, ensuring that all necessary background information
is available to support the main results of this paper.


2.1 Notation


Sets: We use N to denote the set of positive integers {1, 2, · · · } and T = {z ∈ C : |z| = 1} to denote
the complex unit circle. For any set S ⊆ R, we use S≥p to denote S ∩ [p, ∞).


15


Complexity theoretic notation: Throughout the work, we follow the standard complexitytheoretic notation. In particular, we use O [�] (·) to hide polylogarithmic factors, namely, O [�] (f (n)) =
O(f (n) polylog(f (n))).


Norms: We use bold lowercase letters to denote vectors. For example, a represents the vector
(a1, . . ., an). We use 1 to denote the vector ℓ1-norm, i.e., a 1 = [�][n] i=1
specified, ∥A∥ will denote the spectral norm of the operator ∥· ∥ ∥ A. We denote two operators∥ [|][a][i][|][. Unless otherwise] A, B
that are within ε-close in spectral norm, i.e., ∥A − B∥≤ ε, by A ≈ε B. We use Mn(C) to denote
the n n complex matrices. For A, B Mn(C), we define adB(A) = [B, A] = BA AB and so
× ∈   e [ad][B] (A) = e [B] Ae [−][B] . Let : Mn(C) Mn(C) be a quantum channel, then the diamond norm of
E → E
is given by
⋄ := max
∥E∥ ρ:∥ρ∥1≤1 [∥][(][E ⊗] [I][n][) (][ρ][)][∥][1][,]

where ρ ∈ Mn2(C) and ∥A∥1 = Tr[A [†] A] is the trace norm or Schatten 1-norm for matrix A. Let
f (x) : [a, b] → C, we denote
f [a,b] = max
∥ ∥ x∈[a,b] [|][f] [(][x][)][|][.]


Trace, Expectation and Probability: The trace of an operator A will be denoted by Tr[A].
The expectation value of a random variable V will be denoted by E[V ]. The probability of an event
E occurring will be denoted by Pr[E].


Pauli matrices: The Pauli matrices are




  1 0
I =
0 1




- 0 i
, Y =  i 0




- 0 1
, X =
1 0




- 1 0
, Z =
0 −1




.



Any matrix A of dimension 2 [n] can be uniquely written as a linear combination of tensor products
of Pauli matrices, namely,




  A =



2 [n][ Tr[][A][†][P] []][.]



λP P, λP = [1]

2

P ∈{I,X,Y,Z} [⊗][n]



If A is Hermitian, then λP R.
∈


Logarithm of a unitary matrix: For any unitary matrix U, there exists a unique skew-Hermitian
matrix V with eigenvalues in (−iπ, iπ] such that e [V] = U, and we denote V by log(U ).


Computational model: Throughout this article, by the time complexity of a quantum algorithm,
we refer to the number of elementary gates used to implement the algorithm.


2.2 Brief overview of quantum singular value transformation


In a nutshell, quantum singular value transformation (QSVT) applies polynomial transformations
to the singular values of any given operator H that is embedded in the top-left block of a unitary
UH. Before delving into QSVT, let us briefly define block encoding, which was introduced in a
series of works [1, 3, 4]. Formally, we define a block encoding as follows:

Definition 2.1 (Block encoding [4]). Suppose that H is an s-qubit operator, α ∈ R [+] and a ∈ N,
then we say that the (s + a)-qubit unitary UH is an (α, a, 0)-block encoding of H, if


16


H = α( 0 I)UH( 0 I). (2.1)
⟨ | [⊗][a] ⊗ | ⟩ [⊗][a] ⊗



That is,


Usually, errors are allowed in (2.1).




   -   H/α
UH = ∗ .
∗ ∗



Definition 2.2 (Singular value transformation). Let f : R → C be an even or odd polynomial. Let
A ∈ C [m][×][n] be a matrix with singular value decomposition (SVD) A = [�][n] i=1 [σ][i][|][u][i][⟩⟨][v][i][|][ with][ σ][i][ := 0]
when i > min(m, n). We define singular value transformation corresponding to f as



�ni=1 [f][ (][σ][i][)][ |][u][i][⟩⟨][v][i][|] if f is odd,
�ni=1 [f][ (][σ][i][)][ |][v][i][⟩⟨][v][i][|] if f is even.



f [(SV)] (A) :=











Note that √



A [†] A = [�] i [σ][i][|][v][i][⟩⟨][v][i][|][. So if][ f] [(][x][) is even, then][ f][ (SV)][(][A][) =][ f] [(] √



Note that A [†] A = i [σ][i][|][v][i][⟩⟨][v][i][|][. So if][ f] [(][x][) is even, then][ f][ (SV)][(][A][) =][ f] [(] A [†] A). If f (x) =

x f1(x) is odd for some even polynomial f1(x), then f [(SV)] (A) = A f1(√A [†] A). If f (x) is a polynomial

 -  
[(SV)]



x f1(x) is odd for some even polynomial f1(x), then f [(SV)] (A) = A f1( A [†] A). If f (x) is a polynomial

 -  
with definite parity and A is Hermitian, then f [(SV)] (A) = f (A) is the standard polynomial of a
matrix.

Definition 2.3 (Definition 8 of [1]). Let HU be a finite dimensional Hilbert space and U, Π, Π [�] ∈
End ( U ) be linear operators such that U is unitary and Π, Π are orthogonal projectors. [�] Let
H
Φ = (φ1, . . ., φd) ∈ R [d], we define the alternating phase modulation sequences UΦ as follows



UΦ :=














        -        e [i][φ][1][(2][Π][�] [−][I][)] U [�][(] j [d] =1 [−][1)][/][2] e [i][φ][2][j] [(2Π][−][I][)] U [†] e [i][φ][2][j][+1][(2][Π][�] [−][I][)] U, if d is odd,




  -   - (2.2)
�jd/=12 e [i][φ][2][j][−][1][(2Π][−][I][)] U [†] e [i][φ][2][j] [(2][Π][�] [−][I][)] U, if d is even.



With the above preliminaries, we can now state a key result of QSVT. The following theorem provides a nice connection between singular value transformation and the alternating phase
modulation sequences UΦ.


Theorem 2.4 (Theorem 10 of [1]). Assume that f (x) ∈ C[x] is an even or odd function of degree
d and |f (x)| ≤ 1 for all x ∈ [−1, 1], then there exists Φ ∈ R [d] such that



f [(SV)] (Π [�] U Π) =



��
ΠUΦΠ if d is odd,
ΠUΦΠ if d is even.



Intuitively, if we set


then Theorem 2.4 states that




    -     I 0
Π = Π = [�],
0 0




   f [(SV)] (H/α)
UΦ = ∗
∗ ∗




- H/α
, if U = ∗
∗ ∗




.



That is, if U an (α, 1, 0)-block encoding of H, then QSVT provides a generic framework to implement f [(SV)] (H/α), by making Θ(d) queries to U and U [†], while using a single ancilla qubit.
If f (x) is real, then using the linear combination of unitaries (LCU) technique, we can still
have a formula for f [(SV)] (Π [�] U Π), see [1, Corollary 11]. Now, we need to introduce one more ancilla


17


qubit because of LCU. Moreover, if f (x) is a general polynomial (without a definite parity), we
can decompose it into even and odd parts and apply these results to each part. Consequently, we
can still obtain a concise formula for f [(SV)] (Π [�] U Π). In the most general case, two additional ancilla
qubits are used.
Despite its generality, a drawback of this framework is that it assumes access to a block encoding
U of the underlying operator H. The construction of a block encoding itself can be expensive and
resource-consuming, which adds to the overhead of implementing any QSVT. For example, consider
the case that H is Hermitian and can be expressed as a linear combination of strings of L Pauli
operators, i.e.,

�L



H =



λjPj, λj > 0
j=1



where Pj ∈{I, X, Y, Z} [⊗][n] . Denote λ = [�] j [λ][j][. Then the block encoding of such an][ H][ can be]
constructed by using the LCU [54]. This proceeds as follows: Set ℓ = ⌈log2 L⌉. Define the following
two unitaries:







PREP |0⟩ [⊗][ℓ] =



�L



j=1



�L



j j Pj.
| ⟩⟨ | ⊗
j=1



λj/λ |j⟩, and SELP =



Then, it is easy to show that the block encoding of H is

              -              -              -              UH = PREP [†] ⊗ I SELP PREP ⊗ I .

Indeed,

            -            -            -            0 I UH 0 I = H/λ,
⟨ | [⊗][ℓ] ⊗ | ⟩ [⊗][ℓ] ⊗

which is a (λ, ⌈log2 L⌉, 0)-block encoding of H. Observe that building UH typically uses O(log L)
ancilla qubits, and a circuit depth of L (the depth of the unitary SELP ). Indeed, in the Appendix
(Sec. A), we show that Ω(log L) ancilla qubits are required to exactly construct a block encoding
H for a quite general circuit model including the technique of LCU. Moreover, constructing SELP
can be challenging as it involves a sequence of complicated controlled operations.
As a result, for any such Hamiltonian, from Theorem 2.4, QSVT implements f [(SV)] (H/λ) with a
circuit of depth O [�] (Ld), and O(log L) ancilla qubits. Despite its unifying feature, this raises concerns
regarding the applicability of QSVT for small-scale quantum computers. The same cost also holds
appears in many physically relevant problems. In Sec.when H is a k-local Hamiltonian, written as H = [�][L] j 4=1, we propose algorithms for implementing [H][j][. In this case,][ λ][ =][ �] j [L] =1 [∥][H][j][∥][. This]
QSVT without relying on block encoding access, while (nearly) preserving its optimality and using
only a constant number of ancilla qubits.


2.3 Generalized quantum signal processing



Recall that in standard QSVT, the polynomials have to be either complex even or complex odd.
While real polynomials can also be implemented, additional ancilla qubits are used. In the recently
introduced framework of Generalized Quantum Signal Processing (GQSP) [10], if we are allowed to
apply the controlled time-evolution operator, then we can implement any polynomial, even Laurent
polynomials of the time-evolution operator, without introducing more ancilla qubits. Next, we
outline some of their key results used in this work and refer the readers to [10] for details.
Suppose we can implement the controlled Hamiltonian simulation U = e [i][H] (and U [†] = e [−][i][H] ) as
a black box. That is, the operators




   U 0
c0-U = 0 I




- I 0
, c1-U [†] = 0 U [†]




(2.3)



18


using one query to U and one query to U [†] . Let

                e [i(][λ][+][φ][)] cos(θ) e [i][φ] sin(θ)
R(θ, φ, λ) =
e [i][λ] sin(θ)                     - cos(θ)




⊗ I



be arbitrary U(2) rotation of the single ancilla qubit. Motlagh and Wiebe [10] showed that for any
degree-d polynomial P, satisfying |P (x)| ≤ 1 in T := {x ∈ C : |x| = 1}, there exists an interleaved
sequence of R(θj, φj, 0) and c0-U, c1-U [†], of length 2d + 1, that implements a block encoding of
P (U ). Moreover, their framework also holds for Laurent polynomials bounded on T. We state this
result as follows:


Theorem 2.5 (Combining Corollary 5 and Theorem 6 of [10]). For any Laurent polynomial P (z) =

d
j=−d [a][j][z][j][ such that][ |][P] [(][z][)][| ≤] [1][ for all][ z][ ∈] [T][, there exist][ Θ = (][θ][j][)][j][,][ Φ = (][φ][j][)][j][ ∈] [R][2][d][+1][, λ][ ∈] [R]
such that

     -     -     - �d �d     P (U )
∗ = R(θd+j, φd+j, 0)c1-U [†][��] R(θj, φj, 0)c0-U R(θ0, φ0, λ). (2.4)
∗ ∗ j=1 j=1


In this work, we concretely provide the conditions under which a function f (x) can be approximated by a Laurent polynomial in e [i][x] (See Sec. 4). Given any H, this allows for implementing any
such f (H). We observe that GQSP is a particular instance of an interleaved sequence of unitaries
and Hamiltonian evolution operators. So, it suffices to implement the controlled Hamiltonian evolution operators by higher-order Trotter. This allows us to develop an end-to-end quantum algorithm
for QSVT, that is near optimal while using only a single ancilla qubit.


2.4 Hamiltonian simulation by Trotter methods


Simulating the dynamics of physical systems is widely considered to be one of the foremost applications of a quantum computer. Over the years, several quantum algorithms have been developed
for this problem, leading to near-optimal complexities [3, 45, 54, 55]. Trotter methods or product
formulas [5], inspired by the original proposal by Feynman for simulating physical systems [56], are
arguably the simplest techniques to implement e [i][tH] . These methods have seen remarkable progress
over the years, are easy to implement and demonstrate superior performance in practice [6, 57].
Here, we introduce some results from the theory of product formulas [6] which we will be using
in the subsequent sections. Let




- - �d
=



�d 
R(θj, φj, 0)c0-U R(θ0, φ0, λ). (2.4)
j=1



�d �d

R(θd+j, φd+j, 0)c1-U [†][��]
j=1 j=1



H =



�Γ

Hγ
γ=1



be a Hamiltonian expressed as a sum of Γ Hermitian terms. Then, a staged product formula [6, 16]
is an approximation of the unitary evolution operator e [−][i][Ht] by a product of the form



�Γ

e [i][ta][(][ν,γ][)][H][πν] [(][γ][)], (2.5)

γ=1



P(t) :=



�Υ


ν=1



where πν ∈ SΓ is permutation and a(ν,γ) ∈ R. A staged product formula is of p-th order if e [−][i][Ht] =
P(t) + O(t [p][+1] ), and symmetric if P(−t) = P [−][1] (t).
A well-known example is the 2k-th order Trotter-Suzuki formula S2k(t) [58], which is recursively
defined as



e [−][i][H][γ] [t/][2] (2.6)

γ=1



S2(t) :=



�1 �Γ

e [−][i][H][γ][t/][2]

γ=Γ γ=1



�1



19


and
S2k(t) := [S2(k−1)(ukt)] [2] S2(k−1)((1 4uk)t)[S2(k−1)(ukt)] [2], (2.7)
                        
where uk = 1/(4−4 [1][/][(2][k][−][1)] ). The 2k-th order Trotter-Suzuki formula is symmetric with Υ = 2·5 [k][−][1]

and a(ν,γ) 2k/3 [k], as stated in [59]. Define
| | ≤



α [(] comm [j][)] [:=]



�Γ


γ1,γ2,...,γj=1



��� ���
Hγ1Hγ2 . . . Hγj



for j ∈ N, where [X1X2 . . . Xn] refers to a right-nested n-commutator as

[X1X2 . . . Xn] := [X1, [X2, [. . . [Xn−1, Xn] . . .]]] .


Childs et al. [6] showed that

                   e [−][i][tH] (t) = O αcomm [(][p][+1)][t][p][+1][�] .
∥ −P ∥


Thus, the complexity (circuit depth) of p-th order Trotter formula to approximate e [−][i][tH] to an
accuracy of ε, with commutator scaling is given by







O




Γ(αcomm [(][p][+1)][)][1][/p][t][1+1][/p]

ε [1][/p]



.



As discussed in [6], the prefactor αcomm scales significantly better than the worst-case bound of
O( H 1) for many physical Hamiltonians. We take advantage of this scaling in our QSVT algorithm
∥ ∥
developed in Sec. 4.
Recently, it has been shown that the circuit depth can be exponentially improved to O(log(1/ε))
by utilizing extrapolation techniques [16]. Therein, it was proven that for sufficiently small t, P(t)
can be written as an exponential of −iH plus a power series in t, using Baker-Campbell-Hausdorff
(BCH) formula based on right-nested commutators [60].

For anyLemma 2.6 t ∈ R (Lemma 2 of [, if there exists16 J]). ∈ LetN P and(t) c be a staged product formula ∈ R [+] such that (2.5) and amax = maxν,γ |aν,γ|.

sup α [(] comm [j][)] (2.8)
j≥J [·][ (][a][max][Υ][|][t][|][)][j][ ≤] [c,]



then P(t) can be written as



P(t) = e [−][i][t][(][H][+][�] j [∞] =1 [E][j][+1][t][j] [)],



such that Ej (amaxΥ) [j] α [(] comm [j][)] [/j][2][ for all][ j][.]
∥ ∥≤

Note that condition (2.8) ensures that the nested commutators do not grow too rapidly, which
guarantees the convergence of the BCH formula. Using Lemma 2.6, [16] constructed an error series
of an operator evolved under a product formula. More precisely, for s ∈ (0, 1) and observable O, let
O˜T,s := (P [†] (sT )) [1][/s] O(P(sT )) [1][/s] . The next result describes the error between ˜OT,s and the exact
evolution OT := e [i][HT] Oe [−][i][HT] .


20


Lemma 2.7 (Lemma 4 of [16]). Let P be a p-th order staged product formula. Suppose that
condition (2.8) holds for t = sT . Let σ = 2 if P is symmetric, and 1 otherwise. Then, for any
K ∈ N,




   O˜T,s − OT =



s [j][ ˜] Ej+1,K(T ) + F [˜] K (T, s),
j∈(σZ)≥p



where E [˜] j+1,K(T ) and F [˜] K (T, s) are superoperators with induced spectral norm bounded as



min{K�−1,⌊j/p⌋}
Ej+1,K(T ) (amaxΥT ) [j]
∥ [˜] ∥≤

ℓ=1



�ℓ


κ=1



2α [(] comm [j][κ][+1)]
(jκ + 1) [2][,]



(amaxΥT ) [ℓ]

ℓ!




 

j1,...,jℓ∈(σZ)≥p
j1+···+jℓ=j



FK (T, s)
∥ [˜] ∥≤ [(][a][max] K [Υ] ! [T] [)][K]




 - 
(amaxΥsT ) [j]
j∈(σZ)≥Kp j1,...,jK∈(







j1,...,jK∈(σZ)≥p
j1+···+jK =j



�K


κ=1



2αcomm [(][j][κ][+1)]
(jκ + 1) [2][ .]



Expressing the error terms as a power series in the Trotter step sizes allows us to use Richardson
extrapolation (see Sec. 2.5) to extrapolate to the zero-error limit. This leads to a circuit depth
scaling with polylog(1/ε) instead of 1/ε [1][/p] .
In Sec. 3, we provide a non-trivial generalization of the result of [16], proving that even for very
general quantum circuits (interleaved sequence of arbitrary unitaries and Hamiltonian evolution
operators), the difference between the aforementioned expectation values can be expressed as a
power series in the Trotter step sizes. Thus, this is at the heart of our end-to-end quantum
algorithms for QSVT without block encodings.


2.5 Richardson extrapolation


Richardson extrapolation is a method to estimate f (0) = limx→0 f (x) using value f (x) for several
values of x s1, s2, . . ., sm, via an appropriate linear combination of f (s1), f (s2), . . ., f (sm).
∈{ }
This method improves the accuracy of numerical solutions by effectively removing leading-order
error terms, thereby increasing the order of accuracy without significantly increasing computational
effort. Recently, it has been applied to mitigate errors in Hamiltonian simulation using Trotter
methods, multi-product formulas, and qDRIFT. Formally, we state the relevant lemma below:


Lemma 2.8 (Richardson extrapolation, see [11,17]). Suppose that function f : R → R has a series
expansion



f (x) = f (0) +



�∞

cix [i] .
i=1



Choose an initial point s0 ∈ (0, 1) and set points si = s0/ri with integer ri ̸= 0 for i ∈ [m]. Then,
using these m sample points {si : i ∈ [m]}, we can derive an m-term Richardson extrapolation



F [(][m][)] (s0) =



�m

bif (si) (2.9)
i=1



by choosing appropriate coefficients bi to cancel the first m − 1 terms in the series expansion, such
that
|F [(][m][)] (s0) − f (0)| ≤∥b∥1 |Rm(s0)| = O(s [m] 0 [)][.]


21


where Rm(x) is a function that only has terms of order O(x [m] ) and above. In particular, let


̸


̸



1
, (2.10)
1 rℓ/ri

̸ 

̸



�2 , bi =

ℓ̸=i


̸



ri =

̸


̸




- √8m

π sin(π(2i 1)/8m)
     - ̸


̸




- √


̸


̸



̸


then ∥b∥1 = O(log m), maxi{ri} = O(m [4] ) and maxi{ri/rm} = O(m [2] ).


̸



̸


Proof. For a general power series, the solution to find the coefficients bi is given by the Vandermonde
matrix equation
     


̸



̸







̸



̸


b1
b2
...
bm


̸



̸


=



̸



̸


1
0
...
0


̸



̸


.



̸



̸







̸



̸





̸



̸





̸



̸





̸



̸


1 1 . . . 1
r1 [−][1] r2 [−][1] rm [−][1]

                - · ·
... ... ... ...
r1 [−][m][+1] r2 [−][m][+1] . . . rm [−][m][+1]


̸



̸







̸



̸


For the choice of {ri}, it is easy to see that ri decreases as k increases from 1 to m, which implies
that maxi{ri} = r1 = O(m [4] ) and maxi{ri/rm} = r1/rm = O(m [2] ).

Lemma 2.8 provides a choice of coefficients bi for general power series. However, for specific
series where many ci vanish, we can choose different coefficients bi to obtain even better estimates.
In particular, for symmetric Trotter methods, half of the coefficients ci in the power series are zero,
so the following result from [16] will be useful for error analysis of our general framework.

Lemma 2.9 (Lemma 5 of [16]). Let f (x) ∈ C [2][m][+2] ([−1, 1]) be an even, real-valued function, and
let Pj and Rj be the degree-(j − 1) Taylor polynomial and Taylor remainder, respectively, such that
f (x) = Pj(x) + Rj(x). Let


̸



̸


F [(][m][)] (s0) =


̸



̸


�m


̸



̸


bif (si)
i=1


̸



̸


be the Richardson extrapolation of f (x) at points si = s0/ri, i ∈ [m] given by


̸



̸




̸



̸


1
, (2.11)

̸ 1 − rℓ [2][/r] i [2]



̸


  , bi =

ℓ̸=i



̸


ri =

̸



̸


- √


̸



̸


8m
π sin(π(2i 1)/8m)
    - ̸



̸


̸


Then



̸


̸


�m

F [(][m][)] (s0) = f (0) + biR2m (si)

i=1



̸


̸


with error bounded by ∥b∥1 maxi∈[m] |R2m(si)| and ∥b∥1 = O(log m).

In this work, we show that Richardson extrapolation can be applied, almost as a black box, in
much more general settings.

### 3 Interleaved unitaries and Hamiltonian evolutions: A unified frame- work


In this section, we show how quantum circuits composed of interleaved sequences of arbitrary
unitaries and Hamiltonian evolutions can be implemented with near-optimal complexity. Our
approach replaces each Hamiltonian evolution with a higher-order Trotter–Suzuki approximation,
and we demonstrate that the expectation value of any observable with respect to the final state


22


can be expressed as a power series in the Trotter step size. This structure enables the use of
classical extrapolation techniques, significantly improving the dependence on precision from 1/ε [o][(1)]

to polylog(1/ε). As a result, we obtain a resource-efficient, near-optimal solution to Problem 1.1.
Let
H [(1)], H [(2)], . . ., H [(][M] [)],


be Hermitian operators, where each



H [(][ℓ][)] =



�Γℓ

Hγ [(][ℓ][)][,]
γ=1



is a decomposition of H [(][ℓ][)] into terms Hγ [(][ℓ][)][, and the Hamiltonian evolution of each][ H] γ [(][ℓ][)] can be
efficiently implemented. Let V0, V1, . . ., VM be arbitrary unitary operators. Then, we define a
quantum circuit that is an interleaved sequence of unitaries and Hamiltonian evolutions, as follows:



W = V0



�M

e [i][H] [(][ℓ][)] Vℓ. (3.1)
ℓ=1



We now address Problem 1.1, namely the estimation of ψ0 W [†] OW ψ0 for an arbitrary initial
⟨ | | ⟩
state ψ0 and any observable O, using no ancilla qubits, and with near-optimal complexity. Our
| ⟩
algorithm proceeds by applying high-order Trotter methods to implement the Hamiltonian evolution
with decreasing Trotter step sizes. At each step-size, we estimate the observable and then apply
classical extrapolation on the measurement results to recover the zero-step-size limit, corresponding
to the true expectation value. The main results are proven in Theorem 3.4 and Theorem 3.6. To
establish the error bound, we first derive an error series for the measurement result in terms of
the inverse of the total number of Trotter steps as a non-trivial generalization of Lemma 2.7 (see
Lemma 3.1 below).
Define



�� (ℓ) ��

[Hγ1 [H] γ [(][ℓ] 2 [)] [. . . H] γ [(][ℓ] j [)][]]



αcomm [(][j,ℓ][)] [:=]



�Γ



for j ∈ N and



γ1,γ2,...,γj =1


α˜ [(] comm [j][)] [:= max] comm [.] (3.2)
ℓ∈[M ] [α][(][j,ℓ][)]



Let O be an observable, and define
O2M +1 := W [†] OW (3.3)


as the observable evolved under the interleaved operator W defined as in Eq. (3.1). Suppose



�Γ

e [i][ta][(][ν,γ][)][H] πν [(][ℓ][)] (γ),

γ=1



P [(][ℓ][)] (t) =



�Υ


ν=1



is a p-th order symmetric staged product formula for H [(][ℓ][)] . For any s ∈ (0, 1), define




     O˜2M +1,s := V0



�M �† 
(sM ) [1][/][(][sM] [)] Vℓ O V0
P [(][ℓ][)]
ℓ=1



�M 
(sM ) [1][/][(][sM] [)] Vℓ (3.4)
P [(][ℓ][)]
ℓ=1



as the observable evolved under the staged product formula approximations with step size sM .


23


Lemma 3.1. Suppose condition (2.8) holds for ˜α [(] comm [j][)] [with][ t][ =][ sM] [. Then]

       O˜2M +1,s − O2M +1 = j∈(σZ)≥p s [j][ ˜] Ej+1,K(M ) + F [˜] K (M, s),


where E [˜] j+1,K(M ) and F [˜] K (M, s) are superoperators with induced spectral norm bounded as



min{K�−1,⌊j/p⌋}
Ej+1,K(M ) (amaxΥM ) [j]
∥ [˜] ∥≤

ℓ=1



�ℓ


κ=1


�K


κ=1



2˜αcomm [(][j][κ][+1)]
(jκ + 1) [2][,]


2˜αcomm [(][j][κ][+1)]
(jκ + 1) [2][ .]



(3.5)



(amaxΥM ) [ℓ]

ℓ!




 

j1,...,jℓ∈(σZ)≥p
j1+···+jℓ=j



(amaxΥM ) [K]
FK (M, s)
∥ [˜] ∥≤ K!




 - 
(amaxΥsM ) [j]
j∈(σZ)≥Kp j1,...,jK ∈(







j1,...,jK ∈(σZ)≥p
j1+···+jK =j



Proof. Let δ := sM be the time step size of the staged product formula P [(][ℓ][)] and



E [(][ℓ][)] (δ) := −



�∞

Ej [(][ℓ] +1 [)] [δ][j] (3.6)
j∈(2N)≥p



be the effective error Hamiltonian in Lemma 2.6, where the norm of Ej [(][ℓ][)] is bounded as



∥Ej [(][ℓ][)][∥≤] [(][a][max] j [2][Υ)][j]




[Υ)][j]

j [2] α [(] comm [j,ℓ][)] [≤] [(][a][max] j [2][Υ)][j]



α˜ [(] comm [j][)] [.] (3.7)
j [2]



By assumption, δ satisfies the convergence condition of Lemma 2.6 for all ℓ, so we can write P [(][ℓ][)] (δ)
as P [(][ℓ][)] (δ) = e [−][i][δ][(][H][−][E][(][ℓ][)][(][δ][))] . We define the time-dependent Hamiltonian H(t) and H [˜] (t) as




i log(V⌊t⌋/2) if t is even,
⌊ ⌋
−H [(][⌈][t/][2][⌉][)] + E [(][⌈][t/][2][⌉][)] (δ) if ⌊t⌋ is odd,



H(t) =




i log(V⌊t⌋/2) if ⌊t⌋ is even, H˜ (t) =
−H [(][⌈][t/][2][⌉][)] if ⌊t⌋ is odd,



for t ∈ [0, 2M + 1]. Here log(Vℓ) is skew-Hermitian as Vℓ is unitary. Denote OT, O [˜] T,s as the time
evolved observable under the Hamiltonian H(t) and H [˜] (t) respectively, which means


∂tOt = i adH(t)(Ot), ∂tO [˜] t,s = i ad ˜H(t) [( ˜][O][t,s][)] (3.8)

and O0 = O, O [˜] 0,s = O, where adH(·) := [H, ·], see Sec. 2.1. For T = 2M + 1, we have




    O2M +1 = V0



�M �† 
e [i][H] [(][ℓ][)] Vℓ O V0
ℓ=1



�M 
e [i][H] [(][ℓ][)] Vℓ,
ℓ=1



and




    O˜2M +1,s = V0



�M �† 
(sM ) [1][/][(][sM] [)] Vℓ O V0
P [(][ℓ][)]
ℓ=1



�M 
(sM ) [1][/][(][sM] [)] Vℓ,
P [(][ℓ][)]
ℓ=1



which match the definitions of O2M +1 and O [˜] 2M +1,s in Eqs. (3.3) and (3.4). Let 1A be the indicator
function of the set A := {t ∈ [0, 2M + 1] : ⌊t⌋ is odd} and then the effective error Hamiltonian at
time t can be written as


Eˆ(t) := ˜H(t) H(t) = E [(][⌈][t/][2][⌉][)] (δ) 1A(t).
                  -                   

24


T2 T2
Let ΦH(T2, T1) = e [i] �T1 [ad][H][(][t][)][ d][t] and Φ ˜H [(][T][2][, T][1][) =][ T][ e][i] �T1 [ad][H][(][t][)][ d][t] be the time-evolution opT
erator of the differential equation defining OT and O [˜] T,s in Eq. (3.8) and then OT and O [˜] T,s can be
written as
OT = ΦH(T, 0)O, O˜T,s = Φ ˜H [(][T,][ 0)][O]



for T ∈ [0, 2M + 1]. Using a time-dependent variation-of-parameters formula




         T
D2(T, 0) = D1(T, 0) +



D1(T, τ )B(τ )D2(τ, 0) dτ,
0



where
D2(T2, T1) = e
T



T2
�T1 [A][(][t][) d][t],



T2
�T1 [(][A][(][t][)+][B][(][t][)) d][t] and D1(T2, T1) = e
T



the difference between Φ ˜H [(][T,][ 0) and Φ][H][(][T,][ 0) can be written as]

                  - T
Φ ˜H(T, 0) = ΦH(T, 0) + ΦH(T, τ )i ad ˆE(τ )Φ ˜H(τ, 0) dτ.

0

We can use the variation-of-parameters formula K − 1 times to obtain



O˜T,s OT
    = (Φ ˜H(T, 0) ΦH(T, 0))O

  -   



  - T
=

0

  - T
=



ΦH(T, τ1)i ad ˆE(τ1)( O [˜] τ1,s) dτ1
0



T - T

ΦH(T, τ1)i ad ˆE(τ1)(Oτ ) dτ1 +
0 0




- τ1

ΦH(T, τ1)i ad ˆE(τ1) ΦH(τ1, τ2)i ad ˆE(τ2)( O [˜] τ2,s) dτ2dτ1
0



0




   
τ1 τℓ−1

0 - · · 0




T




τ1



=



K�−1



ℓ=1

  - T
+

0



0



τ1 - τK−1

0 - · · 0




- τ1



ΦH(T, τ1)i ad ˆE(τ1) ΦH(τK−1, τK )i ad ˆE(τK )( O [˜] τK,s) dτK dτ1. (3.9)
0 - · · - · ·



ΦH(T, τ1)i ad ˆE(τ1) ΦH(τℓ−1, τℓ)i ad ˆE(τℓ)(Oτℓ ) dτℓ dτ1
0 - · · - · ·



For any ℓ ∈ [K − 1], we have

 - T  - τ1  - τℓ−1



κ=ℓ

�1


κ=ℓ




- τ1



0

 T
=

0

 T
=

0



τ1 - τℓ−1

0 - · · 0

   
τ1 τℓ−1

0 - · · 0

   
τ1 τℓ−1

0 - · · 0



0




τ1



ΦH(T, τ1)i ad ˆE(τ1) ΦH(τℓ−1, τℓ)i ad ˆE(τℓ)(Oτℓ ) dτℓ dτ1
0 - · · - · ·



�1



0




- ΦH(τκ−1, τκ)i adE(⌈τk/2⌉)(δ) 1A(τκ) (Oτℓ ) dτℓ  - · · dτ1



�∞

ad (⌈τk/2⌉) δ [j][κ][�] (O(τℓ)) dτℓ dτ1
jκ∈(2N)≥p Ejκ+1 - · ·




τ1




ΦH(τκ−1, τκ)i1A(τκ)




     
 - T

δ [j]
j∈(2N)≥pℓ 0




   
τ1 τℓ−1

0 - · · 0




 

j1,...,jℓ∈(2N)≥p
j1+···+jℓ=j




(Oτℓ ) dτℓ dτ1,

          - · ·




ΦH(τκ−1, τκ)i1A(τκ) ad (⌈τk/2⌉)
E
jκ+1




 =




τ1



�1


κ=ℓ



0



0



with τ0 T, where the second equation follows from Eq. (3.6). We then substitute δ = sM,
≡
T = 2M + 1, and take summation over ℓ ∈ [K − 1]. This gives




    First line of Eq. (3.9) =



s [j][ ˜] Ej+1,K(M )(O),
j∈(2N)≥p



25


where E [˜] j+1,K is defined as

min{K�−1,⌊j/p⌋}                  - 2M +1
E˜j+1,K(M )(O) = M [j]

0

ℓ=1




- τ1



τ1 - τℓ−1

0 - · · 0



0




(Oτℓ ) dτℓ dτ1.

          - · ·




 

j1,...,jℓ∈(2N)≥p
j1+···+jℓ=j



�1 
ΦH(τκ−1, τκ)i1A(τκ) ad (⌈τk/2⌉)
E

κ=ℓ jκ+1



The induced spectral norm of the superoperator E [˜] j+1,K(M ) is bounded as



Ej+1,K(M )
∥ [˜] ∥




 

j1,...,jℓ∈(2N)≥p
j1+···+jℓ=j




- τ1



τ1  - τℓ−1

0 - · · 0



min{K�−1,⌊j/p⌋}
≤ M [j]



0



�1

1A(τκ) ad (⌈τk/2⌉) dτℓ dτ1
κ=ℓ ∥ Ejκ+1 ∥ - · ·



ℓ=1



�1



�1 
1A(τκ)
κ=ℓ j1,...,j ∈



j1,...,jℓ∈(2N)≥p
j1+···+jℓ=j



min{K�−1,⌊j/p⌋}
= M [j]


ℓ=1


min{K�−1,⌊j/p⌋}
≤ M [j]

ℓ=1




- 2M +1


0


2M +1


0


M [ℓ]




τ1




   
τ1 τℓ−1

0 - · · 0



0



�1

ad (⌈τk/2⌉) dτℓ dτ1
κ=ℓ ∥ Ejκ+1 ∥ - · ·







�1



ℓ!



j1,...,jℓ∈(2N)≥p
j1+···+jℓ=j



�1

(amaxΥ) [j][κ][+1]
2˜α [(] comm [j][κ][+1)]
κ=ℓ (jκ + 1) [2]



(jκ + 1) [2]



min{K�−1,⌊j/p⌋}
= (amaxΥM ) [j]

ℓ=1



�ℓ


κ=1



2˜α [(] comm [j][κ][+1)]
(jκ + 1) [2][ .]



(amaxΥM ) [ℓ]

ℓ!




 

j1,...,jℓ∈(2N)≥p
j1+···+jℓ=j



The first inequality follows from ΦH(τκ−1, τκ) = 1 as H(t) is Hermitian, and the second inequal∥ ∥
ity follows from vol(A [⊗][ℓ] ) = vol(A) [ℓ] = M [ℓ] and take the order of τ1, τ2, . . ., τℓ into account, the
integration

       - 2M +1        - τ1        - τℓ−1 �1 [⊗][ℓ] [ℓ]





1A(τκ) dτℓ dτ1 = [vol(][A][⊗][ℓ][)]

              - · · ℓ!
κ=ℓ




- τ1



�1




[A][⊗][ℓ][)]

= [M] [ℓ]
ℓ! ℓ!



ℓ! [.]



0



τ1 - τℓ−1

0 - · · 0



0



By similar arguments, we can show that the second term in Eq. (3.9) can be written as




 - - 2M +1

(sM ) [j]
j∈(2N)≥Kp 0




- τ1



τ1 - τK−1

0 - · · 0




   F˜(M, s)(O) =



0



0




( O [˜] τK,s) dτK dτ1.
            - · ·




ΦH(τκ−1, τκ)i1A(τκ) ad (⌈τk/2⌉)
E
jκ+1




 

j1,...,jK ∈(2N)≥p
j1+···+jK =j



�1


κ=K



The operator norm of the operator F [˜] K (M, s) is bounded as



FK (M, s)
∥ [˜] ∥≤ [(][a][max] K [Υ] ! [M] [)][K]


This completes the proof.




 - 
(samaxΥM ) [j]
j∈(2N)≥Kp j1,...,jK ∈(2







j1,...,jK ∈(2N)≥p
j1+···+jK =j



�K


κ=1



2˜αcomm [(][j][κ][+1)]
(jκ + 1) [2][ .]



26


For any s0 (0, 1] with 1/s0 N, let
∈ ∈

O˜2 [(][m] M [)] +1,s0 [=]



�m

bkO [˜] 2M +1,sk (3.10)
k=1



be the m-point Richardson extrapolation with bk, sk given in Lemma 2.9, where O [˜] 2M +1,sk is defined
via Eq. (3.4). Let



�1/(j+ℓ) , (˜α [(] comm [j][)] [)][1][/j]



Λj,ℓ := max



��

  

j1,...,jℓ∈(2N)≥p
j1+···+jℓ=j



�ℓ


κ=1



2˜α [(] comm [j][κ][+1)]
(jκ + 1) [2]



(3.11)



and
λcomm := max
j∈(2N)≥2m
ℓ∈[K]



Λj,ℓ. (3.12)



Remark 3.2 (Upper bounds of λcomm). Here, we simplify the expression of λcomm by providing
some known upper bounds.


  - For general Hamiltonians, according to [16, Eqs. (33) and (78)], we have



λcomm 4 max
≤ ℓ∈[M ]



�Γℓ

Hj [(][ℓ][)] (3.13)
ℓ=1 ∥ [∥][.]




- Suppose that there exist α > 0 and Cα > 1 such that



α˜ [(] comm [j][)] (3.14)

[≤] [C][α][α][j][/][2]



for all j ∈ (2N)≥p. Then, for all j ∈ (2N)≥2m and ℓ ∈ [K], we have (˜α [(] comm [j][)] [)][1][/j][ ≤] [C] α [1][/p][α][ and]

 - - �ℓ [(][j][κ][+1)] �1/(j+ℓ) - - �ℓ [1][/][(][p][+1)] [j][κ][+1] �1/(j+ℓ)



j1,...,jℓ∈(2N)≥p
j1+···+jℓ=j



(Cα [1][/][(][p][+1)] α) [j][κ][+1]



�ℓ



�1/(j+ℓ)



�1/(j+ℓ)
≤





 


�ℓ



1



2˜αcomm [(][j][κ][+1)]
(jκ + 1) [2]



κ=1



j1,...,jℓ∈(2N)≥p
j1+···+jℓ=j



κ=1



(jκ + 1) [2]


�ℓ



�1/(j+ℓ)



= αCα [1][/][(][p][+1)]

            




 


j1,...,jℓ∈(N)≥p
j1+···+jℓ=j



(jκ + 1) [2]



κ=1





 


�1/(j+ℓ)



αCα [1][/][(][p][+1)]
≤


= αCα [1][/][(][p][+1)]



1



j1,···jℓ,∈N
j1+···+jℓ=j




j + ℓ  - 1
ℓ   - 1



�1/(j+ℓ)



αCα [1][/][(][p][+1)] (2 [j][+][ℓ] ) [1][/][(][j][+][ℓ][)] = 2Cα [1][/][(][p][+1)] α,
≤



where the first inequality follows from Cα > 1 and jκ ≥ p. This implies that

λcomm ≤ 2Cα [1][/p][α.] (3.15)

The condition in Eq. (3.14) is satisfied by many physical Hamiltonians, as elucidated in [6,44].
We use some of these results to estimate λcomm.


27


(i) For Hamiltonian H = [�][Γ] γ=1 [H][γ][, [][6][] showed that if][ H][ is an electronic-structure Hamil-]

tonians over n orbitals, we have α [(] comm [j][)] [=][ O][(][n][j][) and so]


λcomm = O(n). (3.16)

(ii) For k-local Hamiltonians over n qubits H = [�] j1,...,jk [H][j] 1 [,...,j] k [, we have]

                 -                 α [(] comm [j][)] [=][ O] |||H|||1 [j][−][1] ∥H∥1,



where,
H 1 = max
||| ||| ℓ




max
jℓ




 -  
Hj1,...,jk
∥ ∥
j1,...,jℓ−1,jℓ+1,...,jk



is the induced 1-norm. In this case, we have

               -                λcomm = O ( H 1/ H 1) [1][/p] H 1 . (3.17)
∥ ∥ ||| ||| ||| |||

(iii) For Hamiltonians with a power law decay, this scaling improves further. Let Λ ⊆ R [d] be
an n-qubit d-dimensional square lattice. Then, a power law Hamiltonian H on Λ with
exponent r, is written as

       H = H⃗i,⃗j,

⃗i,⃗j∈Λ



where each H [⃗] i, [⃗] j Λ and i j = 1, if i = j, and
⃗i,⃗j acts non-trivially on two qubits ∈ ∥ [⃗]        - [⃗] ∥



∥ [⃗] i − [⃗] j∥ = ∥ [⃗] i − [⃗] j∥2 [−][r][, if][ ⃗i][ ̸][=][ ⃗j][. Then, [][6][] proved that]



O(n [1][−][r/d] ), 0 ≤ r < d
O(log n), r = d
O(1), r > d



O(n [2][−][r/d] ), 0 ≤ r < d
O(n log n), r = d
O(n), r > d













|||H|||1 =













∥H∥1 =



Substituting the above values of |||H|||1 and ∥H∥1 into Eq. (3.17), we obtain different
scalings for λcomm.


We now state a lemma which upper bounds the error between O2M +1 and O [˜] 2 [(][m] M [)] +1,s0 [.]

Lemma 3.3. Let O2M +1 and O [˜] 2 [(][m] M [)] +1,s0 [be defined via Eqs.][ (][3.3][)][ and][ (][3.10][)][ respectively. Suppose]
that smamaxΥMλcomm 1/2. Then for any initial state ψ0, the extrapolation error is bounded as
≤ | ⟩
follows
��⟨ψ0|O ˜2(mM)+1,s0 [|][ψ][0][⟩−⟨][ψ][0][|][O][2][M] [+1][|][ψ][0][⟩] �� ≤ 4∥O∥∥b∥1(smamaxΥMλcomm)2m max{amaxΥMλcomm, 1}K,

where K = ⌈2m/p⌉.

Proof. Define
f (s) := ψ0 O [˜] 2M +1,s ψ0 for s (0, sm],
⟨ | | ⟩ ∈

f (0) := ψ0 O2M +1 ψ0
⟨ | | ⟩

be the function we want to extrapolate. By the definition of rk in Eq. (2.11) and sk = s0/rk, all sk
are in the domain of f (s). As smamaxΥMλcomm 1/2 and by the definition of λcomm, we have
≤

α˜ [(] comm [j][)]

[·][ (][a][max][Υ][|][s][m][M] [|][)][j][ ≤] [(][s][m][a][max][Υ][Mλ][comm][)][j][ ≤] [1][/][2][j]


28


for all j 2m. So condition (2.8) holds with t = smM, C = 1/2 [2][m], J = 2m. By Lemma 3.1, f (s)
≥
can be expanded as




    f (s) = ψ0 O2M +1 ψ0 +
⟨ | | ⟩




  = f (0) +


j∈2N
2m>j≥p



s [j] ψ0 E [˜] j+1,K(M )(O) ψ0 + ψ0 F [˜] K (M, s)(O) ψ0
j∈2N,j≥p ⟨ | | ⟩ ⟨ | | ⟩



(3.18)
s [j] ψ0 E [˜] j+1,K(M )(O) ψ0 + R2m(s)
⟨ | | ⟩



for all s (0, sm], where
∈




  R2m(s) :=



s [j] ψ0 E [˜] j+1,K(M )(O) ψ0 + ψ0 F [˜] K (M, s)(O) ψ0 (3.19)
j∈2N,j≥2m ⟨ | | ⟩ ⟨ | | ⟩



is the reminder term. Let Fm(s0) := ⟨ψ0|O [˜] 2 [(][m] M [)] +1,s0 [|][ψ][0][⟩] [=][ �] k [m] =1 [b][k][f] [(][s][k][) be the Richardson extrap-]
olation of f (s) at points s1, s2, . . ., sm. By Lemma 2.9, the error of the Richardson extrapolation
is bounded as

(m)
�� ψ0 O ˜2M +1,s0 [|][ψ][0][⟩−⟨][ψ][0][|][O][2][M] [+1][|][ψ][0][⟩] �� = Fm(s0) f (0) b 1 max (3.20)
⟨ | |     - | ≤∥ ∥ k∈[m] [|][R][2][m][(][s][k][)][|][.]

As j 2m K(p 1), by Eq. (3.5), the norm of E [˜] j+1,K(M ) and F [˜] K (M, s) can be bounded as
≥ ≥  


min{K�−1,⌊j/p⌋}
Ej+1,K(M ) (amaxΥM ) [j]
∥ [˜] ∥ ≤

ℓ=1



�ℓ


κ=1



2˜α [(] comm [j][κ][+1)]
(jκ + 1) [2]



(amaxΥM ) [ℓ]

ℓ!




 

j1,...,jℓ∈(2N)≥p
j1+···+jℓ=j



K�−1
= (amaxΥM ) [j]

ℓ=1



(amaxΥM ) [ℓ]

ℓ! Λj,ℓ [j][+][ℓ]



≤



K�−1


ℓ=1



(amaxΥMλcomm) [j][+][ℓ]

, (3.21)
ℓ!



and



��



(amaxΥM ) [K]
FK (M, s)
∥ [˜] ∥ ≤ K!




 - 
(amaxΥsM ) [j][�]
j∈2N,j≥Kp j1,...,jK ∈







j1,...,jK ∈2N≥p
j1+···+jK =j




- - [K]


κ=1



2˜α [(] comm [j][κ][+1)]
(jκ + 1) [2]




 =



K!




 
s [j][ (][a][max][Υ][M] [Λ][j,K][)][j][+][K]

K!

j∈(2N)≥Kp




 ≤




 
s [j][ (][a][max][Υ][Mλ][comm][)][j][+][K]

K!

j∈(2N)≥Kp



. (3.22)
K!



By Eqs. (3.19), (3.21), and (3.22), the reminder R2m(s) can be bounded as




 - K�−1

s [j]

j∈2N,j≥2m ℓ=1

 - �K

s [j]

j∈2N,j≥2m ℓ=1



(amaxΥMλcomm) [j][+][ℓ]

ℓ!


29




   R2m(s)
| | ≤



ℓ=1



K!



(amaxΥMλcomm) [j][+][ℓ]




 
s [j][ (][a][max][Υ][Mλ][comm][)][j][+][K]

K!

j∈2N,j≥Kp




   
comm) [j][+][ℓ]

+
ℓ!




 ≤



ℓ=1


 - �K

(samaxΥMλcomm) [j] max amaxΥMλcomm, 1
j∈2N,j≥2m { } [K] ℓ=1




 ≤



1
ℓ!




1



ℓ=1



(samaxΥMλcomm) [2][m][ �]
≤



j≥0



2



�2j
max amaxΥMλcomm, 1 (e 1)
{ } [K]    


4(samaxΥMλcomm) [2][m] max amaxΥMλcomm, 1,
≤ { } [K]



where the second inequality follows from Kp ≥ 2m and the fourth inequality follows from the estimate samaxΥMλcomm smamaxΥMλcomm 1/2. By Eq. (3.20), we can bound the extrapolation
≤ ≤
error as

(m)
�� ��
⟨ψ0|O ˜2M +1,s0 [|][ψ][0][⟩−⟨][ψ][0][|][O][2][M] [+1][|][ψ][0][⟩]

O b 1 max
≤ ∥ ∥∥ ∥ k∈[m] [4(][sa][max][Υ][Mλ][comm][)][2][m][ max][{][a][max][Υ][Mλ][comm][,][ 1][}][K]

= 4 O b 1(smamaxΥMλcomm) [2][m] max amaxΥMλcomm, 1,
∥ ∥∥ ∥ { } [K]

which is as claimed.


We now summarize our main theorems. Below, we aim to provide a time complexity analysis
rather than expressing complexity in terms of the number of Trotter steps as in [16]. This results
in an additional factor of O(ΓΥ) in the complexity compared to [16], as each Trotter step costs
O(ΓΥ) in the worst case. But for certain Hamiltonians, more efficient implementations of each
Trotter step exist [6].


Theorem 3.4 (Interleaved sequences of unitaries and Hamiltonian evolution with Trotter, incoherent estimation). Let H [(][ℓ][)] ℓ=1 [be a set of Hermitian operators, with decomposition][ H] [(][ℓ][)][ =]
�Γγ=1ℓ [H] γ [(][ℓ][)][, such that Hamiltonian evolution of each] { } [M] [ H] γ [(][ℓ][)] can be implemented with circuit depth at
most τH. Let



�M



e [i][H] [(][ℓ][)] Vℓ,
ℓ=1



W := V0



where {Vℓ}ℓ [M] =0 [are unitaries with circuit depth][ τ][ℓ][.]
Let p ∈ N, ε ∈ (0, 1) be the precision parameter, τsum = [�][M] ℓ=0 [τ][ℓ][,][ Γ][avg][ =][ �] ℓ [M] =1 [Γ][ℓ][/M] [, and let]
λcomm be defined via (3.12) with m = p⌈log(1/ε)⌉, K = 2⌈log(1/ε)⌉. Suppose there is a symmetric pth order product formula with Υ stages and maximum coefficient amax satisfying amaxΥMλcomm ≥ 1.
Assume the initial state ψ0 can be prepared efficiently, then there is an algorithm (see Algorithm 1)
| ⟩
that, for any observable O, estimates ψ0 W [†] OW ψ0 with an error of at most ε O and a success
⟨ | | ⟩ ∥ ∥
probability of at least 2/3, without using any ancilla qubits. The maximum quantum circuit depth
is - 
          - �1+1/p
O pτHΓavgΥ [2+1][/p][�] amaxMλcomm + τsum,


and the total time complexity is




 - 2+1/p [�] �1+1/p

- pτHΓavgΥ amaxMλcomm + τsum
O
ε [2]




.



Proof. We follow the notation in Lemma 3.3 and ψ0 W [†] OW ψ0 = ψ0 O2M +1 ψ0 is the zero-step⟨ | | ⟩ ⟨ | | ⟩
size limit of the extrapolation. For smamaxΥMλcomm 1/2, Lemma 3.3 bounds the Richardson
≤
extrapolation error as
��⟨ψ0|O ˜2(mM)+1,s0 [|][ψ][0][⟩−⟨][ψ][0][|][O][2][M] [+1][|][ψ][0][⟩] �� ≤ 4∥O∥∥b∥1s2mm [(][a][max][Υ][Mλ][comm][)][2][m][(1+1][/p][)][.] (3.23)


30


By Lemma 2.9, b 1 = O(log m), leading to b 1 = Ω(1), and ε [1][/][2][m] = ε [1][/][(2][p][⌈][log(1][/ε][)][⌉][)] = Ω(1).
∥ ∥ ∥ ∥ [−][1][/][2][m]
Choosing


         -         sm = O b 1 ε [1][/][2][m] (amaxΥMλcomm) [−][1][−][1][/p][�] = O (amaxΥMλcomm) [−][1][−][1][/p] )
∥ ∥ [−][1][/][2][m]

ensures that the extrapolation error is at most ε O /2, also ensuring smamaxΥMλcomm 1/2.
∥ ∥ ≤
Next, we analyze the complexity of estimating



⟨ψ0|O [˜] 2 [(][m] M [)] +1,s0 [|][ψ][0][⟩] [=]



�m

bk ψ0 O [˜] 2M +1,sk ψ0 .
⟨ | | ⟩
k=1



Theusing 1 p-th order staged product formula/(skM ) Trotter steps. Then we apply the unitary evolution P [(][ℓ][)] for H [(][ℓ][)] requires 1/(skM V)0 ∈�NMℓ=1 to allow implementation
ψ0, and measure O. This process employs [P] [(][ℓ][)][(][s][k][M] [)][1][/][(][s][k] [M] [)][V][ℓ] [to]
| ⟩

                   -                   -                   Nrep = O (∥b∥1/ε) [2] log(m) = O [�] 1/ε [2][�]

repetitions. Let f [˜] (sk) denote the average of the measurement outcomes. Hoeffding’s inequality
ensures that f [˜] (sk) estimates


ψ0 O [˜] 2M +1,sk ψ0 (3.24)
⟨ | | ⟩

�up to errorm ε∥O∥/(2∥b∥1) with probability at least 1 − 1/(3m). The union bound guarantees that
k=1 [b][k][ ˜][f] [(][s][k][) estimates][ ⟨][ψ][0][|][O][ ˜] 2 [(][m] M [)] +1,s0 [|][ψ][0][⟩] [with error at most][ ε][∥][O][∥][/][2 and probability at least 2][/][3.]
Since sk = s0/rk with rk ∈ Z, we choose 1/s0 ∈ M N to guarantee that 1/(skM ) ∈ N for
all k ∈ [m]. This allows us to obtain estimates f [˜] (sk) for all k. By definition, r1 = Θ(m [2] ) and
rm = Θ(m). So we should ensure that s0 = smrm = O(m(amaxΥMλcomm) [−][1][−][1][/p] ) and 1/s0 =
Ω(M [1+1][/p] ) = Ω(M ). Thus, for sufficiently large M, we can choose 1/s0 M N to satisfy both
∈
requirements.
The number of Trotter steps of estimating ψ0 O [˜] 2M +1,sk ψ0 is 1/sk. Hence, the total number
⟨ | | ⟩
of Trotter steps is



�m



k=1



Nrep



�m


k=1



1
= Nrep
sk



rk
s0


�m


k=1







m
k/m



.




  -  = O Nrep m [2] log m = O [�]

s0



p [(][a][max][Υ][Mλ][comm][)][1+1][/p]

ε [2]











= O




Nrep



s0



Each Trotter step involves ΓℓΥ Hamiltonian evolutions of Hermitian terms, each implemented with
depth at most τH. Combining these, the total time complexity is




O




- pτHΓavgΥ [2+1][/p] (amaxMλcomm) [1+1][/p] + τsum

ε [2]



,



and the maximum quantum circuit depth is


τHΓavgΥ/s1 + τsum = O [�] (pτHΓavgΥ [2+1][/p] (amaxMλcomm) [1+1][/p] + τsum).


This completes the proof.


31


We now present a variant of Theorem 3.4, which makes use of iterative quantum amplitude
estimation [12] to coherently estimate the expectation value. This increases the maximum quantum
circuit depth but reduces the overall time complexity to O [�] (1/ε). The iterative quantum amplitude
estimation is formally introduced below:


Lemma 3.5 (Iterative Quantum Amplitude Estimation [12, Theorem 1]). Given ε, δ ∈ (0, 1) and
an (n + 1)-qubit unitary W such that



W 0 [n] 0 = a ψ0 0 + √
| ⟩| ⟩ [√] | ⟩| ⟩



1 a ψ1 1,
 - | ⟩| ⟩



where ψ0 are ψ1 and arbitrary n-qubit states, there exists an algorithm that outputs an estimate
| ⟩ | ⟩
of a to within additive error ε with probability at least 1 − δ. The algorithm uses




 1
O



δ




  
1 log(1/ε)

ε [log] δ



��



applications of U and U [†] and requires one ancilla qubit besides the n + 1 qubits required by W .


Now we are in a position to state the theorem formally:



Theorem 3.6 (Interleaved sequences of unitaries and Hamiltonian evolution with Trotter, coherent
estimation). Under the same assumption as in Theorem 3.4, if we further assume O/γ is blockencoded via a unitary UO for some γ satisfying γ = Θ( [�] ∥O∥), then there exists a quantum algorithm
that estimates ψ0 W [†] OW ψ0 with an error of at most ε O and a success probability of at least
⟨ | | ⟩ ∥ ∥
2/3 using two ancilla qubits. The maximum quantum circuit depth and total time complexity are
both - 







O




- pτHΓavgΥ [2+1][/p][�] amaxMλcomm�1+1/p + τsum
ε



.



The number of queries to UO is O [�] (p/ε).


Proof. We use the same sample points as Theorem 3.4 for extrapolation, so the extrapolation error
is bounded by ∥O∥ε/2. For any k ∈ [M ], the Hadamard test circuit produces an amplitude of

        
(1 + ψ0 O [˜] 2M +1,sk ψ0 /γ)/2,
⟨ | | ⟩


using one query to UO and Uψ, and 1/sk Trotter steps. Then we can use the Iterative Quantum
Amplitude Estimation (IQAE) [12] to estimate the amplitude. By Lemma 3.5,




   
b 1 1
∥ ∥

ε∥O∥ [log]



ε∥O∥




= O [�] (1/ε)




   γ b 1
Nrep = O ∥ ∥




  
1 γ b 1

∥ ∥
m [log] ε O



��� γ
= O [�]
ε∥O∥



queries to the Hadamard circuit suffice to estimate the probability to within accuracy ε O /(4γ b 1)
∥ ∥ ∥ ∥
with success probability at least 1 1/(3m), which gives an ε O /(2 b 1)-approximation of
              - ∥ ∥ ∥ ∥
ψ0 O [˜] 2M +1,sk ψ0 . Linearly combining the estimates of ψ0 O [˜] 2M +1,sk ψ0, weighted by bk, yields an
⟨ | | ⟩ ⟨ | | ⟩
ε∥O∥/2-approximation of ⟨ψ0|O [˜] 2 [(][m] M [)] +1,s0 [|][ψ][0][⟩] [with success probability at least 2][/][3. Therefore, the]
total error is bounded by ∥O∥ε and the maximum quantum circuit depth and total time complexity
are both - 







O




- pτHΓavgΥ [2+1][/p][�] amaxMλcomm�1+1/p + τsum
ε



.



32


The number of queries to UO is O [�] (m/ε) = O [�] (p/ε).
Besides the ancilla needed for the block encoding of O by the unitary UO, the Hadamard test
uses one additional ancilla qubit. To implement the reflection around ψ0 in IQAE, a Toffoli gate
| ⟩
is needed, which uses one additional ancilla qubit as the target qubit. The Toffoli gate can be
implemented using O(n [2] ) elementary gates [61] without ancilla qubits, or O(n) elementary gates
with one ancilla qubit [62, Corollary 7.4].


Algorithm 1 Interleaved Hamiltonian evolution with Trotter [Theorems 3.4 and 3.6]

Input: M Hermitian operator H [(][ℓ][)] = [�][Γ] γ=1 [ℓ] [H] γ [(][ℓ][)][.]
An initial state ψ0 and an observable O.
| ⟩
WM := + 1 unitaries V0 �Mℓ=1 [e][i] V [H] [(] 0 [ℓ][)], . . ., V [V][ℓ][.] M .
A p-th order symmetric staged product formula P [(][ℓ][)] for each H [(][ℓ][)] with Υ stages, maximum
coefficient amax satisfying amaxΥMλcomm ≥ 1.
m = p⌈log(1/ε)⌉, K = 2⌈log(1/ε)⌉, λcomm is given via (3.12).
Output: ψ0 W [†] OW ψ0 ε O .
⟨ | | ⟩± ∥ ∥

[−][1][−][1][/p]



1: Choose s0 = O(m(amaxΥMλcomm) [−][1][−][1][/p] ) such that 1/s0 ∈ M N.



2: Compute b1, . . ., bm, s1, . . ., sm via Lemma 2.9.
3: For k = 1, . . ., m
Compute f [˜] (sk) := ψ0 �V0 �Mℓ=1 �†O�V0 �Mℓ=1  - ψ0 on a
quantum computer. ⟨ | [P] [(][ℓ][)][(][s][k][M] [)][1][/][(][s][k] [M] [)][V][ℓ] [P] [(][ℓ][)][(][s][k][M] [)][1][/][(][s][k][M] [)][V][ℓ] | ⟩



4: Output [�][m] k=1 [b][k][ ˜][f] [(][s][k][).]



Finally, Algorithm 1 summarizes the method encompassed in Theorem 3.4 and Theorem 3.6.
The framework introduced here is very general. As mentioned previously, V0 could be a quantum
algorithm that precedes the circuit W . Similarly, W could be used as input to another quantum
algorithm, with circuit VM . This flexibility allows for delaying the measurement of the observable
O (whether coherent or incoherent) until the end of the entire algorithm, of which W may be a
subroutine. In the next section, we develop methods to implement QSVT without block encodings

- the key observation is that it is possible to formulate QSVT as a particular instance of W .
However, the applications of this framework extend beyond QSVT.

### 4 QSVT using higher order Trotterization


In this section, we prove in detail our quantum algorithms to implement QSVT using higher-order
Trotterization. Theorem 3.4 provides a general framework to estimate the expectation values of
observables with respect to the output state of any quantum circuit that is an interleaved sequence
of arbitrary unitaries and Hamiltonian evolution operators. Here, we adapt the framework of Generalized Quantum Signal Processing (GQSP) to our setting. Recall from Sec. 2.3, the basic building
blocks are c0-U and c1-U [†] (see Eq. (2.3)). As U = e [i][H], we can rewrite c0-U = e [i ˜][H][0], c1-U [†] = e [i ˜] H1

with H [˜] 0 = diag(H, 0), H [˜] 1 = diag(0, −H). Thus, the circuit in Lemma 2.5 can be reformulated as
an interleaved sequence of unitaries and Hamiltonian evolution operators — our general framework
in Sec. 3. Indeed, we simply replace Vj = R(θj, φj, γj) ⊗ I, and H [(][j][)] = H, for all j. This completely
eliminates the need for any block encoding access to H and allows us to use Theorem 3.4.


33


Consider any n-qubit Hamiltonian H that can be written as



H =



�L

Hj.
j=1



Here, H can be a sum of local terms, or it can be a linear combination of n-qubit strings of Pauli
operators, i.e., Hj = λjPj. We define λ := [�][L] j=1
and observable O, we can estimate the expectation value [∥][H][j][∥][. Thus, given any such][ H][, initial state][ |][ψ][0][⟩][,]

ψ0 f (H) [†] Of (H) ψ0,
⟨ | | ⟩

to arbitrary accuracy, without using any block encodings and while using only a single ancilla
qubit. Naturally, this method can implement any function f (x) that can be approximated by
a Laurent polynomial P (e [ix] ) (bounded in T). We simply use the p-th order Trotter method to
implement (controlled Hamiltonian evolution). Formally, we have the following theorem, where we
have considered 2k-order Suzuki Trotter formula:


Theorem 4.1 (Generalized QSP with Trotter, incoherent estimation). Given B (0, π], let H =

L ∈
j=1 [H][j][ be a Hermitian decomposition of][ H][ such that][ H][j][ is local and][ ∥][H][∥≤] [B][. Let][ k][ ∈] [N][,]
ε ∈ (0, 1/2) be the precision parameter, and f (x) be a function on [−B, B]. Suppose that there
exists a degree-d Laurent polynomial P (z) = [�][d] j=−d [a][j][z][j][ satisfying][ |][f] [(][x][)][ −] [P] [(][e][i][x][)][| ≤] [ε/][6][ for all]
x [ B, B] and P (z) 1 for all z = 1. Assume the initial state ψ0 can be prepared efficiently,
∈ - | | ≤ | | | ⟩
then there exists a quantum algorithm that, for any observable O, estimates ψ0 f (H) [†] Of (H) ψ0
⟨ | | ⟩
with an error of at most ε∥O∥ and a success probability of at least 2/3, using one ancilla qubit. The
maximum quantum circuit depth is

             
                       - �1+1/2k [�]

             O (25/3) [k] k [2] L dλcomm, (4.1)



and the total time complexity is

            
             -             - �1+1/2k 2 [�]
O (25/3) [k] k [2] L dλcomm /ε, (4.2)


where λcomm defined in Eq. (3.12) for all H [(][ℓ][)] = H scales with the nested commutators of H.

Proof. Since ∥H∥≤ B and |f (x)−P (e [i][x] )| ≤ ε/2 for all x ∈ [−B, B], we have ∥f (H)−P (e [i][H] )∥≤ ε/6.
The operator norm of P (e [i][H] ) is upper bounded by 1 since |P (z)| ≤ 1 for |z| = 1. From Theorem B.2,
we have
ψ0 P (e [i][H] ) [†] OP (e [i][H] ) ψ0 ψ0 f (H) [†] Of (H) ψ0 ε O /2.
|⟨ | | ⟩−⟨ | | ⟩| ≤ ∥ ∥



Therefore, it suffices to estimate ψ0 P (e [i][H] ) [†] OP (e [i][H] ) ψ0 to within ε O /2.
⟨ | | ⟩ ∥ ∥
By Theorem 2.5, there exist Θ = (θj)j, Φ = (φj)j R [2][d][+1], λ R such that
∈ ∈

  - iH  -  - �d  - �d  P (e )
∗ = R(θd+j, φd+j, 0) c1-e [−][i][H][���] R(θj, φj, 0) c0-e [i][H]

                                    -                                    
∗ ∗ j=1 j=1




- - �d
=




R(θj, φj, 0) c0-e [i][H][��] R(θ0, φ0, λ).
           -           


j=1




- �d
R(θd+j, φd+j, 0) c1-e [−][i][H][���]
               


j=1



Since c0-e [i][H] = e [i(][|][0][⟩⟨][0][|⊗][H][)] and c1-e [−][i][H] = e [i(][−|][1][⟩⟨][1][|⊗][H][)] are Hamiltonian evolution operators, the
above GQSP circuit can be regarded as a interleaved sequence of Pauli rotations and Hamiltonian
evolutions. The LHS of the above equation is an (n + 1)-qubit unitary.
We use the 2k-th order Trotter-Suzuki formula S2k(t) to approximately implement the Hamiltonian evolution. The formula S2k(t) has Υ = 2 · 5 [k][−][1] stages and maximum parameter amax = 2k/3 [k]

[59]. Note that each Pauli rotation operator can be implemented using O [�] (1) gates. This implies
that τH and τsum in Theorem 3.4 are O [�] (1) and O [�] (d), respectively. Simplifying the complexity in
Theorem 3.4 for S2k(t) gives the claimed results.


34


We only consider Hamiltonians with norms bounded by ∥H∥≤ π in Theorem 4.1 for simplicity.
This condition ensures that the spectrum of H lies within a single period of P (e [i][x] ). However, this
method is not limited to small-norm Hamiltonians. For a general Hamiltonian H with ∥H∥ - π,
we employ a rescaling strategy. Let λcomm be the commutator bound for H. We define a rescaled
Hamiltonian H [′] = H/∥H∥, a corresponding rescaled function g(x) = f (x∥H∥), and then apply
our algorithm to H [′] and g(x). This rescaling has two competing effects on the complexity. First,
the commutator bound for H [′] becomes λ [′] comm [=][ λ][comm][/][∥][H][∥][. Second, the degree of the Laurent]
polynomial required to approximate the more rapidly oscillating function g(x) increases, typically
scaling linearly with ∥H∥. Let d be the degree for approximating the original function f (x); the new
degree d [′] for g(x) is proportional to d ·∥H∥ (see Appendix C for examples). The overall complexity
of estimating ψ0 f (H) [†] Of (H) ψ0 scales with the product of these terms. By applying Theorem
⟨ | | ⟩
4.1 to H [′] and g(x), the complexity scales as

(d [′] λ [′] comm [)][1+1][/][2][k][ ∝] [((][d][∥][H][∥][)(][λ][comm][/][∥][H][∥][))][1+1][/][2][k][ = (][dλ][comm][)][1+1][/][2][k][.]


Thus, the ∥H∥ dependence cancels out, and we recover the same complexity scaling for any general
H. The comparison of the cost of our method with standard QSVT can be seen in Table 1.
Often, for most applications, we are interested in estimating the expectation value of the observable O with respect to the normalized state


f (H) ψ0
ψ = | ⟩
| ⟩ f (H) ψ0
∥ | ⟩∥ [.]

Indeed, for any observable O, we can estimate ⟨ψ|O|ψ⟩ by using fixed point amplitude amplification

[31] to obtain the normalized state |ψ⟩, and then measure O (incoherently). Note that with this
modification, we obtain a new circuit that is an interleaved sequence of unitaries and Hamiltonian
evolution operators. Thus, with only one additional ancilla qubit, we can estimate the desired
expectation value. Formally, we have the following theorem:


Theorem 4.2 (Generalized QSP with Trotter and amplitude amplification). Given B ∈ (0, π],
let H = [�][L] j=1 [H][j][ be a Hermitian decomposition of][ H][ such that][ H][j][ is local and][ ∥][H][∥≤] [B][. Let]
k ∈ N, ε ∈ (0, 1/2) be the precision parameter, and f (x) be a function on [−B, B]. Let |ψ⟩ =
f (H) ψ0 / f (H) ψ0 and assume η f (H) ψ0 . Suppose that there exists a degree-d Laurent
| ⟩ ∥ | ⟩∥ ≤∥ | ⟩∥
polynomial P (z) = [�][d] j=−d [a][j][z][j][ satisfying][ |][f] [(][x][)][−][P] [(][e][i][x][)][| ≤] [ε/][(12][η][)][ for all][ x][ ∈] [[][−][B, B][]][ and][ |][P] [(][z][)][| ≤]
1 for all z = 1. Assume the initial state ψ0 can be prepared efficiently, then there exists a quantum
| | | ⟩
algorithm that, for any observable O, estimates ⟨ψ|O|ψ⟩ with an error of at most ε∥O∥ and a success
probability of at least 2/3 using two ancilla qubits. The maximum quantum circuit depth is

             
                      - �1+1/2k [�]

             O (25/3) [k] k [2] L dλcomm/η, (4.3)


and the total time complexity is

            
            -             - �1+1/2k 2 [�]
O (25/3) [k] k [2] L dλcomm/η /ε, (4.4)


λcomm defined in Eq. (3.12) for all H [(][ℓ][)] = H scales with the nested commutators of H.


Proof. Suppose the initial state ψ0 is a state of n qubits. Since H B and f (x) P (e [i][x] )
| ⟩ ∥ ∥≤ |                      - | ≤
ε/(12η) for all x [ B, B], we have f (H) P (e [i][H] ) ε/(12η). Let the normalized P (e [i][H] ) ψ0
∈        - ∥        - ∥≤ | ⟩
be

ψ [˜] = P (e [i][H] )|ψ0⟩
| ⟩ P (e [i][H] ) ψ0
∥ | ⟩∥ [.]


35


The distance between the two normalized states is



∥|ψ⟩−|ψ [˜] ⟩∥ =



f (H) ψ0
| ⟩
����� f (H) ψ0 P (e [i][H] ψ0
∥ | ⟩∥ [−] ∥ [P] [(][e][i][H] [)] | [|][ψ][0] ⟩∥ [⟩]



2 f (H) ψ0 P (eiH ) ψ0
∥ | ⟩− | ⟩∥
����� ≤ η



P (e ) ψ0
| ⟩∥

η ≤ 6 [ε]



6 [.]



From Theorem B.2, we have
��� ψ˜ OP (eiH) ψ ˜ ψ O ψ ��� ε O /2.
⟨ | | ⟩−⟨ | | ⟩ ≤ ∥ ∥

Therefore, it suffices to estimate ⟨ψ [˜] |O|ψ [˜] ⟩ to within ε∥O∥/2.
By Theorem 2.5, there exists a length-(2d + 1) interleaved circuit sequence comprising of single
qubit U (2) rotations and Hamiltonian evolution, UP, such that


( 0 In)UP 0 ψ0 = P (e [i][H] ) ψ0 .
⟨ | ⊗ | ⟩| ⟩ | ⟩

Using fixed-point amplitude amplification from [31], we can prepare an ε/2-approximation of |ψ [˜] ⟩
using an interleaved sequence of operations


UP (I2 Uψ0)e [i][α][j] [|][0][n][+1][⟩⟨][0][n][+1][|] (I2 Uψ [†] 0 [)][U] P [ †] and e [i][β][j][|][0][⟩⟨][0][|⊗][I][n],
⊗ ⊗

for O(log(1/ε)/η) values of αj, βj R.
∈
The resulting quantum circuit is still an interleaved Hamiltonian sequence with length


O(d log(1/ε)/η),


as UP is a length 2d + 1 interleaved Hamiltonian evolution sequence.
Therefore, we can use Algorithm 1 to estimate ⟨ψ|O|ψ⟩ to within error ε∥O∥, and simplifying
the complexity in Theorem 4.1 yields the results. To implement


e [i][β][j][|][0][⟩⟨][0][|⊗][I][n] and e [i][α][j] [|][0][n][+1][⟩⟨][0][n][+1][|],


we can reuse one additional ancilla qubit as the target qubit for all the (n +2)-qubit Toffoli gates by
uncomputing the target qubit after each reflection. Thus, we use only two ancilla qubits overall.


Finally, it is also possible to estimate the expectation value coherently using quantum amplitude
estimation. So, analogous to Theorem 3.6, we obtain


Theorem 4.3 (Generalized QSP with Trotter, coherent estimation). Under the same assumption
as in Theorem 4.1, if we further assume O/γ is block-encoded via a unitary UO for some γ satisfying
γ = Θ( O ), there exists a quantum algorithm that estimates ψ0 f (H) [†] Of (H) ψ0 with an error
∥ ∥ ⟨ | | ⟩
of at most ε∥O∥ and a success probability of at least 2/3 using three ancilla qubits. The time
complexity and maximum quantum circuit depth are both

             -             
             -             - �1+1/2k
O (25/3) [k] k [2] L dλcomm /ε,


λcomm defined in Eq. (3.12) for all H [(][ℓ][)] = H scales with the nested commutators of H. The number
of queries to UO and its inverse is O [�] (k/ε).


Proof. Choosing the symmetric staged product formula (t) as S2k(t) and simplifying the comP
plexity in Theorem 3.6 gives the claimed results.


36


So, overall, our method allows us to implement functions that can be approximated by a Laurent
polynomial in e [ikx] . This naturally raises the question: Which functions can be efficiently approximated in this form? In Appendix C, we show that many commonly used functions—including the
shifted sign function, rectangle function, inverse function, and exponential function—can indeed be
approximated by Laurent polynomials (bounded in T) in e [i][kx] for some constant k.
In contrast, standard QSVT implements functions expressed as polynomials in x that are
bounded on [−1, 1]. We identify precise conditions under which such a polynomial Q(x) can be
approximated by a Laurent polynomial in e [i][kx], P (e [i][kx] ), bounded in T, for some constant k, with
the degree of P scaling linearly with the degree of Q.
In particular, we prove that if a function f (x) can be approximated by a d-degree polynomial Q
on [−1, 1] that remains bounded by 1 on the extended interval [−1 − δ, 1 + δ] for some δ ∈ (0, 1/2],
then there exists a Laurent polynomial in e [i][πx/][(2(1+][δ][))], P (e [i][πx/][(2(1+][δ][))] ), of degree O [�] (d/δ [2] ), that
approximates f (x) on [−1, 1] and is bounded by 1 on the complex unit circle T. Formally, we prove
the following:

Proposition 4.4. Let ε ∈ (0, 1) and δ ∈ (0, 1/2]. Suppose f : R → R is approximated by a degree-d
polynomial Q satisfying



|f (x) − Q(x)| ≤ ε/2 for all x ∈ [−1, 1],



|Q(x)| ≤ 1 for all x ∈ [−1 − δ, 1 + δ].



Then there exists an Laurent polynomial P (z) of deg(P ) = O(d log(d/ε)/δ [2] ) such that



|P (z)| ≤ 1 for all z ∈ T,



|P (e [i][πx/][(2(1+][δ][))] ) − f (x)| ≤ ε for all x ∈ [−1, 1].



Proof. Notice that for any polynomial P [˜] (y) in y = sin(πx/(2(1 + δ))), we can substitute




 πx
sin
2(1 + δ)




= [1]



2i




e [i][πx/][(2(1+][δ][))] e [−][i][πx/][(2(1+][δ][))][�],

    


into the polynomial to obtain a Laurent polynomial P (z) in z = e [i][πx/][(2(1+][δ][))], of the same degree
as P [˜] . Moreover, |P (z)| ≤ 1 for all z ∈ T is equivalent to |P [˜] (y)| ≤ 1 for all y ∈ [−1, 1]. Following
the proof of [30, Proposition B5], we can construct such a polynomial P [˜] satisfying



|P [˜] (y)| ≤ 1 for all y ∈ [−1, 1],

|P [˜] (sin(πx/(2(1 + δ)))) − f (x)| ≤ ε for all x ∈ [−1, 1],

of degree O(d log(d/ε)/δ [2] ). This yields the desired Laurent polynomial P (z).


By imposing stronger smoothness conditions on the polynomial Q, and after an appropriate
rescaling, the following result from [63] demonstrates that a quadratic improvement in the degree
dependence on δ can be achieved.

Proposition 4.5 (Lemma 37 of [63], rescaled version). Let ε, δ ∈ (0, 1). Suppose f (x): R → R
admits a polynomial approximation Q(x) = [�][K] k=0 [a][k][x][k][ satisfying]

|f (x) − Q(x)| ≤ ε/2 for all x ∈ [−1, 1].

Let B = [�][K] k=0
such that [|][a][k][|][(1+][δ][)][k][. Then there exists a Laurent polynomial][ P] [(][z][)][ of][ deg(][P] [) =][ O][(log(][B/ε][)][/δ][)]

|P (z)| ≤ B for all z ∈ T,

|P (e [i][πx/][(2(1+][δ][))] ) − f (x)| ≤ ε for all x ∈ [−1, 1].


37


Together, Propositions 4.4 and 4.5 establish a formal connection between standard QSVT and
our Laurent polynomial-based approach, highlighting how bounded polynomial transformations in
the QSVT framework can be translated into our setting.
Table 2 presents a detailed comparison between the complexities of our method and standard
QSVT for estimating the expectation value of an observable O with respect to the normalized
quantum state

f (H) ψ0
ψ = | ⟩
| ⟩ f (H) ψ0
∥ | ⟩∥ [.]

Both frameworks offer multiple strategies to perform this estimation. Notably, our approach
achieves comparable asymptotic complexity to standard QSVT while avoiding the need for blockencodings of H, and requiring only a constant number of ancilla qubits. Below, we outline the
complexity of each approach (assuming an appropriate choice of a large enough k) and highlight
its key resource trade-offs:


  - Direct estimation without amplitude amplification or estimation: This approach
runs the interleaved circuit composed of controlled Hamiltonian evolutions and single-qubit
rotations, followed by measurement of the observable O. The circuit depth per coherent run is
determined by Theorem 4.1, and the number of independent classical repetitions is O [�] (η [−][2] ε [−][2] ).
Both the depth and total time complexity nearly match standard QSVT. However, unlike
standard QSVT, which requires ⌈log2 L⌉ +1 ancilla qubits (and complicated controlled logic),
this method uses only a single ancilla qubit. This makes it especially appealing for early
fault-tolerant quantum devices, where running many shallow-depth circuits is more practical
than maintaining deep coherence.


  - Using fixed-point amplitude amplification: This variant composes the fixed-point amplitude amplification circuit with the one described above. The per-run circuit depth is given by
Theorem 4.2, and the number of repetitions reduces to O [�] (ε [−][2] ). While the complexity nearly
matches standard QSVT, our method again requires only two ancilla qubits, a significant
reduction compared to the logarithmic ancilla overhead in standard QSVT.


  - Iterative quantum amplitude estimation: This approach, formalized in Theorem 4.3,
further reduces the number of repetitions by using coherent amplitude estimation, at the cost
of increased circuit depth. Despite the deeper circuits, this method offers a reduced overall
time complexity. As before, the ancilla overhead of our method remains minimal (three),
offering similar advantages over standard QSVT.


Thus, we obtain a simple and resource-efficient method for implementing polynomial transformations, while retaining near-optimal complexity. In the following section (Sec. 5), we apply these
results to both of our target applications.

### 5 Applications


5.1 Quantum linear systems via discrete adiabatic theorem without block encodings


The quantum linear systems algorithm can be stated as follows: Consider a Hermitian matrix
A ∈ C [N] [×][N] with ∥A∥ = 1, whose eigenvalues lie in the interval [−1, −1/κ]∪[1/κ, 1]. Here, ∥A [−][1] ∥ = κ
is the condition number of A. Given access to a procedure that prepares an initial state |b⟩, the
quantum linear systems algorithm prepares the quantum state |x⟩ = A [−][1] |b⟩/∥A [−][1] |b⟩∥. In many


38


applications, simply preparing the state |x⟩ may not be sufficient. Instead, one is often interested
in extracting useful information from this state, such as estimating the expectation value of an
observable O, i.e., ⟨x|O|x⟩.
Since the first quantum algorithm for this problem by Harrow, Hassidim, and Lloyd [64], the
quantum linear systems algorithm has been widely studied. The complexity of this algorithm has
been progressively improved through a series of results based on quantum linear algebra techniques

[1, 4, 15, 36, 65]. The disadvantage of these algorithms is that they require a block encoding access
to A and achieve an optimal linear dependence on the condition number κ only with the help of
complicated subroutines such as variable time amplitude amplification (VTAA) [14]. More recently,
adiabatic-inspired approaches have also been explored [18, 38], which have managed to optimally
solve this problem [13], without the use of VTAA. However, these techniques continue to assume
block encoding access to A.
Among these, the algorithm of Costa et al. [13] achieves optimal query complexity. More
precisely, given access to a block encoding of A, the algorithm makes use of the discrete adiabatic
theorem [66] to prepare a state that is ε-close to |x⟩, with a query complexity of O(κ log(1/ε)).
In this work, we simplify this algorithm by eliminating the need for block encoding and reducing
the ancilla qubit requirement to a constant. Despite this, the complexity has a near-optimal (quasilinear) dependence on κ and a polylogarithmic dependence on the inverse precision. We achieve
this by demonstrating that the simulation of the discretized adiabatic theorem can be seen as a
particular instance of the interleaved sequence circuit described in Sec. 3. Moreover, unlike [13], we
do not require the construction of a qubitized quantum walk operator. We achieve near-optimal
complexity by simply using higher-order Trotterization. We begin by providing a brief overview of
discrete adiabatic computation, stating a key result from [13], which we make use of.


5.1.1 A brief overview of the discrete adiabatic theorem


In adiabatic quantum computation [67,68], one considers a time-dependent Hamiltonian H(s) with
s ∈ [0, 1], where typically, the ground state of H(0) is easy to prepare while the ground state of
H(1) encodes the solution to the problem. The system begins in the ground state of H(0), and
slowly (adiabatically) evolves, over a sufficiently long time T, such that by the end of the evolution,
the system remains ε-close to the ground state of H(1). The precise meaning of “a sufficiently long
time T ” is given by the rigorous version of the adiabatic theorem [69–71]. Informally, if the time
of evolution T is larger than the inverse of the minimum spectral gap of H(s) for any s ∈ [0, 1],
the system will remain in the instantaneous ground state throughout the adiabatic evolution. The
adiabatic theorem holds for any eigenstate of the underlying Hamiltonian, with the key parameter
being the energy gap between the eigenstate and the next closest energy level.
Discrete adiabatic computation (DAC), introduced by [66], is a discretization of the continuoustime adiabatic evolution. This is useful for simulating any adiabatic quantum computation in the
circuit model. In the DAC framework, there are T unitary operators


B(0/T ), B(1/T ), . . ., B((T − 1)/T ),


where each B(j/T ) approximates the ideal (continuous-time) adiabatic evolution at s = j/T .
Overall, define the unitary


sT�−1



U (s) =



B(m/T ),

m=0


39


with U (0) = I. If UA is the ideal adiabatic evolution for some time T, the DAC framework provides
a concrete bound on UA U (s) . In order to state this difference, we define a series of useful
∥           - ∥
quantities. First, define the k-th difference of B(s) as




        D [(][k][)] B(s) := D [(][k][−][1)] B s + [1]





 - D [(][k][−][1)] B(s),




      D [(1)] B(s) := B s + [1]

T





 - B(s),



T



where k N. Then, assume that there exist functions c1(s), c2(s) such that D [(1)], D [(2)] are bounded
∈
as (see [37])




[(][s][)]

, D [(2)] B(s)
T ∥ ∥≤ [c][2] T [(][2][s][)]



D [(1)] B(s)
∥ ∥≤ [c][1] T [(][s][)]



(5.1)
T [2]



for all T > 0. Also define ˆck(s) as


cˆk(s) := max (5.2)
s [′] ∈{s−1/T,s,s+1/T }∩[0,1−k/T ] [c][k][(][s][′][)]


for k = 1, 2, which takes the neighboring steps into account.
Suppose eigenvalues of B(s) are partitioned into two parts: the eigenvalues of interest σΠ(s) and
the remaining ones σ (s). Define Π(s) to be the projection onto the eigenspace of B(s) associated
Π�
with the eigenvalues in σΠ(s). Since B(s) is unitary, all its eigenvalues lie on the unit circle, which
allows us to obtain the gaps between the different eigenvalues. For a non-negative integer k, define
∆k(s) as the minimum angular distance between arcs σΠ [(][k][)] and σΠ [(][k][)][, which satisfy]

                                 


�k

σ (s + l/T ).
Π�
l=0



σΠ [(][k][)]
⊇



�k

σΠ(s + l/T ), σ [(][k][)]
l=0 Π� ⊇



Define the gap



∆(s) =




∆2(s), 0 ≤ s ≤ 1 − 2/T

∆1(s), s = 1 − 1/T

∆0(s), s = 1



(5.3)



to be the minimum gap among eigenvalues in the three successive steps, except at the boundary
cases. Finally, define

ˇ∆(s) = min (5.4)
s [′] ∈{s−1/T,s,s+1/T }∩[0,1] [∆(][s][′][)][,]


as the minimum gap of neighboring steps. As mentioned previously, if the adiabatic evolution
operator corresponds to UA(s), the discrete adiabatic theorem can be formally stated as follows:

Theorem 5.1 (Theorem 3 of [13]). Suppose that the operators W (s) satisfy D [(][k][)] W (s) ck(s)/T [k]
∥ ∥≤

for k = 1, 2, as in Eq. (5.1), and T maxs∈[0,1] 4ˆc1(s)/∆( [ˇ] s) . Then, for any time s such that
≥ { }
sT ∈ N, we have



T [12ˆ] ∆(0) [ˇ][c][1][(0)][2][ + 12ˆ] T ∆( [ˇ][c][1][(] s [s] ) [)][2]



T ∆( [ˇ] s) [+ 305]



sT�−1



U (s) UA(s)
∥ - ∥≤ T [12ˆ] ∆(0) [ˇ][c][1][(0)][2]




[c][1][(][s][)]

T ∆( [ˇ] s) [2][ + 6ˆ] T [c] ∆( [ˇ][1][(][s] s [)]



n=1



cˆ1(n/T ) [2]

T [2][ ˇ] ∆(n/T ) [3]



sT�−1


n=1



cˆ2(n/T )
T [2][ ˇ] ∆(n/T ) [2][,]



+ 44



sT�−1


n=0



cˆ1(n/T ) [2]

T [2][ ˇ] ∆(n/T ) [2][ + 32]



where ˆck(s) and ∆( [ˇ] s) are defined in Eqs. (5.2) and (5.4).


40


5.1.2 The adiabatic Hamiltonian for quantum linear systems


All quantum linear systems algorithm inspired by the adiabatic quantum computation framework
first construct the adiabatic Hamiltonian H(s), given A ∈ C [N] [×][N] [13, 18, 37]. Indeed, in all these
methods, the adiabatic Hamiltonian H(s) is defined as




    -    H(s) = 0 A(f (s))Qb, (5.5)
QbA(f (s)) 0



where




    -    (1 f )I fA
A(f ) := fA [†] −(1 − f )I



and Qb := I2N −|0, b⟩⟨0, b| is a projection, and







κ
f (s) :=
κ − 1




1
1
 - (1 + s( [√] κ 1)) [2]
       


is a schedule function with f (0) = 0 and f (1) = 1. Then |0, 0, b⟩ is a zero-eigenstate of H(0) and
|0, 1, x⟩ is a zero-eigenstate of H(1), where

A [−][1] b
x = | ⟩
| ⟩ A [−][1] b
∥ | ⟩∥ [,]

is the solution to the quantum linear systems.
By choosing σΠ = {1} and σΠ� to be the remaining eigenvalues, the ideal adiabatic evolution
with even steps takes the state the 0-eigenstate of H(0) (i.e., |0, 0, b⟩) to the 0-eigenstate of H(1)
(i.e., |0, 1, x⟩), which encodes the solution.
In [13], the authors assume access to a block encoding of A. Using this, they construct a block
encoding of H(s), and subsequently, a qubitized quantum walk operator, which corresponds to
B(s) in the previous subsection. Furthermore, they prove that these quantum walk operators B(s)
satisfy the smoothness condition in Eq. (5.1) with


c1(s) = 2T (f (s + 1/T ) f (s)) (5.6)
                         

and



c2(s) =




2 maxτ ∈{s,s+1/T,s+2/T }(2 f [′] (τ ) + f [′′] (τ ) ), 0 s 1 2/T,
| | [2] | | ≤ ≤                     - (5.7)
2 maxτ ∈{s,s+1/T }(2 f [′] (τ ) + f [′′] (τ ) ), s = 1 1/T,
| | [2] | |                 


and the gap condition in Eq. (5.4) with



ˇ∆(s) =




(1 f (s + 3/T ) + f (s + 3/T )/κ), 0 s 1 3/T,
  - ≤ ≤  - (5.8)
1/κ, s = 1, 1 − 2/T, 1 − 1/T.



Finally, by Theorem 5.1, [13] shows that the error of the adiabatic evolution can be bounded as




   - [√]

[κ] κ

T [+][ O] T



U (s) UA(s) 44864 [κ]
∥ - ∥≤ T



T




(5.9)



for T ≥ max(κ, 39 [√] κ).



41


5.1.3 Our algorithm


In this work, we consider B(s) = e [i][H][(][s][)] instead of the quantum walk operators, which is the first
major simplification. Suppose there exists a procedure Ub to prepare the state |0, 0, b⟩, then by
choosing T = O(κ), we will show that applying


B(0/T ), B(1/T ), . . ., B(1 − 1/T )

to the initial state |0, 0, b⟩ yields a constant approximation of the state |0, 1, x⟩. Thus far, we simply
have a sequence of Hamiltonian evolutions with different (time-dependent) Hamiltonians. This is
a particular instance of the circuit W in Sec. 3, with H [(][j][)] = H((j − 1)/T ) and Vj = I.
Then, we use the framework in Sec. 4 to approximate the eigenstate filter polynomial of [38] by
a Laurent polynomial in e [i][x] . This projects the aforementioned output state onto the zero-eigenstate
|0, 1, x⟩ of H(1). Overall, the entire quantum circuit incorporates Hamiltonian evolution operators
and Pauli rotations, which is again an interleaved sequence circuit W . So, we can use Algorithm 1
to estimate ⟨x|O|x⟩. Before proving our result formally, let us assume that we have an n-qubit
operator A that can be expressed as a linear combination of strings of Pauli operators. That is,



A =



�L

λjPj, (5.10)
j=1



where Pj I, X, Y, Z, and λ = [�] j
is a sum of local terms that are easy to simulate. Indeed, any 2 ∈{ } [⊗][n] [|][λ][j][|][. Alternatively, one could also consider any][n] dimensional operator can be [ A][ that]
expressed in this form. The first advantage of this is that each term Pj is now efficiently simulable
allowing us to use near-term Hamiltonian simulation techniques for solving this problem. The other
advantage is that (as discussed previously) A naturally has this form in physically relevant settings
(for instance, Hamiltonians for a wide range of physical systems). This is particularly relevant
in scientific computation, where problems involving the inversion of operators of this form, are
ubiquitous. This includes Green’s function estimation [39,72], solving linear and partial differential
equations [35, 73–75], and processing eigenvalues of non-Hermitian systems [65].
It can be shown that if A can be expressed as a linear combination of Pauli operators, then
H(s) can be decomposed into a sum of Hermitian terms, each of which generates a Hamiltonian
evolution that can be implemented using O [�] (1) time and queries. To handle complex coefficients λj,
let us define the operator Qj := (Re(λj)X − Im(λj)Y )/|λj|, which is both Hermitian and unitary.
Indeed, for any f ∈ [0, 1], A(f ) can be decomposed as




- |λj|f (s)Qj ⊗ Pj + λj(1 − f (s))Z ⊗ I .



A(f ) =



�L


j=1



Then for any s ∈ [0, 1], H(s) admits the decomposition




- |λj|f (s)X ⊗ Qj ⊗ Pj + λj(1 − f (s))X ⊗ Z ⊗ I



H(s) =



�L


j=1









�L 
λj f (s) 0 (Qj ⊗ Pj)|0, b⟩⟨0, b|
| | 0, b 0, b (Qj Pj) 0
j=1 | ⟩⟨ | ⊗



�L



�L 
0 (Z I) 0, b 0, b
λj(1 − f (s)) 0, b 0, b (Z I) ⊗ |0 ⟩⟨ |
j=1 | ⟩⟨ | ⊗




(5.11)


. (5.12)



�L



42


We shall demonstrate that e [i][H][(][s][)] can be efficiently implemented using (higher-order) Trotterization. Formally, we have the following theorem, using which we prove both the correctness and
the complexity of our algorithm:


Theorem 5.2. Let Ax = b be a system of linear equations, where A is an N by N matrix with
∥A∥ = 1 and ∥A [−][1] ∥ = κ, and let ε ∈ (0, 1/2) be the precision parameter. Given a unitary oracle
Ub that prepares the state |b⟩ and a Pauli decomposition of A = [�][L] j=1 [λ][j][P][j][, Algorithm][ 1][, for any]
observable O, estimates
⟨x|O|x⟩,

to within an additive error of ε O, using only log(N ) + 4 qubits. Let λ = [�][L] j=1
∥ ∥ [|][λ][k][|][. Then the]

maximum quantum circuit depth is O [�] (L(λκ) [1+][o][(1)] ), while the total time complexity and the number
of queries to Ub and Ub [†] [are][ �][O][(][L][(][λκ][)][1+][o][(1)][/ε][2][)][.]
If we further assume O/γ is block-encoded via a unitary UO for some γ satisfying γ = Θ(∥O∥),
the maximum quantum circuit depth, total time complexity, and the number of queries to Ub and
Ub [†] [are][ �][O][(][L][(][λκ][)][1+][o][(1)][/ε][)][. The number of queries to][ U][O][ is][ �][O][(1][/ε][)][. Aside from the ancillas used in]
the block encoding of O, we need one additional ancilla qubit.


Proof. We first prove the correctness and then estimate the complexity of our algorithm.


Correctness: As mentioned previously, we simply run Algorithm 1, as the entire algorithm is
a particular instance of the interleaved sequence W . We can divide the analysis into two parts. For
the first part, we consider B(s) = e [i][H][(][s][)], and implement the unitary


T�−1



U =



B(j/T ).

j=0



The 0-eigenstates of H(s) are now translated to the 1-eigenstates of B(s). So |0, 0, b⟩ is an 1eigenstate of B(0) and |0, 1, x⟩ is an 1-eigenstate of B(1). Although there is another zero eigenstate
|1, 0, b⟩ of H(0) and H(1), it is orthogonal to the eigenstates of interest |0, 0, b⟩ and |0, 1, x⟩, and
the ideal adiabatic evolution operator UA(s) still maps 0, 0, b to 0, 1, x .
| ⟩ | ⟩
Now, we bound the adiabatic error by showing that the smooth parameters c1(s), c2(s) and the
gap parameter ∆( [ˇ] s) of our Hamiltonian evolution operators W (s) have the same asymptotic scaling
as the quantum walk operators considered in [13]. The quantum walk operators have eigenvalues
scaling as e [±][i arcsin(][H][(][s][))] while in our case, the Hamiltonian evolution operators are e [i][H][(][s][)] . The
eigenvalue gap of arcsin(H) and H around zero are asymptotically the same, so the gap parameter
ˇ∆(s) is asymptotically the same for the B(s). By applying the variation-of-parameters formula,
the derivative of the Hamiltonian evolution operator B(s) = e [i][H][(][s][)] is

              - 1



e [i][uH][(][s][)][ d][H][(][s][)]
0 ds



e [i(1][−][u][)][H][(][s][)] du
ds



whose norm is bounded by

dH(s)
����



df



��f ′(s)�� dA(f )
���� ����
≤ df



��f ′(s)�� √
����
≤



ds



dH(f )
=
���� ����



2 ��f ′(s)��,



where the second inequality follows from

            dA(f )
���



df



�† dA(f )



2
��� = 1 + ∥A∥ = 2.



df



43


The second derivative of H(s) can be bounded by √2|f [′′] (s)| in the same way.

We can bound the difference in B(s) by




          - s+1/T
∥B(s + 1/T ) − B(s)∥≤ s



de [i][H][(][τ] [)]
����� dτ



dτ
�����



s




 - s+1/T
2



√
≤

= √



��f ′(τ )�� dτ



s



2 (f (s + 1/T ) − f (s)),



where the equality follows from the fact that f (s) is a monotonically increasing function. Therefore,
we can take
c1(s) = √2T (f (s + 1/T ) f (s))

                         
to satisfy the smoothness condition. The norm of the second derivative of W (s) is bounded by



(s) e [i(1][−][u][)][H][(][s][)] + eiuH(s) d2H(s)

����
ds ����� ds [2]



ds



iuH(s) dH(s)
e
����� ds



(s) de [i(1][−][u][)][H][(][s][)]

ds ds




- 1



de [i][uH][(][s][)]
����� ds



dH(s)
ds ds



du
�����



H(s)

e [i(1][−][u][)][H][(][s][)] +
����
ds [2]



0




 - 1
≤ 0



01(2u|f [′] (s)| [2] + √



= 2|f [′] (s)| [2] + √



2|f [′′] (s)| + 2(1 − u)|f [′] (s)| [2] ) du



2|f [′′] (s)|.



To bound the second difference of B(s), we use Taylor’s theorem to write



∥B(s + 2/T ) − 2B(s + 1/T ) + B(s)∥




  s+2/T
= ���




             
s+2/T s+1/T

s+1/T (s + 2/T − τ )B [′′] (τ )dτ + s



s+1/T

(τ s)B [′′] (τ )dτ ���
s 


max

≤ T [1][2] τ ∈[s,s+2/T ]



�� ′′ ��
B (τ )



max √

≤ T [1][2] τ ∈{s,s+1/T,s+2/T } [(2][|][f][ ′][(][τ] [)][|][2][ +]



2|f [′′] (τ )|),



where the last inequality follows from the fact that |f [′] (τ )| and |f [′′] (τ )| are monotonically decreasing
functions. So, we can set



2 ��f ′′(τ )���,



c2(s) = max
τ ∈{s,s+1/T,s+2/T }




2
2 ��f ′(τ )�� + √



to satisfy the smoothness condition. In conclusion, we choose asymptotically the same smooth parameters c1(s), c2(s) and the gap parameter ∆( [ˇ] s) as the quantum walk operators in [13]. Therefore,
by Theorem 5.1, the error in the adiabatic evolution is bounded as


U (s) UA(s) = O(κ/T )
∥                - ∥

in the same way as Eq. (5.9). We can choose T = O(κ) to ensure that U (1)|0, 0, b⟩ has constant
overlap with the target state UA(1) 0, 0, b = 0, 1, x . This completes the first part.
| ⟩ | ⟩
For the second part, we project the output state onto the zero eigenstate |0, 1, x⟩ of H(1).
For this, we approximately implement the filter function of H(1), by approximating it with a
Laurent polynomial in e [i][x], allowing us to use Theorem 4.1. Let P (z) be the Laurent polynomials in Lemma C.3 with parameters (∆, ε) = (1/κ, ε). Then we have P (1) ∈ [1 − ε, 1] and


44


P (e [i][x] ) ∈ [−ε/2, ε/2] for all x ∈ [−1, −1/κ] ∪ [1/κ, 1], and deg(P ) = O(κ log(1/ε)). Since all
non-zero eingenvalues of H(1) are in [−1, −1/κ] ∪ [1/κ, 1], P (e [i][H][(1)] ) is an ε-approximation of the
projection operator onto the zero eigenstates of H(1). Therefore, we can apply Theorem 4.1 with
the Laurent polynomial P (z) to project the output state of the adiabatic evolution onto the zero
eigenstate |0, 1, x⟩ of H(1) with constant success probability. Both the parts overall consist of two
circuits, which is a particular case of the interleaved sequence circuit W in Sec. 3. When combined,
they form a new circuit, which is still in the form of W . After running this circuit, we can measure
the state conditioned on the success of the projection to estimate the expectation value of the
observable O with respect to |x⟩. Thus, overall, the quantum circuit only involves Hamiltonian
evolution operators and Pauli rotations, and, we can use Algorithm 1 to estimate ⟨x|O|x⟩ to within
error ε∥O∥.
Now, we move on to analyzing the complexity of our algorithm.


Complexity: The entire interleaved Hamiltonian evolution sequence consists of two parts. The
first part is an adiabatic evolution composed of T = O(κ) Hamiltonian evolutions:


B(0) = e [i][H][(0)], B(1/T ) = e [i][H][(1][/T] [)], . . ., B(1 − 1/T ) = e [i][H][(1][−][1][/T] [)] .

The second part is an eigenstate filtering stage, which involves 2 deg(P ) = O(κ log(1/ε)) interleaved
single-qubit Pauli rotations and Hamiltonian evolutions of the form


e [i][|][0][⟩⟨][0][|⊗][H][(1)] and e [−][i][|][1][⟩⟨][1][|⊗][H][(1)] .



We can indeed implement the Hamiltonian evolution using Trotter methods, as H(s) can be written
as a sum of simple terms as shown previously.
Note that for any two states |y⟩, |z⟩ we have

          - 0 z y          -          - z ��          -          - z z 0          | ⟩⟨ | = | ⟩ z y | ⟩⟨ | .
y z 0 y ⟨ | ⟨ |            - 0 y y
| ⟩⟨ | | ⟩ | ⟩⟨ |

So, the Hermitian terms in Eq. (5.11) and Eq. (5.12) can be decomposed in this manner with
z = (Qj Pj) 0, b, (Z I) 0, b and y = 0, b .
| ⟩ ⊗ | ⟩ ⊗ | ⟩ | ⟩ | ⟩
The Hamiltonian evolution




- z
= | ⟩
|y⟩



�� - - z z 0
z y | ⟩⟨ |
⟨ | ⟨ |  - 0 y y
| ⟩⟨ |




.




 -  exp it (Qj ⊗ Pj)|0, b⟩
|0, b⟩



�� - [�]
0, b (Qj Pj) 0, b
⟨ | ⊗ ⟨ |








            
 
   -    - (Qj (Ub [†][P][j][))] 0
exp 2it + 0 [n][+1] + 0 [n][+1] ⊗
| ⟩| ⟩⟨ |⟨ | 0 I Ub [†]
⊗




 = (Qj ⊗ (PjUb)) 0
0 I Ub
⊗



can be implemented using one query to Ub and Ub [†][, along with one (][n][ + 3)-qubit Toffoli gate and a]
constant number of elementary gates. The Hamiltonian evolution




 -  exp it (Qj ⊗ Pj)|0, b⟩⟨0, b|(Qj ⊗ Pj) 0
0 |0, b⟩⟨0, b|



��








 = (Qj ⊗ (Pj Ub)) 0
0 I Ub
⊗




           

   -   - (Qj (Ub [†][P][j][))] 0
exp it(I 0 [n][+1] 0 [n][+1] ) ⊗
⊗| ⟩⟨ | 0 I Ub [†]
⊗



can be implemented using one query to Ub and Ub [†][, along with one (][n][ + 2)-qubit Toffoli gate]
and a constant number of elementary gates. Using the 2k-th order Trotter-Suzuki formula S2k


45


to approximately implement the Hamiltonian evolution, by Theorem 3.4, the maximum quantum
circuit depth is

             
                       - �1+1/2k [�]

             O (25/3) [k] k [2] L κλcomm,


while the total time complexity and number of queries to Ub and Ub [†] [are]

            
             -             - �1+1/2k 2 [�]
O (25/3) [k] k [2] L κλcomm /ε .


By Eq. (3.13), we have λcomm = O(λ). Choosing a large enough value of k (e.g., k = log(log(κ/ε)))
gives the claimed results. We need n + 2 qubits to encode H(s), one qubit for implementing the
filter function using GQSP, and one qubit to implement the Toffoli gates, so the total number of
qubits is n + 4.
On the other hand, if O is measured coherently, simplifying the complexity in Theorem 3.6
gives the claimed results. Since the ancilla qubit for Toffoli gates can be reused, we only need one
more ancilla qubit.


We compare the complexity of our algorithm with the state-of-the-art procedure of [13] in Table
3. In [13], the block encoding of A alone uses ⌈log2 L⌉ ancilla qubits. In addition to this, their
algorithm needs six more ancilla qubits: (i) four ancilla qubits for constructing the quantum walk
operator out of the block encoding of A, and (ii) two ancilla qubits for an LCU-based method to
implement the eigenstate filter. In order to estimate ⟨x|O|x⟩ to within an ε-additive accuracy, the
maximum quantum circuit depth is O [�] (Lλκ), and O(∥O∥ [2] /ε [2] ) classical repetitions, if O is measured
incoherently, while using ⌈log2 L⌉ + 6 ancilla qubits.
Our method has a quasi-linear dependence on κ and a polylogarithmic dependence on 1/ε,
without assuming any block encoding access, or using quantum walks. Moreover, we only need
four ancilla qubits in all. To the best of our knowledge, this is the first quantum algorithm for
quantum linear systems that satisfies the following three properties: (i) does not assume block
encoding access of A, (ii) achieves a quasi-linear dependence on κ, and (iii) uses only a constant
number of ancilla qubits. Note that randomized quantum linear systems algorithms have recently
been developed, tailored to near-term quantum devices. These methods require a single ancilla
qubit but has a worse total time complexity of O [�] (λ [2] κ [6] /ε [2] ).
In many applications, such as Green’s function estimation, linear regression, and solving differential equations, quantum linear systems are used as a subroutine. That is, the state |x⟩ is
the input to a different part of a larger quantum circuit. Our algorithm can also be used as a
subroutine, as it basically implements an interleaved sequence circuit of unitaries and Hamiltonian
evolution operators. Note that the final unitary in Eq. (3.1) can be a new quantum algorithm
altogether. Thus, the measurement of the observable (and consequently Richardson extrapolation)
can be delayed until the end of the full circuit.


5.2 Ground state property estimation

Consider a Hamiltonian H with spectral decomposition H = [�] i [ξ][i][|][v][i][⟩⟨][v][i][|][, where the eigenvalues]
ξi are arranged in increasing order. The ground state of H is the eigenstate |v0⟩ corresponding
to the smallest eigenvalue ξ0, known as the ground state energy. Preparing the ground state and
estimating the ground state energy of a Hamiltonian are fundamental tasks in quantum computing
and quantum many-body physics. In general, these problems are QMA-hard [76], but they become
tractable when additional information is available. Specifically, one assumes: (i) knowledge of the


46


spectral gap ∆of the Hamiltonian, and (ii) access to a procedure that prepares an initial guess
state φ0 that has at least γ overlap with the ground state v0, i.e. φ0 v0 γ.
| ⟩ | ⟩ |⟨ | ⟩| ≥
Furthermore, we assume that any Hamiltonian H of interest can be expressed as a sum of L local
terms, namely, H = [�][L] k=1 [H][k][, where each][ H][k][ is a local Hamiltonian that can be exponentiated in]
constant time. We now formally state the ground state property estimation problem:

Problem 5.3 (Ground state property estimation). Let H = [�][L] k=1 [H][k][ be a Hamiltonian whose]
spectrum is contained in [ 1, 1], and λ = [�] k
prepare an initial guess state− φ0 such that it has an overlap of at least [∥][H][k][∥][. Suppose][ ε][ ∈] [(0][,][ 1][/][2)][ and that we can efficiently] γ with the ground state
| ⟩
v0 of H, i.e. φ0 v0 γ, for γ (0, 1). Furthermore, assume that there is a spectral gap ∆
| ⟩ |⟨ | ⟩| ≥ ∈
separating the ground state energy ξ0 from the rest of the spectrum. Then, the goal is to compute
v0 O v0 up to additive error ε O for any given observable O.
⟨ | | ⟩ ∥ ∥

Before discussing our algorithms, we briefly discuss some prior results for this problem.


5.2.1 Prior work


The state-of-the-art algorithms for this problem utilize LCU or QSVT, but assume block encoding
access to the underlying Hamiltonian [41, 77]. However, these algorithms are only optimal in
terms of the number of queries made to the underlying block-encoded operator. For instance, the
algorithm in [41] requires a circuit depth of O [�] (Lλ∆ [−][1] γ [−][1] ε [−][1] ) to estimate v0 O v0, while using
⟨ | | ⟩
O(log L) ancilla qubits and several sophisticated controlled operations. The ancilla requirement
of [77] is even higher.
Constructing a block encoding of H can be prohibitively costly in many settings. As a result,
several recent results on ground state property estimation have explored alternatives that avoid
this overhead. These approaches, however, assume access to a different oracle: the time-evolution
operator U = e [iH], and measure cost in terms of the number of queries to U [27, 42, 42, 43, 78, 79].
This framework is commonly referred to as the Hamiltonian-evolution access model, and most
of these algorithms require only O(1) ancilla qubits. To convert such oracle-based procedures
into fully end-to-end quantum algorithms without incurring additional ancilla overhead, one can
approximate U by higher order Trotterization. using higher-order Trotterization. However, this
substitution generally worsens the precision dependence, from the optimal Heisenberg scaling of
1/ε to a suboptimal 1/ε [1+][o][(1)] .
Our approach builds on the algorithm proposed in Ref. [27], which introduces quantum eigenvalue transformation using unitaries (QET-U)—a framework for implementing real polynomial
transformations of unitary matrices, assuming oracle access to e [iH] . Notably, the QET-U circuit
structure can be viewed as an interleaved sequence of single-qubit Z rotations and Hamiltonian
evolutions, which corresponds to a specific instance of the more general circuit architecture W
(introduced in Sec. 3). This connection suggests that end-to-end quantum algorithms for ground
state property estimation and related problems can be naturally realized within our framework,
where classical extrapolation techniques allow us to recover the optimal Heisenberg scaling.


5.2.2 Our algorithm


The ground state property estimation algorithm of [27] implements a polynomial approximation
to the shifted sign function using the QET-U framework. In particular, they assume knowledge of
some µ > 0 such that
ξ0 µ ∆/2 < µ + ∆/2 ξ1.
≤               - ≤


47


Then, the shifted sign function is defined as


θ(x) =




1, x µ,
≤ (5.13)
0, x > µ.



Applying a polynomial approximation to the shifted sign function effectively filters out excited-state
components, projecting the initial state φ0 close to the ground state v0 .
| ⟩ | ⟩
For our algorithm, we show that the shifted sign function can be approximated by a Laurent
polynomial in e [i][x] that remains bounded in T (see Lemma C.2). This key observation enables the
application of Theorem 4.2, allowing us to estimate the expectation value v0 O v0 . This leads to
⟨ | | ⟩
the following result:


Theorem 5.4 (Ground state property estimation using GQSP with Trotter). Assume that ∥H∥≤ 1
and there is a spectral gap ∆ separating the ground state energy ξ0 from the first excited state energy
ξ1 such that
ξ0 µ ∆/2 < µ + ∆/2 ξ1,
≤               - ≤

for some given µ. Let k be a positive integer. Then there is a quantum algorithm for the ground
state property estimation problem 5.3 using only two ancilla qubits. The maximum circuit depth is



�1+o(1)�
,




 -  
 - λcomm
O L

∆γ




 -  
 - λcomm
O L



and the time complexity is




λcomm

∆γ



�1+o(1) [�]




O




L
ε [2]



,



where λcomm defined in Eq. (3.12) for all H [(][ℓ][)] = H scales with the nested commutators of H. If we
further assume O/η is block-encoded via a unitary UO for some η satisfying η = Θ(∥O∥), we can
reduce the time complexity to




λcomm



�1+o(1) [�]



,




 O




L



ε



∆γ



using one additional ancilla qubit.



Proof. According to Lemma C.2, there is a Laurent polynomial P (z) of degree O(∆ [−][1] log((γε) [−][1] ))
such that ∥P (z)∥T ≤ 1, and� [6]

P (e [i][x] ) 1 γε/12, x [ 1, µ ∆/2],
|                       - | ≤ ∈                       -                       - (5.14)
|P (e [i][x] )| ≤ γε/12, x ∈ [µ + ∆/2, 1] .

Therefore, we obtain a bounded polynomial P such that |P (e [i][x] ) - θ(x)| ≤ γε for all [−1, µ - ∆/2] ∪

[µ + ∆/2, 1]. Then we have


P (e [i][H] ) φ0 ψ0 φ0 ψ0 = P (e [i][H] ) φ0 θ(H) φ0 γε,
∥ | ⟩−⟨ | ⟩| ⟩∥ ∥ | ⟩− | ⟩∥≤

where the first equation follows from θ(H) φ0 = ψ0 φ0 ψ0 and the first inequality follows from
| ⟩ ⟨ | ⟩| ⟩
that H has no eigenvalues in (µ ∆/2, µ +∆/2). Let ψ = P (e [i][H] ) φ0 / P (e [i][H] ) φ0 . The distance

         - | ⟩ | ⟩ ∥ | ⟩∥
between the two states after normalization is bounded as

ψ0 φ0 ψ0 2γε
���� ψ | ⟩| ⟩ ����
| ⟩−⟨ ψ0 φ0 ≤ 12 ψ0 φ0 6 [,]

[≤] [ε]



ψ0 φ0
|⟨ | ⟩|



2γε
����
≤ 12 ψ0 φ0 6
|⟨ | ⟩| [≤] [ε]



6 [,]



6Recall that T = {x ∈ C : |x| = 1}.



48


and hence
ψ O ψ ψ0 O ψ0 O ε/2
∥⟨ | | ⟩−⟨ | | ⟩∥≤∥ ∥

By Theorem 4.2, we can estimate ⟨ψ|O|ψ⟩ to accuracy ε∥O∥/2 with maximum circuit depth

               -                
            O (25/3) [k] k [2] L λcomm∆ [−][1] γ [−][1][�][1+1][/][2][k][�],


and total time complexity


               -               
            O (25/3) [k] k [2] L λcomm∆ [−][1] γ [−][1][�][1+1][/][2][k] /ε [2][�],


which gives an estimate of ψ0 O ψ0 to within an additive accuracy of O ε.
⟨ | | ⟩ ∥ ∥
Following Theorem 3.6, it is also possible to measure O using IQAE to achieve optimal complexities. This would increase the quantum circuit depth by a factor of 1/ε, but reduce the total time
complexity to O [�] (1/ε), and we need one more ancilla qubit for the Hadamard test circuit to encode
the expectation value into an amplitude. For both coherent and incoherent estimation, choosing a
large enough k results in the stated complexities.


We have summarized the complexity of our algorithm alongside prior work in Table 4. For a
sufficiently large choice of Trotter order k, our algorithm achieves nearly the same time complexity
as the state-of-the-art method of [41], despite their stronger assumption of quantum access to a
block encoding of H, which can be expensive to construct. For example, consider Hamiltonians
expressed as a linear combination of unitaries: H = [�] k [λ][k][H][k][, where][ ∥][H][k][∥] [= 1, and each unitary]
Hk is easy to implement. Constructing a block encoding of such an H using the LCU method
requires ⌈log2 L⌉ ancillas, along with sophisticated multi-qubit controlled operations. Additionally,
estimating expectation values via iterative quantum amplitude estimation demands at least four
more ancilla qubits, further increasing the hardware overhead.
We now compare the complexity of Dong et al. [27, Theorem 11] with that of Theorem 5.4. To
ensure a fair comparison, we assume that the oracle U = e [iH] in [27] is implemented via the 2k-th
order Trotter-Suzuki product formula S2k(t). Furthermore, as with our algorithm the expectation
value v0 O v0 can be estimated either incoherently or coherently. This leads to different quantum
⟨ | | ⟩
circuit depths and time complexities, as shown below:


  - For incoherent estimation, the ground state property estimation algorithm of [27], each coherent run requires a quantum circuit depth of

              
                   
              O L λ [′] comm [∆][−][1][γ][−][1][�][1+][o][(1)][/ε][o][(1)][�],

while O [�] (ε [−][2] ) classical repetitions are needed, overall. Here, λ [′] comm [=][ O][(][�] k
the nested commutators of Hk, but is different from the expression of λcomm [∥][H] in Remark [k][∥][) scales with] 3.2.
Note that the circuit depth per coherent run is exponentially slower than our algorithm.


  - For coherent estimation, iterative quantum amplitude estimation results in a total time complexity of

             
                   
              O L λ [′] comm [∆][−][1][γ][−][1][�][1+][o][(1)][/ε][1+][o][(1)][�],


which is polynomially worse than our algorithm, which manages to attain the Heisenberg
scaling of 1/ε.


49


### 6 Discussion and open problems

In this work, we have introduced a new approach to Quantum Singular Value Transformation
(QSVT) that eliminates block encodings while maintaining near-optimal complexity. By utilizing
direct Hamiltonian evolution with higher-order Trotterization and Richardson extrapolation, we
have significantly reduced the ancilla overhead, using only a single ancilla qubit instead of the standard O(log L). Our results provide a versatile and general framework for implementing polynomial
transformations of Hermitian and non-Hermitian matrices, making QSVT more hardware-efficient
and accessible for near-term quantum devices.
Moreover, our framework extends beyond QSVT, offering a general technique for mitigating
errors in any quantum circuit that is an interleaved sequence of arbitrary unitary operations and
Hamiltonian evolution. We applied this to develop near-optimal quantum algorithms for quantum
linear systems and ground-state property estimation without assuming any block encoding access.
Our work opens avenues for future research:


  - Optimal cost of the interleaved sequence circuit: For the interleaved sequence of arbitrary unitaries and Hamiltonian evolution operators considered in Sec. 3, an interesting
direction of future research would be to develop a method that estimates the desired expectation value with a cost that scales strictly linearly in M (instead of quasi-linear, as in our
case) while satisfying the three desirable features of our method: (i) commutator scaling,
(ii) no ancilla overhead, (iii) not needing any oracular access to H. Such a method would
attain optimal circuit depth for QSVT (as M translates to the polynomial degree in the case
of QSVT, which is a proven lower bound [1]) without using block encodings or more ancilla
qubits.


  - Generalization to CPTP maps: Another possible direction of research would be to generalize the interleaved sequence circuit in Sec. 3 to incorporate completely positive trace
preserving (CPTP) maps. For instance, an interleaved sequence of CPTP maps and Hamiltonian evolutions capture open quantum systems dynamics. Indeed, quantum collision models
or repeated interaction maps provide a rich framework to simulate complex open quantum
system dynamics [80, 81]. Here, the environment is a sum of discrete sub-environments.
Each sub-environment interacts (or collides) with the system, one by one, for a certain
time, before being traced out. The sequence of interactions can be simulated on a quantum computer, with the underlying circuit being an interleaved sequence of tracing out
of the corresponding sub-environment (a CPTP map) and the evolution of the total (system+environment+interaction) Hamiltonian for some time. Thus, a generalization of our
interleaved sequence circuit would allow for simulating a wide variety of open systems dynamics, such as Lindblad evolution [82, 83] and beyond [84], with near-optimal complexity,
using near-term Hamiltonian simulation procedures and very low hardware overhead. Concretely, is it possible to establish a bound on the circuit depth of interleaved sequences with
CPTP maps and Hamiltonian evolution operators that match known bounds for Lindblad
evolution [82, 83, 85]?


  - Interplay between physical and algorithmic errors: Our work shows that errors due
to Trotterization can be efficiently mitigated, even when it is integrated into a larger, more
general quantum circuit. Thus, is it possible to develop a theory of mitigating algorithmic
errors? Moreover, quantum algorithms are also subjected to physical errors leading to noisy
quantum circuits. It would be interesting to understand the interplay between these two


50


sources of errors, and if they can be jointly mitigated while still retaining quantum advantage

[86].


Our results provide a new perspective on QSVT and quantum polynomial transformations,
demonstrating that block encoding is not a necessary requirement. The framework of the interleavedsequence circuit raises new fundamental questions in quantum complexity and algorithm design,
suggesting possible connections to many different quantum algorithmic paradigms. We anticipate
that this approach will lead to deeper insights into quantum algorithm design, both in near-term
and fully fault-tolerant settings.


Data Availability: No new data were created during this study.
Conflict of Interest: The authors declare that they have no financial interests.

### Acknowledgments


CS and YZ are supported by the National Key Research Project of China under Grant No.
2020YFA0712300. SC and SH acknowledge funding from the Ministry of Electronics and Information Technology (MeitY), Government of India, under Grant No. 4(3)/2024-ITEA. SC also
acknowledges support from Fujitsu Ltd, Japan, and IIIT Hyderabad via the Faculty Seed Grant.
TL and XW were supported by the National Natural Science Foundation of China (Grant Numbers
62372006 and 92365117), and the Fundamental Research Funds for the Central Universities, Peking
University. XW thanks the University of California, Berkeley, for its hospitality during his visit,
where a part of this work was conducted. We thank Andrew M. Childs and Ronald de Wolf for
valuable feedback on this work.

### Appendix A Lower bound on the ancilla requirement for block encoding an LCU


Consider an operator A that can be written as a linear combination of L unitaries, i.e., A =
�L
j=1 [λ][j][P][j][. Suppose that each][ P][j][ can be implemented efficiently on a quantum computer, and are]
of the same dimension. In this section, we prove that in order to block encode A exactly, Ω(log L)
ancilla qubits are required. To derive such a general result, we consider a family of quantum
circuits U, which can possibly be block encodings of A. More specifically, we consider the following
quantum circuit (see Fig. 1):


U = (V1 I)c0-P1(V2 I)c0-P2 (VL I)c0-PL(VL+1 I), (A.1)
⊗ ⊗            - · · ⊗ ⊗

where V1, . . ., VL+1 act on some m ancilla qubits. Additionally, the controlled unitaries c0-Pj (which
is controlled by 0) are defined as:

      c0-Pj := |0 [m] ⟩⟨0 [m] | ⊗ Pj + |k⟩⟨k| ⊗ I = |0 [m] ⟩⟨0 [m] | ⊗ (Pj − I) + Im ⊗ I. (A.2)

k̸=0 [m]


The above quantum circuit is indeed quite general, as it includes LCU as a special case, which
will be explained shortly. Additionally, since all Pj act on the same space as A, it is reasonable to
assume they act on the same qubit space as A in (A.1). To make the circuit more general, we can
introduce some unitaries V1, . . ., VL+1 acting on the ancilla qubits.


51


0 [m] / V1 V2 VL+1
| ⟩                - · ·


ψ / P1 P2 PL
| ⟩                 - · ·


Figure 1: The quantum circuit of U defined via (A.1).


Recall from Sec. 2.2 that the quantum circuit for LCU is


               - �L                (PREP [†] I) j j Pj (PREP I), (A.3)
⊗ | ⟩⟨ | ⊗ ⊗

j=1

                  where PREP is a unitary acting on ℓ = log L ancilla qubits and maps 0 [ℓ] to [�] j λj/λ j, where
⌈ ⌉ | ⟩ | ⟩

λ = [�] j [λ][j][. Here, we assumed][ λ][j][ >][ 0 without loss of generality. In the LCU circuit (][A.3][), each][ P][j]
is controlled by |j⟩. However, we can easily find a permutation Sj that maps |j⟩ to |0 [ℓ] ⟩, such that
controlled operation contj -Pj equals (Sj [†]
that LCU is indeed a special case of the circuit in ( [⊗] [I][)][c][0][-][P][j][(][S] A.1 [j][ ⊗] ), see Fig. [I][). Using this observation, it is easy to see] 2.


|0 [ℓ] ⟩ / PREP CIRC CIRC   - · · CIRC CIRC PREP [†]


ψ / P1 P2 PL
| ⟩    - · ·

                  Figure 2: The quantum circuit of LCU, where ℓ = log L, PREP 0 [ℓ] = [�][L] j=1 λj/λ j with
⌈ ⌉ | ⟩ | ⟩

λ = [�] j [λ][j][, and][ CIRC][ :=][ �] j [L] =1 [|][j][ −] [1][⟩⟨][j][|][ +][ |][L][⟩⟨][0][|][ is a permutation.]


In this section, we aim to prove the following theorem:


Theorem A.1. If U is an exact block encoding of A, that is,

                -                 -                 -                 ⟨0 [⊗][m] | ⊗ I U |0 [⊗][m] ⟩⊗ I = A,


then the number of ancilla qubits, m, satisfies m = Ω(log L).


Proof. From Eq. (A.2), we have


(Vj ⊗ I)c0-Pj = Vj|0 [m] ⟩⟨0 [m] | ⊗ (Pj − I) + Vj ⊗ I.


52


Expanding A = (⟨0 [⊗][m] | ⊗ I) U (|0 [⊗][m] ⟩⊗ I), we obtain:

�L

λjPj
j=1



= 0 [m] V1V2 VL+1 0 [m] I
⟨ |  - · · | ⟩·



+



�L



0 [m] V1 Vj 0 [m] 0 [m] Vj+1 VL+1 0 [m] (Pj I)
j=1⟨ | - · · | ⟩⟨ | - · · | ⟩· 



 +



0 [m] V1 Vj1 0 [m] 0 [m] Vj1+1 Vj2 0 [m] 0 [m] Vj2+1 VL+1 0 [m] (Pj1 I)(Pj2 I)
1≤j1<j2≤L⟨ | - · · | ⟩⟨ | - · · | ⟩⟨ | - · · | ⟩· - 


+ · · · · · ·




 - - �ℓ

0 [m] V1 Vj1 0 [m]
1≤j1<···<jℓ≤L⟨ | - · · | ⟩ r=2




 +



�ℓ 
0 [m] Vjr−1+1 Vjr 0 [m] 0 [m] Vjℓ+1 VL+1 0 [m]
r=2⟨ | - · · | ⟩ ⟨ | - · · | ⟩·



�ℓ

(Pjr I)
r=1 


+ · · · · · ·



L�+1



�L

(Pr I).
r=1 


+



0 [m] Vr 0 [m]
⟨ | | ⟩·
r=1



The above equality should hold for all unitaries P1, . . ., PL, so we obtain a series of equations:



L�+1



0 [m] Vr 0 [m] = 0
⟨ | | ⟩
r=1




- · · · · ·




       - �ℓ
0 [m] V1 Vj1 0 [m]
⟨ | - · · | ⟩




- · · · · ·



�ℓ 
0 [m] Vjr−1+1 Vjr 0 [m] 0 [m] Vjℓ+1 VL+1 0 [m] = 0
r=2⟨ | - · · | ⟩ ⟨ | - · · | ⟩



0 [m] V1 Vj1 0 [m] 0 [m] Vj1+1 Vj2 0 [m] 0 [m] Vj2+1 VL+1 0 [m] = 0
⟨ | - · · | ⟩⟨ | - · · | ⟩⟨ | - · · | ⟩



0 [m] V1 Vj 0 [m] 0 [m] Vj+1 VL+1 0 [m] = λj = 0
⟨ | - · · | ⟩⟨ | - · · | ⟩ ̸



⟨0 [m] |V1V2 · · · VL+1|0 [m] ⟩ = λ1 + · · · + λL.



Apart from the last L+1 equations, all others lead to some orthogonalities. Indeed, from induction,
it is easy to see that we have L(L − 1)/2 such equations:



0 [m] V2 0 [m] = 0 [m] V3 0 [m] = = 0 [m] VL 0 [m] = 0,
⟨ | | ⟩ ⟨ | | ⟩ - · · ⟨ | | ⟩



0 [m] V2V3 0 [m] = 0 [m] V3V4 0 [m] = = 0 [m] VL−1VL 0 [m] = 0,
⟨ | | ⟩ ⟨ | | ⟩ - · · ⟨ | | ⟩



0 [m] V2V3V4 0 [m] = 0 [m] V3V4V5 0 [m] = = 0 [m] VL−2VL−1VL 0 [m] = 0,
⟨ | | ⟩ ⟨ | | ⟩ - · · ⟨ | | ⟩




- · · · · ·



0 [m] V2 VL−1VL 0 [m] = 0.
⟨ | - · · | ⟩



If we consider



H2 = Span{⟨0 [m] |S2}, S2 = {V2}



H3 = Span{⟨0 [m] |S3}, S3 = {V2, V3, V2V3}



H4 = Span{⟨0 [m] |S4}, S4 = {V2, V3, V4, V2V3, V3V4, V2V3V4}



53


                          - · · · · ·

Hj = Span{⟨0 [m] |Sj}, Sj = {Vj, Sj−1, Sj−1Vj}.

Then, we can show that dim( j) dim( j−1)+1. This can be proved by contradiction. Note that
H ≥ H
Hj−1 ⊆Hj. If dim(Hj) = dim(Hj−1), then Hj = Hj−1. This means ⟨0 [m] |Vj ∈ Span{⟨0 [m] |Sj−1} =
Span 0 [m] j−1Vj . This means 0 [m] j−1, which is a contradiction because 0 [m] is orthogonal
{⟨ |S } ⟨ | ∈H ⟨ |
to j−1. From this we conclude that dim( L) L 1, which implies m = Ω(log L).
H H ≥  
### Appendix B Distance between two quantum states


First, consider that there exist two operators P and Q such that ∥P − Q∥≤ γ. We demonstrate
that the expectation value of O with respect to PρP [†] is not far off from the expectation value of
O with respect to QρQ [†], for any density matrix ρ. More precisely, we prove
���Tr[O PρP †] Tr[O QρQ†]��� 3 O γ
                   - ≤ ∥ ∥

for ∥P ∥≤ 1. This was proven in [40], but here we provide a simpler proof. Let us recall the tracial
version H¨older’s inequality, which is stated below for completeness:


Lemma B.1 (Tracial version of H¨older’s inequality [87]). Define two operators A and B and
parameters p, q ∈ [1, ∞] such that 1/p + 1/q = 1. Then the following holds:



Tr[A [†] B] ≤∥A∥p ∥B∥q .



Here ∥X∥p corresponds to the Schatten p-norm of the operator X. For the special case of p = ∞
and q = 1, the statement of Lemma B.1 can be rewritten as

Tr[A [†] B] ≤∥A∥∞ ∥B∥1 = ∥A∥∥B∥1 . (B.1)

Theorem B.2. Suppose P and Q are operators such that ∥P − Q∥≤ γ for some γ ∈ [0, 1].
Furthermore, let ρ be any density matrix and O be some Hermitian operator with spectral norm
∥O∥. Then, if ∥P ∥≤ 1, the following holds:
���Tr[O PρP †] Tr[O QρQ†]��� 3 O γ.
                   - ≤ ∥ ∥

Proof. Using Eq. (B.1), we have

Tr[O PρP [†] ] Tr[O QρQ [†] ] O PρP [†] QρQ [†] 1 (B.2)
|                   - | ≤∥ ∥· ∥                   - ∥

For the second term in the RHS of Eq. (B.2), we can successively apply Eq. (B.1) to obtain:
PρP † QρQ† = ���PρP † PρQ† + PρQ† QρQ†���
���� ����
        - 1        -        - 1



Pρ 1 P Q + P Q ρQ 1
≤∥ ∥ ∥ - ∥ ∥ - ∥∥ ∥
≤∥P ∥∥P − Q∥ + ∥Q∥∥P − Q∥ (As ∥ρ∥1 = 1)



≤ (∥P ∥ + ∥P − Q∥ + ∥P ∥) · ∥P − Q∥



= 2 ∥P ∥∥P − Q∥ + ∥P − Q∥ [2] .



Now, substituting this upper bound back in the RHS of Eq. (B.2), we obtain
���Tr[O PρP †] Tr[O QρQ†]��� ��O����P Q��2 + 2��O����P ����P Q��
             - ≤             -             
�� �� ���� �� �� ��
≤ γ [2][��] O + 2 O P γ ≤ 3γ O .

This completes the proof.


54


### Appendix C Functions approximated by Laurent polynomials

In this section, we show that several important functions can be approximated by Laurent polynomials in e [i][x], bounded in T = {x ∈ C : |x| = 1}. All these functions are implementable by our
methods in Sec. 4. We begin with the shifted sign function.


Shifted sign function: For any ∆ ∈ (0, 1), a trigonometric approximation of sgn(sin(x)) over

[−π + ∆, −∆] ∪ [∆, π − ∆] is given by [26]. Since x ∈ [−π, π], this is also a trigonometric approximation of sgn(x).

Lemma C.1 (Lemma S3 of [26]). For any ∆ [′], ε [′] ∈ (0, 1), there exists a Laurent polynomial P (z)
of deg(P ) = O(log(1/ε [′] )/∆ [′] ) such that


|P (z)| ≤ 1 for all z ∈ T,

|P (e [i][x] ) − sgn(x)| ≤ ε [′] for all x ∈ [−π + ∆ [′], −∆ [′] ] ∪ [∆ [′], π − ∆ [′] ].

Then, we obtain the following:


Lemma C.2 (Trigonometric approximation of the shifted sign function). For any ∆, ε ∈ (0, 1)
and µ ∈ [−1, 1] such that ∆ ≤ 2 min{|µ − 1|, |µ + 1|}, there exists a Laurent polynomial P (z) of
deg(P ) = O(log(1/ε)/∆) such that



|P (z)| ≤ 1 for all z ∈ T,



P (e [i][x] ) ∈ [1 − ε, 1] for all x ∈ [−1, µ − ∆/2],



P (e [i][x] ) ∈ [0, ε] for all x ∈ [µ + ∆/2, 1].



Proof. Let P1(z) be the Laurent polynomial in Lemma C.1 with parameters (∆ [′], ε [′] ) = (min π
{                                          2, ∆/2, 2ε). Then P1(e [i][x] ) is an 2ε-approximation of sgn(x) for all x [ 2, ∆/2] [∆/2, 2]. The
} ∈    -    - ∪
Laurent polynomial P (e [i][x] ) = (P1(e [i(][x][−][µ][)] ) + 1)/2 satisfies the desired properties.


Next, we construct the filter function used for solving linear systems in Theorem 5.2.


Lemma C.3 (Trigonometric approximation of the filter function). For any ∆, ε ∈ (0, 1), there
exists a Laurent polynomial P (z) of degree O(log(1/ε)/∆) such that P (1) ∈ [1 − ε, 1] and

|P (z)| ≤ 1 for all z ∈ T,

P (e [i][x] ) ∈ [−ε/2, ε/2] for all x ∈ [−1, −∆] ∪ [∆, 1].

Proof. Let P1(z) be the Laurent polynomial in Lemma C.1 with parameters (∆ [′], ε [′] ) = (min π
{                                          2, ∆/2, ε). Then the Laurent polynomial P (e [i][x] ) = (P1(e [i(][x][+∆][/][2))] ) + P1(e [i(][−][x][+∆][/][2)] )/2 satisfies the
}
desired properties.


Rectangle function: Combining two approximate shifted sign functions yields an approximate
rectangle function.


Lemma C.4 (Trigonometric approximation of the the rectangle function). For any δ, ε ∈ (0, 1/2)
and t ∈ [−1, 1], there exists a Laurent polynomial P (z) of degree O(log(1/ε)/δ) such that |P (z)| ≤ 1
for all z ∈ T and

P (e [i][x] ) ∈ [1 − ε, 1] for all x ∈ [−t + δ, t − δ],

P (e [i][x] ) ∈ [0, ε] for all x ∈ [−1, −t − δ] ∪ [t + δ, 1].


55


Proof. Let P1(z) be the Laurent polynomial in Lemma C.1 with (∆ [′], ε [′] ) = (min π 2, δ, ε) and
{                                    - }
P (e [i][x] ) = (P1(e [i(][x][−][t][)] ) + P1(e [i(][−][x][−][t][)] ))/2 satisfies the desired properties.


Inverse function: For the inverse function, we can transform the polynomial approximation of
1/x constructed in [15] to a trigonometric approximation using Proposition 4.4.


Lemma C.5 (Trigonometric approximations of the inverse function). For any κ > 1 and ε ∈
(0, 1/2), there exists a Laurent polynomial P (z) of degree O(κ log [2] (κ/ε)) and B = O(κ log(κ/ε))
such that


|P (z)| ≤ 1 for all z ∈ T,

|P (e [i][πx/][3] ) − 1/(Bx)| ≤ ε for all x ∈ [−1, −1/κ] ∪ [1/κ, 1].

Proof. [15, Lemmas 17-19] constructed an O(κ log(κ/ε))-degree polynomial g(x) that is bounded
by B = O(κ log(κ/ε)) in [−1, 1] and (Bε/2)-close to 1/x in [−1, −1/(2κ)] ∪ [1/(2κ), 1]. Then
g˜(x) := g(x/2)/B is ε/2-close to 1/(Bx) in [−2, −1/κ] ∪ [1/κ, 2] and bounded by 1 in [−2, 2].
Therefore, we can apply Proposition 4.4 to ˜g(x) with parameters (ε, δ) = (ε/2, 1/2), which gives us
a Laurent polynomial P (z) of degree O(κ log [2] (κ/ε)) such that


|P (z)| ≤ 1 for all z ∈ T,

|P (e [i][πx/][3] ) − g˜(x)| ≤ ε/2 for all x ∈ [−1, 1].

The Laurent polynomial P (e [i][πx/][3] ) is ε-close to 1/(Bx) in [−1, 1/κ] ∪ [1/κ, 1] as ˜g(x) is ε/2-close
1/(Bx) in this interval.


Exponential function: We can also construct the trigonometric polynomial approximation of the
exponential function used in the quantum Gibbs sampler [63].


Lemma C.6 (Trigonometric approximations of the exponential function). For any β > 1 and
ε ∈ (0, 1/2), there exists a Laurent polynomial P (z) of degree O(β log(1/ε)) such that

|P (z)| ≤ 1 for all z ∈ T,

|P (e [i][πx/][(2(1+1][/β][))] ) − e [β][(][x][−][1)][−][1] | ≤ ε for all x ∈ [−1, 1].

Proof. The function e [β][(][x][−][1)][−][1] has Taylor series



�∞
e [β][(][x][−][1)][−][1] = e [−][β][−][1]


j=0



β [j]

j! [x][j][,]



which we denote by [�][∞] j=0 [a][j][x][j][. Let][ δ][ = 1][/β][ and][ B][ =][ �] j [∞] =0 [a][j][(1+] [δ][)][j][ =][ e][−][β][−][1+][β][(1+1][/β][)][ = 1. Then]
applying Proposition 4.5 with f (x) = f [˜] (x) = e [β][(][x][−][1)][−][1] gives the claimed results.

### References


[1] Andr´as Gily´en, Yuan Su, Guang Hao Low, and Nathan Wiebe. Quantum singular value
transformation and beyond: exponential improvements for quantum matrix arithmetics. In
Proceedings of the 51st annual ACM SIGACT symposium on theory of computing, pages 193–
204, 2019.


56


[2] John M Martyn, Zane M Rossi, Andrew K Tan, and Isaac L Chuang. Grand unification of
quantum algorithms. PRX Quantum, 2(4):040203, 2021.


[3] Guang Hao Low and Isaac L Chuang. Hamiltonian simulation by qubitization. Quantum,
3:163, 2019.


[4] Shantanav Chakraborty, Andr´as Gily´en, and Stacey Jeffery. The power of block-encoded
matrix powers: Improved regression techniques via faster hamiltonian simulation. In 46th
International Colloquium on Automata, Languages, and Programming (ICALP 2019), volume
132 of Leibniz International Proceedings in Informatics (LIPIcs), pages 33:1–33:14, Dagstuhl,
Germany, 2019.


[5] Seth Lloyd. Universal quantum simulators. Science, 273(5278):1073–1078, 1996.


[6] Andrew M. Childs, Yuan Su, Minh C. Tran, Nathan Wiebe, and Shuchen Zhu. Theory of
Trotter error with commutator scaling. Physical Review X, 11(1):011020, 2021.


[7] Hsin-Yuan Huang, Yu Tong, Di Fang, and Yuan Su. Learning many-body Hamiltonians with
Heisenberg-limited scaling. Physical Review Letters, 130(20):200403, 2023.


[8] Ainesh Bakshi, Allen Liu, Ankur Moitra, and Ewin Tang. Learning quantum Hamiltonians at
any temperature in polynomial time. In Proceedings of the 56th Annual ACM Symposium on
Theory of Computing (STOC), pages 1470–1477, 2024.


[9] Ainesh Bakshi, Allen Liu, Ankur Moitra, and Ewin Tang. High-temperature Gibbs states are
unentangled and efficiently preparable. In 2024 IEEE 65th Annual Symposium on Foundations
of Computer Science (FOCS), pages 1027–1036. IEEE, 2024.


[10] Danial Motlagh and Nathan Wiebe. Generalized quantum signal processing. PRX Quantum,
5(2):020368, 2024.


[11] Guang Hao Low, Vadym Kliuchnikov, and Nathan Wiebe. Well-conditioned multiproduct
Hamiltonian simulation. arXiv:1907.11679, 2019.


[12] Dmitry Grinko, Julien Gacon, Christa Zoufal, and Stefan Woerner. Iterative quantum amplitude estimation. npj Quantum Information, 7(1):52, 2021.


[13] Pedro C.S. Costa, Dong An, Yuval R. Sanders, Yuan Su, Ryan Babbush, and Dominic W.
Berry. Optimal scaling quantum linear-systems solver via discrete adiabatic theorem. PRX
Quantum, 3(4):040303, 2022.


[14] Andris Ambainis. Variable time amplitude amplification and quantum algorithms for linear algebra problems. In Christoph D¨urr and Thomas Wilke, editors, 29th International Symposium
on Theoretical Aspects of Computer Science (STACS 2012), volume 14 of Leibniz International Proceedings in Informatics (LIPIcs), pages 636–647, Dagstuhl, Germany, 2012. Schloss
Dagstuhl – Leibniz-Zentrum f¨ur Informatik.


[15] Andrew M. Childs, Robin Kothari, and Rolando D. Somma. Quantum algorithm for systems
of linear equations with exponentially improved dependence on precision. SIAM Journal on
Computing, 46(6):1920–1950, 2017.


[16] James D. Watson and Jacob Watkins. Exponentially reduced circuit depths using Trotter
error mitigation. arXiv:2408.14385, 2024.


57


[17] James D Watson. Randomly compiled quantum simulation with exponentially reduced circuit
depths. arXiv:2411.04240, 2024.


[18] Suba¸si Yi˘git, Rolando D. Somma, and Davide Orsucci. Quantum algorithms for systems
of linear equations inspired by adiabatic quantum computing. Physical Review Letters,
122(6):060504, 2019.


[19] Dominic W. Berry, Andrew M. Childs, Yuan Su, Xin Wang, and Nathan Wiebe. Timedependent Hamiltonian simulation with L [1] -norm scaling. Quantum, 4:254, 2020.


[20] Jacob Watkins, Nathan Wiebe, Alessandro Roggero, and Dean Lee. Time-dependent hamiltonian simulation using discrete-clock constructions. PRX Quantum, 5:040316, 2024.


[21] Dong An, Jin-Peng Liu, and Lin Lin. Linear combination of Hamiltonian simulation for nonunitary dynamics with optimal state preparation cost. Physical Review Letters, 131(15):150603,
2023.


[22] Dong An, Andrew M Childs, and Lin Lin. Quantum algorithm for linear non-unitary dynamics
with near-optimal dependence on all parameters. arXiv:2312.03916, 2023.


[23] Dong An, Andrew M Childs, Lin Lin, and Lexing Ying. Laplace transform based quantum
eigenvalue transformation via linear combination of Hamiltonian simulation. arXiv:2411.04010,
2024.


[24] Marco Cerezo, Andrew Arrasmith, Ryan Babbush, Simon C Benjamin, Suguru Endo, Keisuke
Fujii, Jarrod R McClean, Kosuke Mitarai, Xiao Yuan, Lukasz Cincio, et al. Variational quantum algorithms. Nature Reviews Physics, 3(9):625–644, 2021.


[25] Andrew M Childs and Nathan Wiebe. Hamiltonian simulation using linear combinations of
unitary operations. Quantum Information & Computation, 12(11-12):901–924, 2012.


[26] Youle Wang, Lei Zhang, Zhan Yu, and Xin Wang. Quantum phase processing and its applications in estimating phase and entropies. Physical Review A, 108(6):062413, 2023.


[27] Yulong Dong, Lin Lin, and Yu Tong. Ground-state preparation and energy estimation on early
fault-tolerant quantum computers via quantum eigenvalue transformation of unitary matrices.
PRX Quantum, 3(4):040305, 2022.


[28] Seth Lloyd, Bobak T Kiani, David RM Arvidsson-Shukur, Samuel Bosch, Giacomo De Palma,
William M Kaminsky, Zi-Wen Liu, and Milad Marvian. Hamiltonian singular value transformation and inverse block encoding. arXiv:2104.01410, 2021.


[29] Jiasu Wang, Yulong Dong, and Lin Lin. On the energy landscape of symmetric quantum signal
processing. Quantum, 6:850, 2022.


[30] Shantanav Chakraborty, Soumyabrata Hazra, Tongyang Li, Changpeng Shao, Xinzhao Wang,
and Yuxin Zhang. Quantum singular value transformation without block encodings: Nearoptimal complexity with minimal ancilla. arXiv:2504.02385v1, 2025.


[31] Theodore J. Yoder, Guang Hao Low, and Isaac L. Chuang. Fixed-point quantum search with
an optimal number of queries. Physical Review Letters, 113:210501, 2014.


[32] Shantanav Chakraborty, Aditya Morolia, and Anurudh Peduri. Quantum regularized least
squares. Quantum, 7:988, 2023.


58


[33] Andrew M Childs and Jin-Peng Liu. Quantum spectral methods for differential equations.
Communications in Mathematical Physics, 375(2):1427–1457, 2020.


[34] Jin-Peng Liu, Herman Øie Kolden, Hari K. Krovi, Nuno F. Loureiro, Konstantina Trivisa, and
Andrew M. Childs. Efficient quantum algorithm for dissipative nonlinear differential equations.
Proceedings of the National Academy of Sciences, 118(35):e2026805118, 2021.


[35] Hari Krovi. Improved quantum algorithms for linear and nonlinear differential equations.
Quantum, 7:913, 2023.


[36] Guang Hao Low and Yuan Su. Quantum linear system algorithm with optimal queries to
initial state preparation. arXiv:2410.18178, 2024.


[37] Dong An and Lin Lin. Quantum linear system solver based on time-optimal adiabatic quantum
computing and quantum approximate optimization algorithm. ACM Transactions on Quantum
Computing, 3(2):1–28, 2022.


[38] Lin Lin and Yu Tong. Optimal polynomial based quantum eigenstate filtering with application
to solving quantum linear systems. Quantum, 4:361, 2020.


[39] Samson Wang, Sam McArdle, and Mario Berta. Qubit-efficient randomized quantum algorithms for linear algebra. PRX Quantum, 5(2):020324, 2024.


[40] Shantanav Chakraborty. Implementing any linear combination of unitaries on intermediateterm quantum computers. Quantum, 8:1496, 2024.


[41] Lin Lin and Yu Tong. Near-optimal ground state preparation. Quantum, 4:372, 2020.


[42] Lin Lin and Yu Tong. Heisenberg-limited ground-state energy estimation for early faulttolerant quantum computers. PRX Quantum, 3:010318, 2022.


[43] Ruizhe Zhang, Guoming Wang, and Peter Johnson. Computing Ground State Properties with
Early Fault-Tolerant Quantum Computers. Quantum, 6:761, 2022.


[44] Junaid Aftab, Dong An, and Konstantina Trivisa. Multi-product Hamiltonian simulation with
explicit commutator scaling. arXiv:2403.08922, 2024.


[45] Guang Hao Low and Isaac L. Chuang. Optimal hamiltonian simulation by quantum signal
processing. Physical Review Letters, 118, 2017.


[46] Fernando G.S.L. Brand˜ao, Amir Kalev, Tongyang Li, Cedric Yen-Yu Lin, Krysta M. Svore, and
Xiaodi Wu. Quantum SDP solvers: Large speed-ups, optimality, and applications to quantum
learning. In Proceedings of the 46th International Colloquium on Automata, Languages, and
Programming, volume 132 of Leibniz International Proceedings in Informatics (LIPIcs), pages
27:1–27:14, 2019.


[47] Joran van Apeldoorn and Andr´as Gily´en. Improvements in Quantum SDP-Solving with Applications. In 46th International Colloquium on Automata, Languages, and Programming (ICALP
2019), volume 132 of Leibniz International Proceedings in Informatics (LIPIcs), pages 99:1–
99:15, Dagstuhl, Germany, 2019.


59


[48] Simon Apers, Andr´as Gily´en, and Stacey Jeffery. A unified framework of quantum walk
search. In 38th International Symposium on Theoretical Aspects of Computer Science (STACS
2021), volume 187 of Leibniz International Proceedings in Informatics (LIPIcs), pages 6:1–6:13,
Dagstuhl, Germany, 2021.


[49] Amara Katabarwa, Katerina Gratsea, Athena Caesura, and Peter D. Johnson. Early faulttolerant quantum computing. PRX Quantum, 5:020101, 2024.


[50] Suguru Endo, Simon C. Benjamin, and Ying Li. Practical quantum error mitigation for nearfuture applications. Physical Review X, 8:031027, 2018.


[51] Zhenyu Cai, Ryan Babbush, Simon C. Benjamin, Suguru Endo, William J. Huggins, Ying Li,
Jarrod R. McClean, and Thomas E. O’Brien. Quantum error mitigation. Reviews of Modern
Physics, 95:045005, 2023.


[52] Gumaro Rendon, Jacob Watkins, and Nathan Wiebe. Improved accuracy for Trotter simulations using Chebyshev interpolation. Quantum, 8:1266, 2024.


[53] Gumaro Rendon. All you need is Trotter. arXiv:2311.01533, 2023.


[54] Dominic W. Berry, Andrew M. Childs, Richard Cleve, Robin Kothari, and Rolando D. Somma.
Simulating Hamiltonian dynamics with a truncated Taylor series. Physical Review Letters,
114:090502, 2015.


[55] Guang Hao Low and Isaac L. Chuang. Hamiltonian simulation by uniform spectral amplification. arXiv:1707.05391, 2017.


[56] Richard P. Feynman. Simulating physics with computers. International Journal of Theoretical
Physics, 21(6/7), 1982.


[57] Andrew M. Childs, Dmitri Maslov, Yunseong Nam, Neil J. Ross, and Yuan Su. Toward the
first quantum simulation with quantum speedup. Proceedings of the National Academy of
Sciences, 115(38):9456–9461, 2018.


[58] Masuo Suzuki. Fractal decomposition of exponential operators with applications to many-body
theories and Monte Carlo simulations. Physics Letters A, 146(6):319–323, 1990.


[59] Nathan Wiebe, Dominic Berry, Peter Høyer, and Barry C. Sanders. Higher order decompositions of ordered operator exponentials. Journal of Physics A: Mathematical and Theoretical,
43(6):065203, 2010.


[60] Ana Arnal, Fernando Casas, and Cristina Chiralt. A note on the Baker–Campbell–Hausdorff
series in terms of right-nested commutators. Mediterranean Journal of Mathematics, 18:1–16,
2021.


[61] Mehdi Saeedi and Massoud Pedram. Linear-depth quantum circuits for n-qubit Toffoli gates
with no ancilla. Physical Review A—Atomic, Molecular, and Optical Physics, 87(6):062318,
2013.


[62] Adriano Barenco, Charles H Bennett, Richard Cleve, David P DiVincenzo, Norman Margolus,
Peter Shor, Tycho Sleator, John A Smolin, and Harald Weinfurter. Elementary gates for
quantum computation. Physical Review A, 52(5):3457, 1995.


60


[63] Joran van Apeldoorn, Andr´as Gily´en, Sander Gribling, and Ronald de Wolf. Quantum SDPsolvers: Better upper and lower bounds. In 2017 IEEE 58th Annual Symposium on Foundations
of Computer Science (FOCS), pages 403–414. IEEE, 2017.


[64] Aram W. Harrow, Avinatan Hassidim, and Seth Lloyd. Quantum algorithm for linear systems
of equations. Physical Review Letters, 103(15):150502, 2009.


[65] Guang Hao Low and Yuan Su. Quantum eigenvalue processing. In 2024 IEEE 65th Annual
Symposium on Foundations of Computer Science (FOCS), pages 1051–1062. IEEE, 2024.


[66] Alexander Dranov, R Seiler, and J Kellendonk. Discrete time adiabatic theorems for quantum
mechanical systems. Technical report, SCAN-9706123, 1997.


[67] Edward Farhi, Jeffrey Goldstone, Sam Gutmann, and Michael Sipser. Quantum computation
by adiabatic evolution. arXiv preprint quant-ph/0001106, 2000.


[68] Edward Farhi, Jeffrey Goldstone, Sam Gutmann, Joshua Lapan, Andrew Lundgren, and Daniel
Preda. A quantum adiabatic evolution algorithm applied to random instances of an NPcomplete problem. Science, 292(5516):472–475, 2001.


[69] Andris Ambainis and Oded Regev. An elementary proof of the quantum adiabatic theorem.
arXiv preprint quant-ph/0411152, 2004.


[70] Sabine Jansen, Mary-Beth Ruskai, and Ruedi Seiler. Bounds for the adiabatic approximation
with applications to quantum computation. Journal of Mathematical Physics, 48(10):102111,
10 2007.


[71] Alexander Elgart and George A. Hagedorn. A note on the switching adiabatic theorem. Journal
of Mathematical Physics, 53(10):102202, 09 2012.


[72] Yu Tong, Dong An, Nathan Wiebe, and Lin Lin. Fast inversion, preconditioned quantum linear
system solvers, fast Green’s-function computation, and fast evaluation of matrix functions.
Physical Review A, 104:032422, 2021.


[73] Dominic W Berry, Andrew M Childs, Aaron Ostrander, and Guoming Wang. Quantum algorithm for linear differential equations with exponentially improved dependence on precision.
Communications in Mathematical Physics, 356:1057–1081, 2017.


[74] Andrew M. Childs, Jin-Peng Liu, and Aaron Ostrander. High-precision quantum algorithms
for partial differential equations. Quantum, 5:574, 2021.


[75] Noah Linden, Ashley Montanaro, and Changpeng Shao. Quantum vs. classical algorithms for
solving the heat equation. Communications in Mathematical Physics, 395(2):601–641, 2022.


[76] Julia Kempe, Alexei Kitaev, and Oded Regev. The complexity of the local Hamiltonian
problem. SIAM Journal on Computing, 35(5):1070–1097, 2006.


[77] Yimin Ge, Jordi Tura, and J Ignacio Cirac. Faster ground state preparation and high-precision
ground energy estimation with fewer qubits. Journal of Mathematical Physics, 60(2):022202,
2019.


[78] Kianna Wan, Mario Berta, and Earl T. Campbell. Randomized quantum algorithm for statistical phase estimation. Physical Review Letters, 129:030503, 2022.


61


[79] Guoming Wang, Daniel Stilck Fran¸ca, Ruizhe Zhang, Shuchen Zhu, and Peter D. Johnson.
Quantum algorithm for ground state energy estimation using circuit depth with exponentially
improved dependence on precision. Quantum, 7:1167, 2023.


[80] Marco Cattaneo, Gabriele De Chiara, Sabrina Maniscalco, Roberta Zambrini, and Gian Luca
Giorgi. Collision models can efficiently simulate any multipartite Markovian quantum dynamics. Physical Review Letters, 126:130403, Apr 2021.


[81] Francesco Ciccarello, Salvatore Lorenzo, Vittorio Giovannetti, and G. Massimo Palma. Quantum collision models: Open system dynamics from repeated interactions. Physics Reports,
954:1–70, 2022.


[82] Zhiyan Ding, Xiantao Li, and Lin Lin. Simulating open quantum systems using Hamiltonian
simulations. PRX Quantum, 5:020332, May 2024.


[83] Matthew Pocrnic, Dvira Segal, and Nathan Wiebe. Quantum simulation of lindbladian dynamics via repeated interactions. Journal of Physics A: Mathematical and Theoretical, 2023.


[84] F. Ciccarello, G. M. Palma, and V. Giovannetti. Collision-model-based approach to nonMarkovian quantum dynamics. Physical Review A, 87:040103, Apr 2013.


[85] Richard Cleve and Chunhao Wang. Efficient quantum algorithms for simulating lindblad evolution. In 44th International Colloquium on Automata, Languages, and Programming (ICALP
2017), volume 80 of Leibniz International Proceedings in Informatics (LIPIcs), pages 17:1–
17:14, Dagstuhl, Germany, 2017.


[86] Pegah Mohammadipour and Xiantao Li. Direct analysis of zero-noise extrapolation: Polynomial methods, error bounds, and simultaneous physical-algorithmic error mitigation.
arXiv:2502.20673, 2025.


[87] Mary Beth Ruskai. Inequalities for traces on von Neumann algebras. Communications in
Mathematical Physics, 26:280–289, 1972.


62


