**Simulating quantum collision models with Hamiltonian simulations using early fault-tolerant**
**quantum computers**


Kushagra Garg, [1, 2,] _[ ∗]_ Zeeshan Ahmed, [2, 3,][ †] Subhadip Mitra, [1, 2,][ ‡] and Shantanav Chakraborty [2, 3,][ §]

1 _Center for Computational Natural Sciences and Bioinformatics,_
_International Institute of Information Technology, Hyderabad 500 032, India_
2 _Center for Quantum Science and Technology, International Institute of Information Technology, Hyderabad 500 032, India_
3 _Center for Security, Theory and Algorithmic Research,_
_International Institute of Information Technology, Hyderabad 500 032, India_
(Dated: August 20, 2025)


We develop randomized quantum algorithms to simulate quantum collision models, also known as
repeated interaction schemes, which provide a rich framework to model various open-system dynamics.
The underlying technique involves composing time evolutions of the total (system, bath, and interaction) Hamiltonian and intermittent tracing out of the environment degrees of freedom. This results in
a unified framework where any near-term Hamiltonian simulation algorithm can be incorporated to
implement an arbitrary number of such collisions on early fault-tolerant quantum computers: we do
not assume access to specialized oracles such as block encodings and minimize the number of ancilla
qubits needed. In particular, using the correspondence between Lindbladian evolution and completely
positive trace-preserving maps arising out of memoryless collisions, we provide an end-to-end quantum algorithm for simulating Lindbladian dynamics. For a system of _n_ -qubits, we exhaustively compare
the circuit depth needed to estimate the expectation value of an observable with respect to the reduced
state of the system after time _t_ while employing different near-term Hamiltonian simulation techniques,
requiring at most _n_ + 2 qubits in all. We compare the CNOT gate counts of the various approaches for
estimating the Transverse Field Magnetization of a 10-qubit XX-Heisenberg spin chain under amplitude
damping. Finally, we also develop a framework to efficiently simulate an arbitrary number of memoryretaining collisions, i.e., where environments interact, leading to non-Markovian dynamics. Overall, our
methods can leverage quantum collision models for both Markovian and non-Markovian dynamics on
early fault-tolerant quantum computers, shedding light on the advantages and limitations of simulating
open systems dynamics using this framework.



**I.** **INTRODUCTION**


Simulating the dynamics of closed quantum systems,
also known as Hamiltonian simulation, is widely considered to be one of the foremost applications of a quantum
computer [1–5]. A natural extension is the problem of
simulating open systems dynamics, wherein the underlying quantum system interacts with an environment, resulting in non-unitary dynamics. Over the years, several
techniques have been put forth that capture the effects
of environmental interactions on the underlying quantum
system [6, 7]. Quantum master equations derived in a
wide variety of settings accurately describe the system dynamics under both coherent evolution and environmental interactions. Of these, the most widely analyzed is
the Gorini-Kossakowski-Sudarshan-Lindblad (GKSL) master equation (generally referred to as a Lindblad master
equation), which provides a general model to describe
Markovian quantum dynamics, i.e., when the system and
the environment remain uncorrelated throughout the evolution [8, 9]. This equation generates dynamics of com

_∗_ [kushagra.garg@research.iiit.ac.in](mailto:kushagra.garg@research.iiit.ac.in)

[† zeeshan.ahmed@research.iiit.ac.in](mailto:zeeshan.ahmed@research.iiit.ac.in)

[‡ subhadip.mitra@iiit.ac.in](mailto:subhadip.mitra@iiit.ac.in)
[§ shchakra@iiit.ac.in](mailto:shchakra@iiit.ac.in)



pletely positive trace-preserving (CPTP) maps, capturing
effects such as spontaneous emission, dephasing, and dissipation [6, 7]. Besides being fundamental to our understanding of environmental effects on quantum systems,
Lindbladian dynamics has found diverse applications in
quantum computation, ranging from quantum error mitigation strategies [10, 11] to recent quantum algorithms
for preparing ground [12] and thermal states of Hamiltonians [13]. Thus, the problem of simulating open systems
dynamics is of considerable importance.
One would expect quantum computers to provide a significant advantage over their classical counterparts for this
problem, owing to the favorable scaling of the Hilbert
space dimension with the number of qubits. However,
since most current methods require significant resources
in the form of access to specialized oracles such as blockencodings [5, 14], several ancilla qubits, and sophistical controlled operations [15–19], they are ill-suited for
the early fault-tolerant era, where quantum computers
have limited ancilla space, and complicated control logic
is absent [20]. This naturally leads us to the question of
whether open systems dynamics can be efficiently simulated on early fault-tolerant quantum computers.
We consider quantum collision models, also known as repeated interaction schemes, which have emerged as a powerful framework to describe the dynamics of open quantum systems [21–25]. In such models, the environment


comprises several individual subsystems, each interacting
with the system for a fixed time interval, one after another.
The underlying idea is that environmental effects can arise
from the repeated sequential interactions between the underlying system and the individual environment subsystems (referred to as _sub-environments_ throughout this article). Despite their simplicity, collision models can effectively describe a variety of physical quantum systems,
since it is possible to engineer a broad range of dynamics through a sequence of relatively simple discrete interactions in this framework. For instance, the basic framework of a microscopic maser can be described using collision models [26]. In quantum thermodynamics, collision
models have been employed in the study of quantum batteries [27, 28], Landauer’s principle [29], and quantum
thermalization [25, 30–35]. Other applications include
the study of quantum optical systems [36–42], modelling
of continuous measurements [43], and quantum metrology or thermometry [44, 45]. Indeed, Markovian dynamics naturally emerge from memory-less collisions, i.e.,
when the environment comprises many non-interacting
sub-environments interacting exactly once with the system. On the other hand, in scenarios where an interaction between the system and an environment is followed
by an interaction between two or more sub-environments,
memory effects arise, leading to non-Markovian dynamics [23, 46–49].


There are clear advantages in simulating open systems
dynamics using quantum collision models. The interaction between the system and an environment subsystem
is simply the time evolution of the corresponding total
Hamiltonian (sum of the system, sub-environment, and
interaction Hamiltonian), and repeated interactions boil
down to implementing a composition of Hamiltonian evolutions. Thus, these models provide an avenue to simulate various open quantum systems dynamics using only
Hamiltonian simulation algorithms (which have seen remarkable progress) as core subroutines. Indeed, this includes both state-of-the-art Hamiltonian simulation algorithms with near-optimal complexities [3, 5, 50, 51] as well
as methods suitable for near-term implementation, such as
qDRIFT and (low-order) Trotter methods, that are simple
and provide better performance in practice [1, 4, 52, 53].
Ref. [54] has recently explored the possibility of simulating Lindbladian dynamics using Hamiltonian simulations.
It unravels Lindblad dynamics as a stochastic Schrödinger
equation and constructs an effective Hamiltonian from
the Kraus operator representation obtained from the discretization of these unraveling equations. While this approach achieves near-optimal query complexity, it still requires several ancilla qubits and block-encoding access to
the effective Hamiltonian to achieve optimal complexity.


In this paper, we build on the results of Ref. [55],
where the authors provide explicit bounds for approximating Lindbladian dynamics through Markovian maps from
quantum collision models. They compute the query com


plexity of this problem using Hamiltonian simulation by
qubitization [5] and higher-order Trotter methods [53].
In contrast, we explore end-to-end complexities of simulating open systems dynamics using quantum collision models restricted by a lack of ancilla qubits and no access to
specialized oracles such as block encodings. We also consider near-term simulation methods such as low- and highorder Trotter methods [53], qDRIFT [4], and, in particular,
incorporate the randomized Hamiltonian simulation technique of Refs. [56–58], which is a particular instance of
a Linear Combination of Unitaries (LCU) that can be implemented efficiently on early fault-tolerant quantum computers.
We first consider a quantum collision model that naturally gives rise to Markovian dynamics. We assume the
environment comprises a discrete set of subsystems, each
interacting with the system for a time ∆ _t_, one by one, before being traced out. This process is repeated _K_ times,
leading to a Markovian _K_ -collision map. Given the total
Hamiltonian _H_ for each collision (the system, the corresponding sub-environment, and their interaction), we develop a randomized algorithm that outputs an _ε_ -additive
estimate of the expectation value of any observable _O_ with
respect to the reduced state of the system after undergoing _K_ memoryless collisions (i.e., a Markovian _K_ -collision
map). This is achieved by composing a Hamiltonian simulation that implements _e_ _[−][iH]_ [∆] _[t]_ to a precision of _ε_ _[′]_ _≈_ _K∥εO∥_ [,] _[ K]_
times. Using different near-term Hamiltonian simulation
techniques, we exhaustively compare the end-to-end cost
of estimating the desired expectation value.
Subsequently, we develop a randomized quantum algorithm for simulating Lindbladian dynamics, which can
be shown as a particular instance of the Markovian _K_ collision map. Our procedure (i) does not require access
to block encodings of _H_, and (ii) is qubit efficient since
it only employs near-term Hamiltonian simulation procedures. We exhaustively compare the cost (circuit depth,
qubit count, and classical repetitions) of simulating Lindbladian dynamics using different Hamiltonian simulation
techniques. For instance, we find that in terms of the evolution time and precision, a Hamiltonian simulation by
the Single-Ancilla LCU (SA-LCU) method requires a circuit depth of _O_ [�] ( _t_ [3] _/ε_ ). [1] This method outperforms both the
first-order Trotter method and qDRIFT by a factor of 1 _/ε_ .
On the other hand, second-order Trotterization has a circuit depth of _O_ ( _t_ [9] _[/]_ [4] _/ε_ [5] _[/]_ [4] ): compared to the Hamiltonian

[�]
simulation by SA-LCU, it has a better dependence on _t_ but
a worse dependence on the precision. Interestingly, for 2 _k_ order, with _k →_ ∞, the circuit depth is better only by a factor of _t/ε_ compared to first-order Trotter and qDRIFT. In
fact, the circuit depth of higher-order Trotter is _O_ [�] ( _t_ [2] _/ε_ ),


1 Throughout this article, we follow standard complexity-theoretic notations. See Sec. II



2


which is optimal for simulating Linbladian dynamics using
quantum collision models [15] up to log factors.
We also numerically benchmark the performance of simulating Lindbladian dynamics using collision models. For
this, we consider a 10-qubit transverse-field Ising Hamiltonian under amplitude damping. Our goal is to estimate
the average transverse magnetization of the reduced quantum state of the system up to an additive accuracy of _ε_ .
If we demand high precision, say _ε_ = 10 _[−]_ [4], the Hamiltonian simulation by SA-LCU has a CNOT gate count (per coherent run) 200 times lower than that of the second-order
Trotter method and 2000 times lower than qDRIFT. On the
other hand, for low precision and long evolution time _t_, the
higher-order Trotter methods outperform other near-term
techniques.
Finally, we also explore the possibility of simulating nonMarkovian collisions on early fault-tolerant quantum computers. We extend the notion of Markovian _K_ -collision
maps to include interactions between the environment
subsystems. We consider the framework of Ciccarello et
al. [23], where a collision between the system and an environment subsystem is followed by a collision between
two consecutive environment subsystems. More precisely,
the _j_ -th iteration comprises the following two interactions:
first, the system interacts with the sub-environment _j_ and
then there is an interaction between the sub-environments _̸_
_j_ and _j_ + 1. We simulate a total of _K_ iterations (nonMarkovian _K_ -collision map) of these interaction sequences
using near-term Hamiltonian simulation procedures, requiring circuit depths that scale similarly to the Markovian
case. Thus, our overall framework allows for the possibility of simulating a broad range of open systems dynamics
through quantum collision models.
The remainder of this paper is organized as follows.
Sec. II, we formalize the notations we use throughout the
article. We present a framework for simulating memoryless collisions in Sec. III, and develop a randomized quantum algorithm to simulate a Markovian _K_ -collision map.
Sec. IV applies this to simulate Lindbladian dynamics and
comprises detailed comparisons of the complexities. We
also benchmark the gate counts for the estimation of the
overall magnetization of the transverse-field Ising model
under amplitude damping. In Sec. V, we extend our approach to simulate non-Markovian collisions and define a
non-Markovian _K_ -collision map. We conclude by summarizing our results and discussing possible open problems in
Sec. VI.


**II.** **NOTATIONS**


We use _g_ ( _n_ ) = _O_ ( _f_ ( _n_ )) to imply that _g_ is upper bounded
by _f_, i.e., there exist constants _k_ 1 and _k_ 2 such that _∀n > k_ 1,
_g_ ( _n_ ) _≤_ _k_ 2 _· f_ ( _n_ ). We also follow the standard convention
of using _tilde_ ( _∼_ ) to hide polylogarithmic factors. For instance, _O_ ( _f_ ( _n_ )) = _O_ ( _f_ ( _n_ )polylog( _f_ ( _n_ ))). The trace of an

[�]



operator _A_ is denoted by Tr[ _A_ ], while the expectation value
of the operator will be denoted by E[ _A_ ]. The probability of
an event _X_ occurring will be denoted by Pr[ _X_ ].
We use operator as well as superoperator norms. The
Schatten _p_ -norm of the operator _X_ is defined as


_̸_



_∥X∥p_ =


_̸_




- �1 _/p_
### ∑ σ j [p] [(] [X] [)],

_j_


_̸_



where _σ_ _j_ ( _X_ ) is the _j_ -th singular value of _X_ . So if _σ_ max( _X_ )
denotes the maximum singular value of _X_, we have


_̸_



�1 _/p_
= _σ_ max _,_


_̸_



_σ_ _j_ _[p]_ [(] _[X]_ [)]

_σ_ max ~~_[p]_~~ [(] _[X]_ [)]


_̸_



lim
_p→_ ∞ _[∥][X][∥][p]_ [ =] _[ σ]_ [max] _[ ·]_ [ lim] _p→_ ∞


_̸_





### ∑

_j_


_̸_



which is the spectral norm of the operator _X_ . We will denote this as simply _∥X∥_ . For instance, for any density operator _ρ_, we have _∥ρ∥_ 1 = 1, while for any unitary _U_, the
spectral norm _∥U∥_ = 1. For a superoperator _M_ which maps
operators to operators, we define the induced 1-norm of _M_
as follows:


_̸_



_∥M ∥_ 1 _→_ 1 = sup
_ρ̸_ =0



_∥M_ [ _ρ_ ] _∥_ 1

_._

_̸_ _∥ρ∥_ 1



_̸_


We provide a comprehensive list of all mathematical
symbols used in this paper, along with their definitions in
Appendix A (see Table A1).


**III.** **QUANTUM COLLISION MODELS**


Collision models are a versatile framework for simulating the dynamics of open quantum systems, where the
system interacts with its environment through a sequence
of discrete interactions or ‘collisions.’ Unlike continuoustime approaches, collision models treat the environment
as a set of discrete, independent subsystems (referred to
as sub-environments throughout this article) that interact
with the system one at a time. This setup provides valuable physical insights and a constructive approach to simulating complex open systems dynamics. For instance, repeated interactions between the system and each environment subsystem may be as follows: each sub-environment
(initially uncorrelated with both the system and other subenvironments) interacts with the system for a short duration before being traced out, dissipating information and
energy while resulting in a CPTP map. The overall dynamics of these collisions is described by a composition of the
CPTP maps, allowing for the modeling of Markovian (Lindbladian) dynamics. In this section, we discuss the possibility of simulating an arbitrary number of such collisions
using early fault-tolerant quantum computers.



_̸_


3


**A.** **Markovian** _K_ **-collision map**


Let us consider a quantum system in an _n_ -qubit Hilbert
space _HS_ that is coupled to a quantum environment belonging to the space _HE_, formed out of the tensor product
of _m_ environment subsystems: _HE_ = _HE_ 1 _⊗_ _HE_ 1 _···⊗_ _HEm_ .
We denote the system Hamiltonian by _HS_ . The environment is a discrete sum of environment subsystems, with
the Hamiltonian of the sub-environment _j_ denoted by _HE_ _j_ .
The _j_ -th collision corresponding to the interaction between
the system _S_ and the _j_ -th sub-environment, _E j_, is denoted
by the interaction Hamiltonian _HI_ _j_ . Thus, the total Hamiltonian is given by



_m_
### H = HS + ∑

_j_ =1




- _HI_ _j_ + _HE_ _j_ _._ (1)



We assume that the total Hamiltonian corresponding to the
_j_ -th collision can be expressed as a Linear combination of
Pauli operators, i.e.,



**Definition 2** (Markovian _K_ -collision map) **.** _Let_ Φ1 _,_ Φ2 _, ..._ _,_
Φ _K be the collision maps from Definition 1. The K-collision_
_map MK is the composition of these maps, defined as:_


            -             _MK_ [ _·_ ] _≡_ _⃝_ _[K]_ _j_ =1 [Φ] _[j]_ [[] _[·]_ []] _._ (5)


Thus, the _K_ collisions correspond to composing the collision map (evolving under _H_ for time _t_ = ∆ _t_ followed by tracing out the corresponding sub-environment) _K_ times. The
Hamiltonian simulation is the key subroutine in simulating a Markovian _K_ -collision map on a quantum computer.
Our goal is to develop a randomized quantum algorithm
that estimates the expectation value of an observable _O_ for
a system (initialized in _ρS_ ) after _K_ collisions, up to an additive precision _ε_ . That is, the algorithm outputs _µ_ such
that


�� _µ −_ Tr                       - _OMK_ [ _ρS_ ]��� _≤_ _ε._ (6)


In what follows, we estimate the precision required of any
Hamiltonian simulation procedure to estimate _µ_ with _ε_ additive accuracy. Let us denote by _U_ [�] _j_, the circuit corresponding to the Hamiltonian simulation procedure implementing _e_ _[−][i]_ [∆] _[tH][ j]_ to some accuracy (to be determined
later). Then, it is possible to define approximate versions
of the collision maps from Definitions 1 and 2, respectively,
where the exact time evolution operator _U_ _j_ is now replaced
by _U_ [¯] _j_ :



_H_ _j_ = _HS_ + _HE_ _j_ + _HI_ _j_ =



_L_ _j_
### ∑ hi, jPi, j, (2)

_i_ =1



where _Pi,_ _j ∈±{I,_ _σ_ _[x]_ _,_ _σ_ _[y]_ _,_ _σ_ _[z]_ _}_ _[⊗]_ _[n]_ and, without loss of generality, each _hi,_ _j ∈_ R [+] . Also, let _L_ = max _j L_ _j_ . Finally,
for 1 _≤_ _j ≤_ _K_, we denote the normalized Hamiltonians
_L j_
_H j_ = _H_ _j/β_ _j_, where _β_ _j_ = ∑ _i_ =1 _[h][i][,]_ _[j]_ [. Note that this is also]
without loss of generality, as we can always rescale ∆ _t_ by
multiplying it with _β j_ .
Now, we are in a position to describe the dynamics induced by the _j_ -th collision: the system, in state _ρS_, interacts
with the _j_ -th sub-environment, initialized in the state _ρE j_,
for a duration of ∆ _t_ . The dynamics induced by the _j_ -th collision is then given by the time evolution operator


_U_ _j_ = _e_ _[−][i][β]_ _[j][H][ j]_ [∆] _[t]_ (3)


Following this, the sub-environment is traced out. Formally, we define a Markovian collision map:


**Definition 1** (Markovian collision map) **.** _Let j ∈_ [1 _,_ _K_ ] _, ρE_ _j_
_represent the initial state of the j-th sub-environment, and_
_U_ _j be the unitary representing the interaction between the_
_system and the j-th sub-environment. The j-th collision map_
Φ _j is defined as:_




_,_ (7)



Φ� _j_ [ _·_ ] _≡_ Tr _E_ _j_




- - _U_ - _j_ _·⊗_ _ρE_ _j_ _U_ - _j_ [†]




(4)



and subsequently, the approximate _K_ -Collision map is defined as


            -             _M_    - _K_ [ _·_ ] _≡_ _⃝_ _[K]_ _j_ =1 [Φ][�] _[j]_ [[] _[·]_ []] _._ (8)


We now prove that if the Hamiltonian simulation procedures in the construction of the approximate Markovian _K_ -collision map are implemented with a precision
of _ε/_ (3 _K∥O∥_ ), then the expectation value of observable _O_
with respect to the state of the system with respect to the
map _M_ [�] _K_ is _ε_ -close to the desired expectation value. We do
so via the following lemma:


**Lemma 1** (Bounds on the Markovian collision map) **.** _Let O_
_be an observable and_ _M_ - _K represent the approximate Marko-_
_vian K-collision map in Eq._ (8) _, where_



Φ _j_ [ _._ ] _≡_ Tr _E_ _j_




- - _U_ _j_ _._ _⊗_ _ρE_ _j_ _U_ _j_ [†]



_ε_
��� _U_ _j −U_ - _j_ ��� _≤_ 3 _K∥O∥_ _[.]_ (9)



_Here,_ Tr _E_ _j denotes the partial trace over the j-th sub-_
_environment, resulting in a reduced state for the system._


For multiple collisions, this process is repeated. The resulting iterative sequence for _K_ collisions can be described by
composing _K_ such collision maps. Formally, we define a
Markovian _K_ -collision map as follows:



_Then, the expectation value of O over a state evolved under_
_the approximate map satisfies,_

���Tr           - _OMK_ [ _ρ_ ]� _−_ Tr           - _OM_ [�] _K_ [ _ρ_ ]���� _≤_ _ε._ (10)



max
1 _≤_ _j≤K_



4


_Proof._ We consider the error between the operations performed on the state _ρ_ under _U_ _j_ and _U_ [�] _j_ . More precisely,

let ��� _U_ _j −U_ - _j_ ��� _≤_ _ξ j_, where we denote the maximum error in
any of the Hamiltonian simulation procedures in the definition of the approximate _K_ -collision map by _ξ_ max, i.e.,
_ξ_ max = max1 _≤_ _j≤K ξ j_ . Then, using Theorem A1, we have


�� _U_ _jρU_ _j_             - _[−][U]_ [�] _[j][ρ]_ [ �] _[U]_ _j_ [†] ��1 _[≤]_ [3] _[ξ]_ _[j][,]_ (11)


for any quantum state _ρ_ . Since partial trace is a CPTP operation, it is contractive under the trace norm. Therefore,
we obtain,

       -        -        -        - [�]
Tr _E_ _j_ _U_ _jρU_ _j_ [†] _−_ Tr _E_ _j_ _U_      - _jρ_      - _U_ _j_ [†] _≤_ 3 _ξ_ _j._ (12)
���� ���1


This inequality implies that the trace distance between
the exact map Φ _j_ [ _ρ_ ] and the approximate map Φ [�] _j_ [ _ρ_ ] is
bounded by 3 _ξ j_ :

���Φ _j_ [ _ρ_ ] _−_ Φ� _j_ [ _ρ_ ]���1 _[≤]_ [3] _[ξ][ j][.]_ (13)


So,


max _j_ ���Φ _j_ [ _ρ_ ] _−_ Φ� _j_ [ _ρ_ ]���1 _[≤]_ [3] _[ξ]_ [max] _[.]_ (14)


Now, from Lemma A6, we obtain,

��� _⃝Kj_ =1 [Φ] _[j]_ [[] _[ρ]_ []] _[−⃝][K]_ _j_ =1 [Φ][�] _[j]_ [[] _[ρ]_ []] ���1 _[≤]_ [3] _[K][ξ]_ [max] _[.]_ (15)


Thus, we have


_∥MK_ [ _ρ_ ] _−_ _M_ [�] _K_ [ _ρ_ ] _∥_ 1 _≤_ 3 _Kξ_ max _._ (16)


Finally, we apply Theorem A1 once again to bound the difference in the expectation values of the observable _O_ under
_MK_ and _M_ - _K_ :
���Tr     - _OMK_ [ _ρ_ ]� _−_ Tr     - _OM_ [�] _K_ [ _ρ_ ]���� _≤_ 3 _K∥O∥ξ_ max _._ (17)


Therefore, by choosing _ξ_ max = _ε/_ (3 _K∥O∥_ ), we can ensure
that
���Tr           - _OMK_ [ _ρ_ ]� _−_ Tr           - _OM_ [�] _K_ [ _ρ_ ]���� _≤_ _ε._ (18)


Now, we can compare the complexities of using different
Hamiltonian simulation algorithms to implement a Markovian _K_ -collision map on a quantum computer. As mentioned earlier, we will primarily focus on near-term Hamiltonian simulation techniques, i.e., ones that do not require
multiple ancilla qubits. We will consider Trotter methods,
qDRIFT, and also the SA-LCU method of Ref. [58]. We need
to estimate the cost of composing _K_ Hamiltonian simulation algorithms, each implementing _e_ _[−][iH]_ [∆] _[t]_ to a precision



_ε/_ (3 _K∥O∥_ ), from Lemma 1. So, if a Hamiltonian simulation algorithm requires a circuit depth of


_τ_ �∆ _t, ε/_ ( _K∥O∥_ )� _,_


to implement _U_ _j_, up to an additive precision of
_O_ ( _ε/_ ( _K∥O∥_ )), the _K_ -collision map can be implemented
within a circuit depth of


_τd_ = _O_       - _Kτ_ �∆ _t, ε/_ ( _K∥O∥_ )� + _KτρE_       - _,_


where _τρE_ is the maximum of the circuit depths of the unitaries preparing the sub-environments, i.e., if for _j ∈_ [1 _,_ _K_ ],
if _τE_ _j_ is the circuit depth of preparing _ρE_ _j_, then _τρE_ =
max _j∈_ [1 _,K_ ] _τρE j_ . While any near-term Hamiltonian simulation procedure can be used to implement a Markovian _K_ collision map, the SA-LCU algorithm [58] demands some
attention. This method, described in the next section, expresses each _U_ _j_ as a linear combination of strings of Pauli
operators (say _U_ [�] _j_ ) with the total weight of the coefficients
_α_ = _O_ (1). Now, composing individual Hamiltonian simulations for implementing the Markovian _K_ -collision map can
potentially lead to an exponential scaling _α_ _[K]_, detrimentally affecting the circuit depth. However, below, we show
that it is possible to implement the Markovian _K_ -collision
map while bypassing this exponential scaling.


**B.** **Using Hamiltonian simulation by Single-Ancilla LCU to**
**simulate the Markovian K-collision map**


Given a Hamiltonian _H_ = ∑ _[L]_ _ℓ_ =1 _[p][ℓ][P][ℓ]_ [, where] _[ P][ℓ]_ [is a string]
of Pauli operators and ∑ _ℓ_ _pℓ_, there is a way to express _U_ =
_e_ _[−][i][τ][H]_ as a linear combination of Clifford gates and Pauli
rotations [56–58]. This involves writing down the Taylor series expansion of the time evolution operator _U_ and
truncating after some _q_ terms to obtain _U_, which is now

[�]
an LCU, expressed as _U_ [�] = ∑ _j α_ _jWj_, such that ��� _U −U_ ���� _≤_ _ε_

for _q_ = _O_ (log( _r_ ) _/_ loglog( _r/ε_ )). The parameter _r_ is crucially
chosen so that the total weight of the LCU coefficients of
_U_ �, given by _α_ = ∑ _j |αi| ≤_ _e_ _[−][τ]_ [2] _[/][r]_, converges. Each _Wi_ is a sequence of _q_ Clifford operators and a single Pauli rotation,
repeated _r_ times. We formally state this in the following
Lemma.


**Lemma 2** (LCU decomposition of time-evolution operator

[56–58]) **.** _Let H_ = ∑ _[L]_ _ℓ_ =1 _[p][ℓ][P][ℓ]_ _[be a Hermitian operator ex-]_
_pressed as a convex combination of strings of Pauli operators_
_Pℓ. Then, we can construct an Unitary operator_ _U_ [�] _repre-_
_sented as an LCU that approximates the time evolution oper-_
_ator U_ = _e_ _[−][i][τ][H]_ _satisfying:_
��� _U −U_ ���� _≤_ _ε,_ (19)


_where_


_U_        - = ∑ _αiWi,_ (20)
_i_



5


FIG. 1. The quantum circuit for simulating a _K_ -collision map using Hamiltonian simulation by SA-LCU. The algorithm applies controlled
and anti-controlled sampled unitaries ( _X_ _j_ and _Yj_, respectively) for the interaction between the system and each sub-environment,
following which the latter is traced out. This sequence is repeated _K_ times, corresponding to the _K_ collisions. At the end of the process,
the ancilla qubit and the system are measured. Notably, only a single environment register suffices, as it can be reused following the
tracing out of the previous environment subsystem.



_and_

_α_ = ∑ _|αi| ≤_ _e_ _[τ]_ [2] _[/][r]_ _._ (21)
_i_


_Here, each Wj is a sequence of q Clifford operators followed by_
_a single Pauli rotation, repeated r times. The parameter r is_
_chosen such that τ/r <_ 1 _(to ensure convergence of the series)_
_and the parameter q controls the precision of the approxima-_
_tion (the order at which the Taylor series is truncated), which_
_we choose to be_



system register is initialized in the state _ρS_ ; the environment registers in the state _ρE_ 1, and the ancilla qubit in the
state _|_ + _⟩_ . Let us first discuss the implementation of the
approximate collision map Φ [�] _j_, corresponding to the _j_ -th
collision. We recall that the (normalized) total Hamiltonian for the _j_ -th collision _H_ _j_ ( _∥H j∥_ = 1) can be expressed
as a convex combination of strings of Pauli operators, i.e.,
_H j_ = ∑ _[L]_ _k_ =1 _[p][ jk][P][jk]_ [. Then, from Lemma][ 2][, we pick the param-]
eter _r_ _j_ (to be determined later) such that for any _j ∈_ [1 _,_ _K_ ],


_U_       - _j_ = ∑ _α jkWjk,_ (23)
_k_


and

_ε_
��� _U_ _j −U_                      - _j_ ��� _≤_ 6 _K∥O∥_ _[,]_


where _U_ _j_ = _e_ _[−][i][β]_ _[j]_ [∆] _[tH][ j]_, here we have scaled the simulation
time. Note that from Lemma 2, each _Wji_ is a string of
_q_ Pauli operators and a single Pauli rotation, repeated _r j_
times, where




  - log( _r/ε_ )
_q_ = _O_
loglog( _r/ε_ )




_._ (22)



We present a derivation of the LCU decomposition in Appendix B for completeness. Clearly, for _r_ = _O_ ( _τ_ [2] ), the total weight _α_ = _O_ (1). Interestingly, the LCU _U_ [�] can be implemented using only a single ancilla qubit [58] such that
the expectation value of any observable _O_ with respect to
the time-evolved state can be estimated up to _ε_ -additive
accuracy by running a simple quantum circuit of depth
_O_ ( _rq_ ) = _O_ ( _τ_ [2] ), a total of _T_ = _O_ ( _∥O∥_ [2] _/ε_ [2] ) times.

[�]
Despite its near-term applicability, there are some issues
with using this method as a subroutine to implement a
Markovian _K_ -collision map. The choice of _r_ = _O_ ( _τ_ [2] ) only
ensures that _α_ = _O_ (1), and composing _K_ such Hamiltonian simulation procedures results in the total weight of
_α_ _[K]_, which grows exponentially with _K_ . This affects the
complexity of implementing the _K_ -collision map. However,
we show that this can be avoided by choosing a different
value of the parameter _r_ when considering the composition
of SA-LCU Hamiltonian simulation algorithms. This leads
to a procedure that can estimate the expectation value of
_O_ with respect to a state that has undergone the _K_ memoryless collisions up to an _ε_ -additive accuracy while using
the SA-LCU Hamiltonian simulation algorithm as a subroutine. Each run of the algorithm involves running the quantum circuit shown in Fig. 1. The outcome of this circuit is
a random variable that, in expectation value, estimates the
desired quantity. The overall algorithm (outlined in Algorithm 1) involves running this circuit a total of _T_ times and
estimating the sample average of the outcomes.
We require three registers: the system register, the environment register, and a single qubit ancilla register. The



Note that E[ _X_ _j_ ] = E[ _Yj_ ] = _U_ [�] _j/α_ [(] _[j]_ [)] . Then, we coherently apply the controlled version _X_ _j_ [(] _[c]_ [)] and the anti-controlled ver
sion _Yj_ [(] _[a]_ [)] of these sampled unitaries:


_X_ _j_ [(] _[c]_ [)] = _|_ 0 _⟩⟨_ 0 _|⊗_ I + _|_ 1 _⟩⟨_ 1 _|⊗_ _X_ _j,_ (26)

_Yj_ [(] _[a]_ [)] = _|_ 0 _⟩⟨_ 0 _|⊗Yj_ + _|_ 1 _⟩⟨_ 1 _|⊗_ I _._ (27)


After applying _X_ _j_ [(] _[c]_ [)] and _Yj_ [(] _[a]_ [)], we trace out the environment
register, which can be reused for the next collision.
We repeat these steps for _j_ = 1 to _K_ (as outlined in step 2
of Algorithm 1) to implement the approximate Markovian




  - log  - _r_ _jK∥O∥_ _/ε_  
_q_ = _O_

loglog ~~�~~ _r jK∥O∥_ _/ε_ ~~�~~







_,_ (24)



and _α_ [(] _[j]_ [)] = ∑ _k α_ _jk ≤_ _e_ _[−][β]_ [ 2] _j_ [∆] _[t]_ [2] _[/][r]_ [2] _j_ .
Next, we draw two independent and identically distributed (i.i.d.) samples, _X_ _j_ and _Yj_, from the ensemble




  _D_ _j_ = _Wjk,_ _[α]_ _[jk]_

_α_ [(] _[j]_ [)]




_._ (25)



6


**Algorithm 1:** Algorithm to estimate the
expectation value of an observable _O_ with respect
to a quantum state evolved under a _K_ -collision
map.

**Input:** Initial system state in _ρS_, sub-environment states
_ρE_ 1 _,...,_ _ρEK_, observable _O_, unitaries _U_ [�] 1, .... _U_ [�] _K_,
and precision _ε_ _[′]_, where the LCU decomposition of
each _U_ [�] _j_ = ∑ _k_ _α jkWjk_, such that _∀_ _j ∈_ [1 _,_ _K_ ],
���� _U_ _j −_ _e−i_ ∆ _tβ jH j_ ��� _≤_ _ε_ _′_ .


1. Initialize the system and the ancilla in the state _ρS_
and _|_ + _⟩_, respectively.


2. For each collision step, from _j_ = 1 to _K_ :


a. Initialize the environment register in state
_ρE_ _j_ .

b. Draw two i.i.d. samples _X_ _j_ and _Yj_ from the
ensemble



1 _−_ _δ_ . We prove the validity of Algorithm 1 with the following Theorem.


**Theorem 1.** _Let ε,_ _δ ∈_ (0 _,_ 1) _. Then, for ε_ _[′]_ = _ε/_ (6 _K∥O∥_ ) _,_
_Algorithm 1 outputs µ with at least_ 1 _−_ _δ probability such_
_that_


�� _µ −_ Tr[ _O MK_ [ _ρS_ ]]�� _≤_ _ε,_


_using T repetitions of the circuit shown in Figure 1 where_



_Each such coherent run has a circuit depth of_


_τd_ = _O_  - _β_ [2] _K_ [2] ∆ _t_ [2] log( _β_ _K∥O∥_ ∆ _t/ε_ )
loglog( _β_ _K∥O∥_ ∆ _t/ε_ ) [+] _[K][τ][ρ][E]_







_T_ = _O_




_∥O∥_ [2] log(1 _/δ_ )

_ε_ [2]



_._ (28)




_._ (29)




    -     _D_ _j_ = _Wjk,_ _[α][ jk]_ _,_

_α_ [(] _[j]_ [)]


where _α_ [(] _[j]_ [)] = ∑ _k |α_ _jk|_



c. Apply the controlled unitary _X_ _j_ [(] _[c]_ [)] and the

anti-controlled unitary _Yj_ [(] _[a]_ [)] to the system


d. Perform a partial trace over the environment
register.


3. Measure the joint ancilla and system state on the
observable ( _σ_ _[x]_ _⊗_ _O_ ) and record the measurement
outcome as _µi_ .


4. Repeat Steps 1 to 3 a total of _T_ times.


5. Compute the final estimate _µ_ as:



_Here, β_ = max _j β_ _j and τρE_ = max _j τρE j, where τρE j is the cir-_
_cuit depth of the unitary preparing the sub-environment in_
_the state ρE_ _j_ _._


_Proof._ Following Algorithm 1, we initialize the ancilla and
system registers in the state


_ρ_ 0 = _|_ + _⟩⟨_ + _|⊗_ _ρS_ (30)


and the environment register in the state _ρE_ 1 . As shown
in Fig. 1, we implement _X_ 1 [(] _[c]_ [)] and _Y_ 1 [(] _[a]_ [)] by sampling _X_ 1 and
_Y_ 1 from _D_ 1, followed by tracing out of the environment _E_ 1.
The resulting state is



_µ_ = _[ζ]_ [ 2]

_T_



_T_
#### ∑ µ j,

_j_ =1



_ρ_ 1 = Tr _E_ 1




_Y_ 1 [(] _[a]_ [)] _X_ 1 [(] _[c]_ [)][(] _[ρ]_ [0] _[ ⊗]_ _[ρ][E]_ 1 [)] _[X]_ 1 [(] _[c]_ [)][†] _Y_ 1 [(] _[a]_ [)][†]




(31)



where _ζ_ = ∏ _[K]_ _j_ =1 _[α]_ [(] _[j]_ [)][.]


**Output:** Estimated expectation value _µ_


_K_ -collision map, _M_ - _K_ . Then, we measure the observable
_σ_ _[x]_ _⊗_ _O_ in the ancilla and the system register. This corresponds to a single run of the algorithm. The outcome of the
_j_ -th run (for any _j ∈_ [1 _,_ _T_ ]) is a random variable _µ_ _j_ whose
expectation value is given as,


E[ _µ_ _j_ ] = Tr[ _O MK_ [ _ρS_ ]] _/ζ_ [2] _,_


where _ζ_ = ∏ _[K]_ _j_ =1 _[α]_ [(] _[j]_ [)][. Overall, by taking some] _[ T]_ [ repetitions]
of this procedure, we collect random variables _{µ j}_ _[T]_ _j_ =1 [,]
such that



For simplicity, let us define the map Φ [(] _j_ _[PQ]_ [)] as



Φ [(] _j_ _[PQ]_ [)] [ _._ ] = Tr _E_ _j_




- - - _P_ _._ _⊗_ _ρE_ _j_ _Q_ [†] _,_ (32)



which represents applying the operator _P_ from the left and
_Q_ [†] from the right, followed by the tracing out of the environment register _E_ _j_ . We can write _ρ_ 1 in this notation as
follows:



_ρ_ 1 = [1]

2





_|_ 0 _⟩⟨_ 0 _|⊗_ Φ [(] 1 _[YY]_ [)] [ _ρS_ ]+ _|_ 0 _⟩⟨_ 1 _|⊗_ Φ1 [(] _[YX]_ [)] [ _ρS_ ]


              


+ _|_ 1 _⟩⟨_ 0 _|⊗_ Φ [(] 1 _[XY]_ [)] [ _ρS_ ]+ _|_ 1 _⟩⟨_ 1 _|⊗_ Φ1 [(] _[XX]_ [)] [ _ρS_ ]



_._



_µ_ = _[ζ]_ [ 2]

_T_



_T_
### ∑ µ j,

_j_ =1



approximates the desired expectation value within _ε_ additive accuracy with a success probability of at least



Next, we prepare the environment register in the state
_ρE_ 2, and apply the next set of unitaries (obtained by sampling from _D_ 2), followed by the tracing out the environment _E_ 2. It is easy to see that this sequence leave us with



7


a composition of the maps, resulting in the state:





_|_ 0 _⟩⟨_ 0 _|⊗_ Φ [(] 2 _[YY]_ [)] Φ [(] 1 _[YY]_ [)] [ _ρS_ ]



_ρ_ 2 = [1]

2



_ρ_ 2 = [1]



+ _|_ 0 _⟩⟨_ 1 _|⊗_ Φ [(] 2 _[YX]_ [)] Φ [(] 1 _[YX]_ [)] [ _ρS_ ]

+ _|_ 1 _⟩⟨_ 0 _|⊗_ Φ [(] 2 _[XY]_ [)] Φ [(] 1 _[XY]_ [)] [ _ρS_ ]

          
+ _|_ 1 _⟩⟨_ 1 _|⊗_ Φ [(] 2 _[XX]_ [)] Φ [(] 1 _[XX]_ [)] [ _ρS_ ] _._ (33)



Continuing in this way _K_ times, we obtain by induction,





_|_ 0 _⟩⟨_ 0 _|⊗⃝_ _[K]_ _j_ =1 [Φ][(] _j_ _[YY]_ [)] [ _ρS_ ]



_ρK_ = [1]

2



_ρK_ = [1]



+ _|_ 0 _⟩⟨_ 1 _|⊗⃝_ _[K]_ _j_ =1 [Φ][(] _j_ _[YX]_ [)] [ _ρS_ ]

+ _|_ 1 _⟩⟨_ 0 _|⊗⃝_ _[K]_ _j_ =1 [Φ][(] _j_ _[XY]_ [)] [ _ρS_ ]


+ _|_ 1 _⟩⟨_ 1 _|⊗⃝_ _[K]_ _j_ =1 [Φ][(] _j_ _[XX]_ [)] [ _ρS_ ]







_._ (34)



Thus,

           _µ −_ Tr _O_ _M_        - _K_ [ _ρS_ ] _≤_ _ε/_ 2 _,_ (38)
��� ����


with at least 1 _−_ _δ_ probability for

_T ≥_ [8] _[∥][O][∥]_ [2][ ln][(][2] _[/][δ]_ [)] _[ζ]_ [ 4] _._

_ε_ [2]

Now, for any _j ∈_ [1 _,_ _K_ ], we get
��� _U_ _j −U_                    - _j_ ��� _≤_ _ε_ _′_ = 6 _Kε∥O∥_


from the statement of Lemma 2. Then, using Lemma 1 and
the triangle inequality, we obtain

    -    - [�]
_µ −_ Tr _O MK_ [ _ρS_ ]
���� ���

     -      - [�]      -      -      -      - [�]
_≤_ _µ −_ Tr _O_ _M_ - _K_ [ _ρS_ ] + Tr _O_ _M_ - _K_ [ _ρS_ ] _−_ Tr _O MK_ [ _ρS_ ]
���� ��� ���� ���


_≤_ _ε/_ 2 + _ε/_ 2 = _ε._ (39)


To estimate the circuit depth of Algorithm 1 and the number of classical repetitions _T_, we need to find _ζ_, which crucially depends on the choices of the parameters _r_ _j_ . For the
_j_ -th collision, Lemma 2 shows how we can consider the
LCU decomposition _U_ [�] _j_ approximating _U_ _j_ = _e_ _[−][i]_ [∆] _[t][β]_ _[j][H]_ with
sufficient accuracy. If _β_ = max _j β j_ and _r_ = min _j r_ _j_, then the
sum of LCU coefficients _α_ [(] _[j]_ [)] = ∑ _k |α_ _jk|_ satisfies,

_α_ [(] _[j]_ [)] _≤_ _e_ [(] _[β]_ _[j]_ [∆] _[t]_ [)][2] _[/][r][ j]_ _≤_ _e_ [(] _[β]_ [∆] _[t]_ [)][2] _[/][r]_ _,_ (40)


with


         _ζ ≤_ _e_ [(] _[β]_ [∆] _[t]_ [)][2] _[/][r]_ [�] _[K]_ _._ (41)


Thus we ensure that _ζ_ = _O_ (1) by choosing _r_ = _O_ ( _β_ [2] ∆ _t_ [2] _K_ ).
Consequently, the number of classical repetitions needed
is



Finally, we measure the ancilla and system registers with
the observable _σ_ _[x]_ _⊗_ _O_ . This constitutes one run of Algorithm 1.
Let us now look at the outcome of any such run. On
measuring the ancilla in _σ_ _[x]_, the first and the last terms
of Eq. (34) disappear, and so the output of the _k_ -th run
becomes,





_µk_ = 2 [1] [Tr]  _O_








     -      -      -      - [�]
_⃝_ _[K]_ _j_ =1 [Φ][(] _j_ _[YX]_ [)] _ρS_ + _⃝_ _[K]_ _j_ =1 [Φ][(] _j_ _[XY]_ [)] _ρS_  _._ (35)



Then, by the linearity of expectation, we have



E[ _µk_ ] = [1]




   -   _ζ_ [2] [Tr] _OM_ [�] _K_ [ _ρS_ ] _,_ (36)








   -   _ζ_ [1][2] [Tr] _⃝_ _[K]_ _j_ =1 [Φ][�] _[j]_ [[] _[ρ][S]_ []] = _ζ_ [1]



_T_ = _O_




_∥O∥_ [2] log(1 _/δ_ )

_ε_ [2]



_._ (42)



where _ζ_ is as defined in Algorithm 1. Thus, the outcome
of each run is a random variable whose expectation value
gives an estimate of the desired quantity (up to a multiplicative factor of 1 _/ζ_ [2] ).
We observe that the positive operator-valued measurement of the state at the end yields some eigenvalue of _O_ in
the range [ _−∥O∥,_ _∥O∥_ ]. So, outcome _µk_ satisfies,


_−∥O∥_ _ζ_ [2] _≤_ _ζ_ [2] _µk ≤∥O∥_ _ζ_ [2] _._ (37)


Thus, after _T_ runs, we have a set of random variables
_{µk}_ _[T]_ _k_ =1 [. By using Hoeffding’s inequality, we can ensure]



which gives the overall circuit depth per coherent run as



Now, for the circuit depth of each coherent run, the
quantum circuit in Fig. 1 consists of 2 _K_ unitaries of the
form _X_ _j_ [(] _[c]_ [)] and _Yj_ [(] _[a]_ [)] . Each of these unitaries comprises
_qr_ Pauli operators and _r_ controlled single-qubit rotations,
where _q_ is the truncation parameter of the Taylor series.
Thus, the overall circuit depth will be _τd_ = _O_ ( _K_ ( _qr_ + _r_ )) =
_O_ ( _Kqr_ ). For the above choice of _r_, Eq. (24) gives




  - log( _β_ _K∥O∥_ ∆ _t/ε_ )
_q_ = _O_
loglog( _β_ _K∥O∥_ ∆ _t/ε_ )




_,_



_τd_ = _O_ - _β_ [2] _K_ [2] ∆ _t_ [2] log( _β_ _K∥O∥_ ∆ _t/ε_ )
loglog( _β_ _K∥O∥_ ∆ _t/ε_ ) [+] _[K][τ][ρ][E]_



_µ_ = _[ζ]_ [ 2]

_T_



_T_
### ∑ µk,

_k_ =1




_._ (43)



is close to its expectation value. Indeed,






 _≤_ 2exp



8 _ζ_ [4] _∥O∥_ [2]











Here, the additive term _KτρE_ appears because, in each run
of the circuit, the sub-environment needs to be prepared _K_
times, each time requiring a circuit depth of at most _τρE_ .
This completes the proof.



Pr





    -     - [�]
 _µ −_ Tr _O_ _M_ - _K_ [ _ρS_ ] _≥_ _ε/_ 2
���� ���



_T_ _ε_ [2]

_−_



_._



8


TABLE I. Comparison of the costs of estimating the expectation value of an observable _O_ with respect to a quantum state that has
undergone the _K_ -collision map of Definition 2 using different near-term Hamiltonian simulation algorithms. The goal of the algorithm
is to output the desired expectation value within an additive accuracy of _ε_ with a constant success probability. Here, the ancilla qubits
indicate the number of additional qubits (other than the system and environment qubits) required. We assume that for any of the _K_
collisions, the total Hamiltonian is a linear combination of at most _L_ strings of _n_ -qubit Pauli operators, with the total weight of the
coefficients upper bounded by _β_ . Each collision corresponds to evolving according to the corresponding (total) Hamiltonian for a time
∆ _t_ . Also, _τρE_ = max _j∈_ [1 _,K_ ] _τρE j_, where _τρE j_ is the circuit depth of the unitary preparing the sub-environment _E j_ in the state _ρE j_ .


Algorithm No. of ancilla qubits Circuit depth per coherent run Classical repetitions




- _β_ [2] _K_ [2] _∥O∥L_ ∆ _t_ [2]

_ε_ + _KτρE_




- _β_ [2] _K_ [2] _∥O∥L_ ∆ _t_ [2]







1st-order Trotter 0 _O_




- _β_ [2] _K_ [2] _∥O∥_ ∆ _t_ [2]

_ε_ + _KτρE_




- _β_ [2] _K_ [2] _∥O∥_ ∆ _t_ [2]







qDRIFT 0 _O_






2 [1] _k_ - _∥O∥_



_O_


_O_





 _O_



1

- 2 _k_

+ _KτρE_



_ε_



2 _k_ -order Trotter 0 _O_



 _L_ ( _Kβ_ ∆ _t_ ) [1][+] 2 [1]



Single-Ancilla LCU 1 _O_ - _β_ [2] _K_ [2] ∆ _t_ [2] log( _β_ _K∥O∥_ ∆ _t/ε_ )
loglog( _β_ _K∥O∥_ ∆ _t/ε_ ) [+] _[K][τ][ρ][E]_




_O_




_∥O∥_ [2]

_ε_ [2]


_∥O∥_ [2]

_ε_ [2]


_∥O∥_ [2]

_ε_ [2]


_∥O∥_ [2]

_ε_ [2]













**C.** **Comparing the complexity of implementing a**
**Markovian** _K_ **-collision map using various near-term**
**Hamiltonian procedures**


We now compare the complexity of other near-term
Hamiltonian simulation algorithms to output an _ε_ -additive
accurate estimate of the expectation value Tr[ _O_ _MK_ [ _ρS_ ]].
Primarily, we will compare the circuit depth, the number
of ancilla qubits, and the number of classical repetitions
needed. At the onset of the early fault-tolerant era, it is
better to have multiple independent runs of a short-depth
quantum circuit than a single run of a very deep quantum
circuit. Thus, it is standard to separately analyze the cost
of each run and the number of classical repetitions separately. The total complexity is, of course, the product of
the circuit depth per coherent run and the total number of
classical repetitions.


First, we observe that most Hamiltonian simulation algorithms can be incorporated into Algorithm 1. Steps 2a
and 2b, which are essentially implementing the operator
_U_ _j_ = _e_ _[−][i]_ [∆] _[t][β]_ _[j][H][ j]_ in the Hamiltonian simulation by SA-LCU,
can be replaced with other near-term techniques such as
qDRIFT or Trotterization. In Step 3, a direct measurement of _O_ on the system register would suffice for these
two methods, as they do not require any ancilla registers.
So, Lemma 1 can also be modified to incorporate different
procedures: any Hamiltonian simulation procedure needs
to be implemented with precision _O_ ( _ε/_ ( _K∥O∥_ )), in order
to output an _ε_ -accurate estimate of the expectation value
of _O_ . This circuit depth is essentially the cost of composing
the underlying Hamiltonian simulation algorithm _K_ times.


On the other hand, the expectation value of _O_ can ei


ther be measured incoherently or coherently. The incoherent approach involves simply measuring _O_ with respect to
the prepared state, requiring _O_ ( _∥O∥_ [2] _/ε_ [2] ) classical repetitions. It is also possible to use quantum amplitude estimation [59, 60] to estimate this quantity in cost scaling
as 1 _/ε_ coherently. However, this requires access to a block
encoding [5, 14] of the observable _O_, adding to the number of ancilla qubits required. More precisely, given an
( _αO,_ _aO,_ 0) block-encoding of _O_, we can coherently estimate
the desired expectation value using amplitude estimation
for _O_ - _αO_ ( _τd_ + _τO_ ) _/ε_ - cost. Here, _τd_ is the circuit depth of
the composition of _K_ Hamiltonian simulation algorithms,
and _τO_ is the circuit depth of implementing the block encoding of _O_ . So, along with the number of ancilla qubits,
the circuit depth also increases substantially. Thus, amplitude estimation is not a technique that can be deployed
in early fault-tolerant quantum computers. Consequently,
we restrict ourselves to estimating the cost using the incoherent approach. Table I summarizes the complexities associated with different near-term Hamiltonian simulation
methods.
Let us begin by considering the circuit depth of the Firstorder Trotter method [1, 53]. We note that no ancilla
qubit (other than the system and environment registers) is
needed. The worst-case circuit depth of simulating the _j_ -th
collision map scales with the number of terms in the corresponding total Hamiltonian ( _L_ _j_ ) as _O_ ( _KLβ_ _j_ [2][∆] _[t]_ [2] _[∥][O][∥][/][ε]_ [)][.]
Then, by composing _K_ such collision maps and using the
upper bounds _β_ and _L_, we obtain the circuit depth for each
coherent run as







_τd_ = _O_




- _K_ [2] _Lβ_ [2] ∆ _t_ [2] _∥O∥_

_ε_ + _KτρE_



_._



9


In order to estimate the expectation value of observable _O_
with a success probability of at least 1 _−_ _δ_, the number of
independent runs required is _O_ ( _∥O∥_ [2] log(1 _/δ_ ) _/ε_ [2] ).
The randomized Hamiltonian simulation approach,
qDRIFT [4], also requires no ancilla qubits. Moreover, the
circuit depth does not depend on the number of terms in
the Pauli decomposition of the underlying Hamiltonian.
The overall circuit depth to simulate the Markovian _K_ collision map is given by







_._



_τd_ =




- _K_ [2] _β_ [2] ∆ _t_ [2] _∥O∥_

_ε_ + _KτρE_




- _K_ [2] _β_ [2] ∆ _t_ [2] _∥O∥_



Thus, compared to SA-LCU, both First-order Trotter and
qDRIFT require an exponentially worse circuit depth in
terms of 1 _/ε_ .
We now move on to the complexity of implementing the
Markovian _K_ -collision map by using higher-order Trotter
methods [53]. For any positive number _k_, the circuit depth
of the 2 _k_ -order Trotter method for implementing _e_ _[−][i]_ [∆] _[tH][ j]_ to
within an accuracy of _O_ ( _ε/K∥O∥_ ) is







1 - _K∥O∥_

2 _k_ _·_



1 

2 _k_



 _._



_ε_



1 

- 2 _k_



_O_



5 _[k][−]_ [1] _L_ _j_ - _β_ _j_ ∆ _t_ �1+ 21



Then, composing the previously mentioned simulation procedure a total of _K_ times requires a circuit depth of



would require some sophisticated controlled logic in executing this [55]. Although the circuit depth


_τd_ = _O_     - _KLβ_ ∆ _t_ + _K_ log( _K∥O∥/ε_ )+ _KτρE_     - _,_


has a better dependence on _K_ and ∆ _t_, as compared to nearterm Hamiltonian simulation methods, implementing a _K_ collision map using qubitization is beyond the reach of
early fault-tolerant quantum computers.
Overall, we have developed a general framework to simulate _K_ memoryless collisions on a quantum computer using various near-term Hamiltonian simulation procedures.
In the next section, we use such collisions to simulate Lindbladian dynamics. The framework introduced here can
also be adapted to incorporate memory effects from interactions between the environment subsystems, leading to
non-Markovian dynamics. We later define and simulate a
non-Markovian _K_ -collision map in Sec. V.


**IV.** **SIMULATING LINDBLADIAN DYNAMICS USING**
**QUANTUM COLLISION MODELS**


The Lindblad master equation describes the time evolution of a quantum system undergoing dissipative dynamics
in the presence of an environment. It assumes that the underlying system is weakly coupled to the environment at all
times so that the Born-Markov and secular approximations
hold [6]. The Lindblad operator is, in fact, the generator
of any quantum Markov semigroup [9]. For a system with
Hamiltonian _HS_, the Lindblad master equation, describing
the reduced state of the system _ρS_, is given by







2 [1] _k_ _·_ - _K∥O∥_










_ε_



1

- 2



_τd_ = _O_


= _O_



5 _[k][−]_ [1] _KL_ ( _β_ ∆ _t_ ) [1][+] 2 [1]



5 _[k][−]_ [1] _L_ ( _Kβ_ ∆ _t_ ) [1][+] 2 [1]



1

- 2 _k_

+ _KτρE_



_L_ [ _ρS_ ] _≡_ _[∂ρ][S]_

_∂t_ [=] _[ −][i]_ [[] _[H][S][,]_ _[ρ]_ []+][∑] _j_







2 [1] _k_ _·_ - _∥O∥_






 _._ (44)




- _A_ _jρA_ [†] _j_ _[−]_ [1] _j_ _[A]_ _[j][,]_ _[ρ][}]_ _._

2 _[{][A]_ [†]



1

- 2 _k_

+ _KτρE_



1

- 2



_ε_



Note that the pre-factor (( _β_ _L_ ) [1][+][1] _[/]_ [(][2] _[k]_ [)] ) in the complexity
of Trotter-based methods scales with the norm of the sum
of the nested commutators of the local Pauli terms in the
description of the Hamiltonian. In certain cases, the prefactor scaling is better than the worst-case bounds we consider here. We refer the readers to Ref. [53] for more details. Although higher-order Trotter methods do not require any ancilla qubits, the exponential scaling in the prefactor makes it difficult to implement these methods for
high _k_ values. Typically, in practice, _k_ = 1 (the secondorder method) and _k_ = 2 (the fourth-order method) are
implemented.
Finally, the state-of-the-art Hamiltonian simulation
method, qubitization, requires access to a block encoding
of the underlying Hamiltonian [5]. In the case of simulating each collision _U_ _j_ = _e_ _[−][i]_ [∆] _[t][β]_ _[j][H][ j]_, a block encoding to _H_ _j_
is needed, which requires _O_ (log _L_ _j_ ) ancilla qubits. However, since we have to implement a composition of these
individual collision maps, overall, we need _O_ (log _L_ ) ancilla
qubits to implement each of these maps. Additionally, we



(45)
Here, the evolution comprises two distinct parts: a unitary
component governed by the system Hamiltonian _HS_ and
a dissipative component described by the so-called quantum jump operators _A_ _j_, obtained from the interaction between the system and the environment. Note that for a
_d_ -dimensional system, _A_ _j ∈_ C _[d][×][d]_, are not necessarily Hermitian. Simulating the Lindblad dynamics for time _t_ on
a quantum computer essentially means implementing the
map _e_ _[L][ t]_ .
We can now analyze the complexity of simulating Lindblad dynamics using the Markovian _K_ -collision map from
Sec. III A. As discussed in the previous section, quantum
collision models simulate open system dynamics by discretizing the continuous system-environment interaction
into a sequence of brief collisions between the system and
independent sub-environments. The correspondence between Lindblad dynamics and the collision model has been
derived earlier [21, 24, 55]. We will follow the constructions and error analysis of the recent work by Pocrnic et
al. [55]. The choices of the time of each collision (∆ _t_ ) and
the total number of collisions ( _K_ ) are crucial for quantum



10


collision models to approximate Lindbladian dynamics. It
is only for the right choices that a Markovian _K_ -collision
map can approximate Lindblad dynamics, and (a slightly
modified version of) Algorithm 1 can be used to efficiently
estimate Tr[ _O e_ _[L][ t]_ [ _ρS_ ]] for any observable _O_ .
As in Sec. III, we consider an _n_ -qubit system with Hamiltonian _HS_, prepared initially in the quantum state _ρS_ .
The environment consists of _m_ discrete, single qubit subenvironments prepared in some state _ρE_ _j_, for _j ∈_ [1 _,_ _m_ ]. As
before, these sub-environments sequentially interact with
the system over small but equal time intervals, ∆ _t_, driving
its evolution. The system evolves under its free Hamiltonian _HS_, while the _j_ -th sub-environment evolves under its
local Hamiltonian _HE_ _j_ . The interaction Hamiltonian _HI_ _j_
governs the interaction between the system and the _j_ -th
sub-environment.
While Lindbladian dynamics effectively couple the system to all _m_ environmental subsystems simultaneously,
the collision model operates sequentially, with the system
interacting with one environment at a time. To reconcile this difference, we renormalize the system Hamiltonian as _HS →_ _m_ [1] _[H][S]_ [.] Furthermore, the Lindblad dynam
ics is derived from collision maps in a regime where the
system-environment coupling parameter _λ_ is tuned to satisfy _λ_ [2] ∆ _t_ = 1. As ∆ _t_ is typically small, intuitively, this results in repeated momentary collisions between the system and a strongly coupled sub-environment. This ensures
the coupling is strong enough to drive dissipative dynamics even within a short interaction time ∆ _t_ . In the remainder of this section, we shall assume that the coupling con_√_
stant _λ_ is diverging, i.e., _λ →_ 1 _/_ ∆ _t_, and we refer the

readers to Refs. [22, 24, 55] for detailed discussions. Another standard assumption, for the derivation of Lindblad
dynamics from collision models, is that the state of each
sub-environment or the interaction Hamiltonians are so
chosen that _∀_ _j,_ Tr _E_ _j_ [[ _HI_ _j_ _,_ _ρS ⊗_ _ρE_ _j_ ]] = 0. This is equivalent
to considering the overall state of the environment _E_ to be
thermal.
Let us now describe the structure of the Hamiltonian we
consider that satisfies the above constraints. We assume
that the system Hamiltonian _HS_ (rescaled by _m_ ) is a linear
combination of strings of Pauli operators given by



**Algorithm 2:** Algorithm to estimate the
expectation value of an observable _O_ with respect
to the Lindblad map applied to a quantum state.

**Input:** Initial system state in _ρS_, _m_ single qubit
sub-environment states, each initialized in the
state defined in Eq. (46), observable _O_, unitaries
_U_ �1, .... � _Um_, the total number of repetitions _ν_, and
precision _ε_ _[′]_, where the LCU decomposition of each
_U_   - _j_ = ∑ _k α jkWjk_, such that _∀_ _j ∈_ [1 _,_ _m_ ],
���� _U_ _j −_ _e−i_ ∆ _tβ_ _jH j_ ��� _≤_ _ε_ _′_ .


1. Initialize the system and the ancilla in the state _ρS_
and _|_ + _⟩_, respectively.


2. For iterations from _j_ = 0 to _K −_ 1, where _K_ = _mν_ :


a. Set _ℓ_ = _j_ (mod _m_ )+ 1.


b. Initialize the environment register in state _ρEℓ_ .

c. Draw two i.i.d. samples _X_ _j_ and _Yj_ from the
ensemble




  _Dℓ_ = _Wℓk,_ _[α][ℓ][k]_

_α_ [(] _[ℓ]_ [)]




  _Dℓ_ = _Wℓk,_ _[α][ℓ][k]_




_,_



where _α_ [(] _[ℓ]_ [)] = ∑ _k |αℓk|_

d. Apply the controlled unitary _X_ _j_ [(] _[c]_ [)] and the

anti-controlled unitary _Yj_ [(] _[a]_ [)] to the system.


e. Perform a partial trace over the environment
register.


3. Measure the joint ancilla and system state on the
observable ( _σ_ _[x]_ _⊗_ _O_ ) and record the measurement
outcome as _µi_ .


4. Repeat Steps 1 to 3 a total of _T_ times.


5. Compute the final estimate _µ_ as:



_µ_ = _[ζ]_ [ 2]

_T_



_T_
#### ∑ µ j,

_j_ =1



_HS_ =



_LS_
### ∑ λ jPj/m,

_j_ =1



such that _βS_ = ∑ _j |λ_ _j|_ . In our case, the environment is a
discrete sum of _m_ sub-environments, such that _HE_ _j_ = _βE_ _j_ _σ_ _[z]_

(equivalent to the number operator up to an energy shift).
Each sub-environment is prepared in the single qubit thermal state (at some inverse temperature _ω_ ), i.e.,



_ρE_ _j_ = _[|]_ [0] _[⟩⟨]_ [0] _[|]_ [+] _[e][−][ω][ |]_ [1] _[⟩⟨]_ [1] _[|]_ _._ (46)

1 + _e_ _[−][ω]_



where _ζ_ = ∏ _[K]_ _j_ =1 _[α]_ [(] _[j]_ [)][.]


**Output:** Estimated expectation value _µ_


entangled pure state


_|ψ⟩_ = _[|]_ [00] _[⟩]_ ~~_√_~~ [+] _[e][−][ω][/]_ [2] _[ |]_ [11] _[⟩]_ _,_

1 + _e_ ~~_[−][ω]_~~


and then tracing out the second qubit. Henceforth, we will
assume that preparing _ρE_ _j_ is a constant-depth unitary procedure.


We consider that the interaction Hamiltonian corresponding to the _j_ -th collision (between the system and _j_ th sub-environment) _HI_ _j_ can also be expressed as a linear
combination of some _LI_ _j_ Pauli operators. For instance, we
can express it in terms of the Lindbladian jump operators



This state can be prepared efficiently by first preparing the



11


FIG. 2. The circuit to estimate the expectation value of an observable _O_ for a system evolved under Lindbladian dynamics. The ancilla
qubit and the system is initialized in _|_ + _⟩⟨_ + _|_ and _ρS_ respectively. In each block, the unitaries _X_ _j_ and _Yj_ are independently sampled
and applied as controlled and anti-controlled operations conditioned on the ancilla qubit. After each interaction, the corresponding
environment sub-system _ρE_ _j_ is traced out, enforcing the Markovian condition. This process is repeated cyclically over _m_ environments
for _ν_ iterations. Finally, the observable _σ_ _[x]_ _⊗_ _O_ is measured to estimate the time-evolved expectation value of _O_ .



as


        _HI_ _j_ = _A j ⊗_ _σ_ [+] + _A_ [†] _j_ _[⊗]_ _[σ]_ _[−]_ [�] _,_


where _σ_ _[±]_ = ( _σ_ _[x]_ _±iσ_ _[y]_ ) _/_ 2 are the raising and lowering operators respectively. We assume _βI_ _j_ denotes the total weight
of the coefficients in the description of _HI_ _j_ and that this
Hamiltonian has _LI_ _j_ terms. Note that in some cases, the
individual jump operator _A j_ may itself be unitary [55].
Overall, the total Hamiltonian corresponding to the _j_ -th
collision is given by:



The value of _ν_, i.e., the number of times the sequence of _m_
collisions should be repeated so that a ( _m,_ _ν_ )-collision map
approximates _e_ _[L][ t]_ up to an additive accuracy _ε_ was found
in Ref. [55]. For this, let us define



�4

- _βS,_ _βIℓ,_ _βEℓ_ - _,_ (50)



Γ = _[∥][L][ ∥]_ 1 [2] _→_ 1 +
_m_





max
_ℓ∈_ [1 _,m_ ]



where _∥L ∥_ 1 _→_ 1 is the induced 1-norm of _L_ [ _._ ]. Now, we
restate the result of [55] here:


**Lemma 3** (Corollary 2.1 of [55]) **.** _For ε ∈_ (0 _,_ 1) _, a_ ( _m,_ _ν_ ) _-_
_collision map as defined in Definition 3, with interaction time_
∆ _t_ = _t/ν,_




_,_ (47)



_H j_ = [1]

_β j_




- 1

_m_ _[H][S]_ [ +] _[H][E]_ _[j]_ [ +] _[λ]_ _[H][I]_ _[j]_



_√_
where _β_ _j ≤_ _βS/m_ + _λβI_ _j_ + _β_ _E j_, and _λ_ = 1 _/_ ∆ _t_ . Hence, _H j_

also can be expressed as a linear combination of _LS_ + _LI_ _j_ +1
Pauli operators with total weight at most _β j_ .
Let us now discuss the choice of ∆ _t_ and _K_ for a _K_ -collision
map to be close (in induced 1-norm) to _e_ _[L][ t]_ [ _._ ]. The collisions between the system and the _m_ sub-environments
occur one by one in a fixed order ( _E_ 1, _E_ 2, _..._, _Em_ ). Now, to
simulate the Lindblad dynamics for a total evolution time
of _t_, this sequence is repeated _ν_ times, with each collision
occurring for a time interval ∆ _t_ = _t/ν_ . Thus, in all, there
are _K_ = _m_ _×_ _ν_ collisions, making it an ( _m,_ _ν_ )-collision map.
As before, the interaction of _j_ -th sub-environment with
the system is given by


_U_ _j_ = _e_ _[−][i][β]_ _[j][H][ j]_ [∆] _[t]_ _,_


and, from Definition 1, the _j_ -th collision map is




_t_ [2] _m_







_ν ≥_ _O_



_ε_ [Γ]



_,_ (51)




_._ (48)



_and λ →_ ~~_√_~~ 1

∆ _t_ _[satisfies]_

_L t_
_e_ _−_ _Mm,ν_ [ _._ ] (52)
��� ���1 _→_ 1 _[≤]_ _[ε][.]_

This demonstrates that the ( _m,_ _ν_ )-collision map _Mm,ν_ [ _._ ]
provides an accurate approximation of Lindbladian dynamics, provided _ν_ is as stated in Lemma 3. We use Hamiltonian simulation by SA-LCU and Algorithm 2 to achieve
this.
We intend to implement the circuit shown in Fig. 2. Each
sequence of unitaries _Qi_ corresponds to _m_ collisions between the system and each single-qubit sub-environment
_E_ 1 through _Em_ . As this is repeated _ν_ times, there are overall
_K_ = _mν_ collisions. Since each block _Qi_ corresponds to collisions with the same set of sub-environments, we do not
have _K_ distinct collisions with distinct sub-environments,
but rather _ν_ blocks of _m_ -collisions between the system and
the _m_ sub-environments. So, to implement the circuit in
Fig. 2, we slightly modify Algorithm 1.
We rewrite the ( _m,_ _ν_ )-collision map as

_Mm,ν_ [ _._ ] = _⃝_ _[K]_ _j_ = _[−]_ 0 [1][Φ] _[j]_ [(][mod] _[ m]_ [)+][1] [[] _[.]_ []] _[,]_ (53)


where _K_ = _mν_ . The right-hand side of Eq. (53) is simply a Φ _j_ [ _._ ] map, composed _K_ times, where the cyclic order of the _ν_ repetitions is respected. Thus, the problem



Φ _j_ [ _._ ] = Tr _E_ _j_




- - _U_ _j_ _._ _⊗_ _ρE_ _j_ _U_ _j_ [†]



The ( _m,_ _ν_ )-collision map is defined as follows:


**Definition 3** (( _m,_ _ν_ )-collision map) **.** _Let_ Φ1 _to_ Φ _m be the col-_
_lision maps as defined in Definition 1. Then a_ ( _m,_ _ν_ ) _-collision_
_map, Mm,ν_ _, is defined as the application of these maps com-_
_posed ν times as follows:_


          -          - _◦ν_
_Mm,ν_ [ _._ ] _≡_ _⃝_ _[m]_ _j_ =1 [Φ] _[j]_ [ [] _[.]_ []] _._ (49)



12


of simulating Lindbladian dynamics implies implementing
a specific _K_ -collision map. Just as in Sec. III A, this map
can be implemented using a number of near-term Hamiltonian simulation algorithms. In our case, this change is
reflected in Step 2a. of Algorithm 2. For the _j_ -th iteration in
Step 2 of Algorithm 1, the Φ _ℓ_ [ _._ ] map is implemented, where
_ℓ_ = _j_ (mod _m_ )+ 1, i.e. it implements a collision between the
system and the single qubit environment _Eℓ_ . Overall, the
correctness of Algorithm 2 is similar to Theorem 1. Formally, we state the results via the following theorem:


**Theorem 2.** _Let us consider an observable O, an n-qubit sys-_
_tem prepared in the initial state ρS, and m single-qubit sub-_
_environments with each initialized in the single-qubit ther-_
_mal state defined in Eq._ (46) _. Let ε,_ _δ ∈_ (0 _,_ 1) _and K_ = _mν,_
_where_



For any valid initial state of the system, _ρS_, we have from
the definition of induced-1 norm:

_tL_ _ε_
_e_ [ _ρS_ ] _−_ _Mm,ν_ [ _ρS_ ] (59)
��� ���1 _[≤]_ 2 _∥O∥_ _[.]_


Using the tracial version of Hölder’s inequality (Lemma
A5) we obtain

      -       -       -       - [�] _ε_
Tr _Oe_ _[t][L]_ [ _ρS_ ] _−_ Tr _OMm,ν_ [ _ρS_ ] _≤_ (60)
��� �� 2 _[.]_


Then, the triangle inequality gives us

       -        - [�]
_µ−_ Tr _Oe_ _[t][L]_ [ _ρS_ ]
���� ���

_≤_ �� _µ −_ Tr    - _OMm,ν_ [ _ρS_ ]���

+ Tr     - _OMm,ν_ [ _ρS_ ]� _−_ Tr     - _Oe_ _[t][L]_ [ _ρS_ ]
��� ����



_≤_ _[ε]_




_[ε]_ _[ε]_

2 [+] 2





_._ (54)



_ν_ = _O_




_t_ [2] _m∥O∥_ Γ


_ε_



2 [=] _[ ε][.]_ (61)



_Then, for ε_ _[′]_ = _ε/_ (12 _K∥O∥_ ) _, Algorithm 2 outputs an estimate_
_µ with a probability of at least_ 1 _−_ _δ_ _, such that:_

           _µ −_ Tr _Oe_ _[L][ t]_ [ _ρS_ ] _≤_ _ε,_ (55)
��� ����


_using T runs of the circuit shown in Figure 2, where_



In our case, _K_ = _mν_, ∆ _t_ = _t/ν_, and _τρE_ = _O_ (1). Moreover,
_β_ depends on _t_ and _ε_ as



Now, Theorem 1 gives the circuit depth of a _K_ -collision
map as



_τd_ = _O_ - _β_ [2] _K_ [2] ∆ _t_ [2] log( _β_ _K∥O∥_ ∆ _t/ε_ )
loglog( _β_ _K∥O∥_ ∆ _t/ε_ ) [+] _[K][τ][ρ][E]_




_._



_β_ = max
_ℓ∈_ [1 _,m_ ] [(] _[β]_ _[j]_ [) =][ max] _ℓ_







_T_ = _O_




_∥O∥_ [2] log(1 _/δ_ )

_ε_ [2]



_._ (56)



��



_ν_ [1]

_t_ _[β][I][ℓ]_ [+] _m_



_ν_







_m_ _[β][S]_ [ +] _[β][E][ℓ]_



_Moreover, the circuit depth of each run is_



_ν_

(62)
_t_ _[×]_ _[O]_ [ (] _[β]_ [max][)] _[,]_








~~�~~
_≤_



_τd_ = _O_ [�]




_m_ [3] _t_ [3] _∥O∥_

Γ _β_ max [2]
_ε_



_,_ (57)



where, in the last line, we have used the fact that _βEℓ_ = 1
for any _ℓ_ _∈_ [1 _,_ _m_ ]. Here, _β_ max is as defined in the statement
of this Theorem. Substituting these parameters, we obtain



_where_




    
_β_ max = max _βIℓ,_
_ℓ∈_ [1 _,m_ ]



_t_

_ν_







_t_
_m_ [2] _ν_ _[β][S][,][ β][E][ℓ]_











_._ (58)



_τd_ = _O_ - _β_ [2] _m_ [2] _t_ [2] log( _β_ _mt∥O∥/ε_ ) loglog( _β_ _mt∥O∥/ε_ ) [+] _[m][ν]_





_._


(63)







_νm_ [2] _tβ_ max [2] log( _β_ max _m_ ~~_[√]_~~ _νt∥O∥/ε_ )
loglog( _β_ max _m_ ~~_[√]_~~ _νt∥O∥/ε_ ) [+] _[m][ν]_



_Proof._ First, from the proof of Theorem 1, we know that
for precision _ε_ _[′]_ = _ε/_ (12 _∥O∥K_ ) and _ν_ as chosen in the statement of the Theorem, Algorithm 2 outputs _µ_ such that,


�� _µ −_ Tr                     - _O Mm,ν_ [ _ρS_ ]��� _≤_ _ε_

2 _[,]_


with probability at least (1 _−_ _δ_ ). This requires



_τd_ = _O_


= _O_

[�]



= _O_




_m_ [3] _t_ [3] _∥O∥_



Finally, substituting _ν_ = _O_ ( _t_ [2] _m∥O∥_ Γ _/ε_ ), we obtain




- _m_ [3] _t_ [3] _β_ max [2] _[∥][O][∥]_ [Γ] log( _β_ max _mt_ Γ _∥O∥/ε_ )

_ε_ loglog( _β_ max _mt_ Γ _∥O∥/ε_ )




- _m_ [3] _t_ [3] _β_ max [2] _[∥][O][∥]_ [Γ]







_β_ max [2] [Γ]
_ε_







_._ (64)







_T_ = _O_




_∥O∥_ [2]



log(1 _/δ_ )
_ε_ [2]



_,_



repetitions of the circuit in Fig. 2. Furthermore, from
Lemma 3, we know that our choice of _ν_ ensures

_tL_ _ε_
_e_ _−_ _Mm,ν_ [ _._ ]
��� ���1 _→_ 1 _[≤]_ 2 _∥O∥_ _[.]_



This completes the proof.


There are two primary sources of error in simulating
Lindblad dynamics using quantum collision models: the
first arises from approximating Lindbladian dynamics by
collision models, and the second stems from the simulation



13


TABLE II. Comparison of the complexities for simulating Lindblad dynamics via the quantum collision model using different nearterm Hamiltonian simulation procedures. We consider an _n_ -qubit system, prepared in _ρS_, with Hamiltonian _HS_, expressed as a linear
combination of _LS_ strings of Pauli operators, with total weight _β j_ . The environment is a discrete sum of _m_ single-qubit sub-environments,
each prepared in the (single-qubit) thermal state. The _j_ -th collision corresponds to the interaction Hamiltonian _HI_ _j_, which is also a
linear combination of strings of Pauli operators of _LI_ _j_ terms with total weight _βI_ _j_ . We implement _m_ collisions between the system and
each sub-environment qubit, one by one, such that each block of _m_ collisions is repeated a total of _ν_ times. For any observable _O_, if
_ν_ = _O_ ( _t_ [2] _∥O∥m_ Γ _/ε_ ), our procedures output an estimate that is an _ε_ -additive accurate estimate of Tr[ _O e_ _[L][ t]_ [ _ρS_ ]]. Here, _L,_ _β_ max and Γ are
defined in Eq. (65), Eq. (58), and Eq. (50), respectively.


Algorithm Total no. of. qubits Circuit depth per coherent run Classical repetitions




_Lm_ [3] _t_ [3] _∥O∥_ [2]

Γ _β_ max [2]
_ε_ [2]




_Lm_ [3] _t_ [3] _∥O∥_ [2]








_∥O∥_ [2]

_ε_ [2]


_∥O∥_ [2]

_ε_ [2]


_∥O∥_ [2]

_ε_ [2]


_∥O∥_ [2]

_ε_ [2]


_∥O∥_ [2]

_ε_ [2]















1st-order Trotter _n_ + 1 _O_




_m_ [3] _t_ [3] _∥O∥_ [2]

Γ _β_ max [2]
_ε_ [2]




_m_ [3] _t_ [3] _∥O∥_ [2]







qDRIFT _n_ + 1 _O_



_O_


_O_


_O_


_O_


_O_











2nd-order Trotter _n_ + 1 _O_




   - _∥O∥_
_L_ ( _mt_ ) [9] _[/]_ [4]



_ε_




- _m_ [3] _t_ [3] _∥O∥_



�5 _/_ 4
Γ _β_ max [3] _[/]_ [2]


  


Single-Ancilla LCU _n_ + 2 _O_ 


Γ _β_ max [2]
_ε_




_Lm_ [2] _t_ [2] _∥O∥_

Γ _β_ max
_ε_




_Lm_ [2] _t_ [2] _∥O∥_







2 _k_ -order Trotter [ _k >_ 2] _n_ + 1 _O_ 


of individual collision steps, which depends on the precision of the Hamiltonian simulation technique employed.
While the latter can be mitigated by choosing Hamiltonian simulation algorithms with optimal precision dependence, the error coming from the inherent gap between
the Lindblad map and the ( _m,_ _ν_ )-collision map remains unaffected by the choice of Hamiltonian simulation. Indeed,
Lindbladian dynamics can be approximated only if the system strongly couples with the sub-environments with a
_√_
strength _λ_ = 1 _/_ ∆ _t_ = ~~�~~ _ν/t_ ∝ _t/_ _[√]_ _ε_ that grows stronger



_√_
strength _λ_ = 1 _/_ ∆ _t_ = ~~�~~ _ν/t_ ∝ _t/_ _[√]_ _ε_ that grows stronger

with the time we intend to simulate the dynamics. The
norm of the _j_ -th collision Hamiltonian is at most _β_ _j_, which
also increases monotonically with _t_, affecting the circuit
depth of all methods that simulate Lindblad dynamics using quantum collision models [24].



∆ _t_ = ~~�~~



In contrast, the state-of-the-art methods (i.e., direct approaches) for simulating Lindbladian dynamics require a
cost _O_ ( _t_ polylog - _t/ε_ �) [15–17, 54]. However, most of these
methods require access to block encodings and use complicated, infeasible controlled operations for early faulttolerant quantum computers. On the other hand, quantum
collision models provide an easy-to-implement approach,
not just for Lindbladian maps but also for other open systems dynamics. Moreover, as mentioned in Sec. III C, Algorithm 2 also provides a unified framework to compare
the cost of implementing the ( _m,_ _ν_ )-collision map using different near-term Hamiltonian simulation techniques. Consequently, in the next section, we compare the complexity of Algorithm 2 when other near-term Hamiltonian



techniques are used to output an _ε_ -additive estimate of
Tr[ _O e_ _[L][ t]_ [ _ρS_ ]].


**A.** **Comparison with other near-term Hamiltonian**
**simulation algorithms**


We will borrow the circuit depths obtained in Sec. III C
(Table I) for estimating Tr[ _O e_ _[L][ t]_ [ _ρS_ ]] to _ε_ -additive accuracy.
In this case, the parameters are _K_ = _mν_, ∆ _t_ = _t/ν_, and _β_ =
_O_ ( _β_ max ~~�~~ _ν/t_ ), where _ν_ = _O_ ( _t_ [2] _∥O∥m_ Γ _/ε_ ). From Theorem

2, we know that any Hamiltonian simulation procedure
needs to be implemented with precision _ε_ _[′]_ = _O_ ( _ε/K∥O∥_ ).
The circuit depth per coherent run, the total number of
qubits needed, and the number of classical repetitions required are outlined in Table II.
Let us first analyze the circuit depth for the first-order
Trotter approach. In the worst case, it would depend on
the maximum number of terms in _Hℓ_ = _HS_ + _HIℓ_ + _HEℓ_ corresponding to the collisions. Let


_L_ = _LS_ + max (65)
_ℓ∈_ [1 _,m_ ] _[L][I][ℓ]_ [+] [1] _[.]_


Then, for the first-order Trotter method, the appropriate
substitution of the parameters yields



which indicates that the circuit depth is worse than
the circuit depth of Hamiltonian simulation by SA-LCU




  _Lm_ [3] _t_ [3] _∥O∥_ [2]

_τd_ = _O_ Γ _β_ max [2]

_ε_ [2]







_,_ (66)



14


[Eq. (57)]. This method is, however, qubit-efficient, requiring _n_ + 1 qubits overall.
The circuit depth of any procedure using qDRIFT to estimate the desired expectation value is given by







_,_ (67)



_τd_ = _O_




_m_ [3] _t_ [3] _∥O∥_ [2]

Γ _β_ max [2]
_ε_ [2]




_m_ [3] _t_ [3] _∥O∥_ [2]



This happens when we wish to simulate Lindblad dynamics
for short _t_, and moreover, the maximum number of terms in
the underlying Hamiltonians _H j_ ( _L_ ) is substantially large

[4]. As mentioned before, we have listed the worst-case
complexity for Trotterization. It is possible that for specific
Hamiltonians, the scaling of the prefactor is better than the
worst-case [53].
Finally, qubitization requires _O_ (log _L_ ) ancilla qubits, coherent access to a block encoding of the underlying Hamiltonians _H_ [¯] _j_, and sophisticated controlled operations. The
circuit depth is given by


       -       -       - [�]
_τd_ = _O_ _Lβ_ _mt_ + _mν_ log _mν∥O∥/ε_ (70)



wherein the advantage over first-order Trotter is in the absence of any dependence on _L_ . However, this circuit depth
is also worse than Eq. (57). The qDRIFT approach also
requires _n_ + 1 qubits overall, which is one less than Hamiltonian simulation by SA-LCU.
For any 2 _k_ -order Trotter method, we also incorporate the
additive cost coming from the repeated preparation of the
sub-environment register in the single qubit thermal state
a total of _K_ = _mν_ times (each such state can be prepared
in _O_ (1) circuit depth). Overall, we have







= _O_

[�]




_Lm_ [2] _t_ [2] _∥O∥_

Γ _β_ max
_ε_



_._ (71)



4 _k_ [�] Γ _β_ max [2] - 1 ~~2~~



1 ~~2~~ [+] 4 [1]




  4 _k_
+ _mν_ _._ (68)



4 [3] _k_ - _∥O∥_



1

- ~~2~~



1 ~~2~~ [+] 4 [3]



_τd_ = _O_ - _L_ ( _mt_ ) ~~2~~ 3 [+] 4 [3]



_ε_



However, as mentioned previously, only low-order Trotter
methods are preferred for near-term implementation. In
particular, for the second-order Trotter method ( _k_ = 1),
this becomes




  -   - _∥O∥_
_τd_ = _O_ _L_ ( _mt_ ) [9] _[/]_ [4]

_ε_



�5 _/_ 4
Γ _β_ max [3] _[/]_ [2]




_._ (69)



Thus, scaling of the circuit depth is similar to a very high
order Trotter (up to logarithmic factors).
From the above discussion, it is clear that any procedure would at least require a circuit depth of _mν_ =
_O_ ( _mt_ [2] _∥O∥_ Γ _/ε_ ), simply because the sub-environments are
prepared a total of _mν_ times. This can be seen as a lower
bound for the circuit depth of estimating Tr[ _O e_ _[L][ t]_ [ _ρS_ ]] using incoherent measurements of _O_, and matches with the
lower bound of Ref. [15]. In the next section, we apply
these methods to a concrete problem.
Overall, our methods provide qubit-efficient, end-to-end
quantum algorithms for simulating Lindbladian dynamics
via the quantum collision model. It is, however, important to distinguish them from direct approaches such as
Refs. [15, 17, 54, 61]. These methods assume access to
specialized oracles such as block encodings [5, 14], i.e.
unitaries that embed the system Hamiltonian (say _UHS_ )
and each of the Lindblad jump operators (say _UA j_ ), in their
top-left block. The complexity is expressed in terms of the
number of queries made to the oracles _UH_ and _UA_ _j_, with the
query complexity scaling as _O_ ( _t ·_ polylog( _t/ε_ )) (ignoring dependence on other parameters). The actual circuit depth
and gate counts depend on the detailed structure of _HS_
and _A_ _j_, making a direct comparison with our end-to-end
methods infeasible. Moreover, constructing such blockencodings often requires substantial overhead (in terms
of ancilla qubits, multi-qubit controlled operations), rendering these methods impractical for near-term quantum
devices.


**B.** **Numerical benchmarking: Ising model under amplitude**
**damping**


We numerically benchmark the performance of the
Markovian quantum collision model for simulating Lindblad dynamics by applying it to a concrete problem. We
consider the one-dimensional transverse-field Ising model
with nearest-neighbor interactions (also known as the



Compared to the circuit depth obtained by Hamiltonian
simulation by SA-LCU, the second-order Trotter method
has a better dependence on _m, t_ and _β_ max, and a worse
dependence on _∥O∥_ and 1 _/ε_, in addition to scaling with
_L_ . Thus, the circuit depth in Eq. (57) is shorter in settings
where _L ≪_ _β_ max, and a high precision of the desired expectation value is demanded.
In summary, SA-LCU achieves significantly shorter circuit depths than second-order Trotterization for highprecision simulations over short time scales. More precisely, the ratio between the circuit depths per coherent run of second-order Trotter and SA-LCU scales as
_O_ ( _ε_ [1] _[/]_ [4] _/t_ [3] _[/]_ [4] ) (ignoring the dependence on all other parameters). Therefore, for simulating Lindblad dynamics over
very long time durations where _ε_ [1] _[/]_ [4] _/t_ [3] _[/]_ [4] _≪_ 1, second-order
Trotterization can offer shorter circuit depths.
For higher orders of this method ( _k >_ 2), the additive
term _mν_ starts to dominate, and in such cases, the asymptotic circuit depth is



_τd_ = _O_ [�]




- _Lm_ [2] _t_ [2] _∥O∥_

Γ _β_ max
_ε_



_._



Thus, even at very high Trotter orders, the dependence on
1 _/ε_, _∥O∥_, and Γ can be no better than Eq. (57). However,
the dependence on _m, t_ and _β_ max is quadratically better. So,
the circuit depth in Eq. (57) is shorter when _L ≫_ _mβ_ max _t_ .



15


10 [16]


10 [14]


10 [12]


10 [10]


10 [8]


10 [6]





10 [4]

10 [−][5] 10 [−][4] 10 [−][3] 10 [−][2] 10 [−][1]


Precision (ε)


(a)



10 [12]


10 [11]


10 [10]


10 [9]


10 [8]


10 [7]


10 [6]



1 2 3 4 5 6 7 8 9 10


Evolution time (t)


(b)





FIG. 3. We consider the problem of estimating the average transverse-field magnetization of a 10-qubit Heisenberg XXX model under
amplitude damping. The corresponding Lindbladian dynamics can be approximated by quantum collision models. The randomized
quantum algorithms we develop for simulating quantum collision models can be used to estimate the desired expectation value. In these
plots, we show the CNOT gate count per coherent run of our algorithm for different near-term Hamiltonian simulation procedures: the
First-order Trotter method (brown circles), the Second-order Trotter method (olive squares), Hamiltonian simulation by Single-Ancilla
LCU (SA-LCU, blue diamonds), and qDRIFT (purple triangles). In (a), we vary the precision ( _ε_ ) for a fixed evolution time ( _t_ = 1) of the
underlying Lindbladian. The Hamiltonian simulation by SA-LCU outperforms the first- and second-order Trotter methods and qDRIFT.
In (b), we vary the evolution time ( _t_ ) for a fixed precision, _ε_ = 0 _._ 01, where second-order Trotter outperforms the other methods.



Heisenberg XXX model), a widely used testbed for benchmarking Hamiltonian simulation techniques due to its
physical significance in condensed matter physics [62]. We
look at the dynamics of this system when the environment
is a discrete sum of sub-environments, each corresponding
to a single-qubit amplitude-damping channel. The _j_ -th collision corresponds to the _j_ -th sub-environment qubit interacting non-trivially with site _j_ of the system Hamiltonian.
Thus, the total number of sub-environments is the same as
the number of sites in the Ising chain. Consequently, let us
define the system Hamiltonian as follows:


_m−_ 1 _m_
### HS = −J ∑ σi [z][σ] i [z] +1 [−] [h] ∑ σi [x][,] (72)

_j_ =1 _j_ =1


where _J_ denotes the coupling strength between nearest
neighbors, _h_ is the transverse magnetic field strength, and
_σ_ _[z]_ _j_ [and] _[ σ]_ _[x]_ _j_ [are Pauli operators acting on site] _[ j]_ [. The to-]
tal number of sites _m_, is the same as the number of subenvironments. Finally, we accommodate for the fact that
the system interacts with each sub-environment one at
a time by considering the rescaled system Hamiltonian
_HS/m_, with _βS_ = ( _J_ + _h_ ). The environment is a discrete
sum of _m_ single-qubit number operators, with each subenvironment being in the state _|_ 0 _⟩_, corresponding to a thermal state at zero temperature ( _ω →_ ∞), i.e., _ρE_ _j_ = _|_ 0 _⟩⟨_ 0 _|_,
for all _j ∈_ [1 _,_ _m_ ].



We define the interaction Hamiltonian corresponding to
the _j_ -th collision as

_HI_ _j_ = ~~_[√]_~~ ~~_γ_~~ (I _[j][−]_ [1] _⊗_ _σ_ ˆ [+] _j_ _[⊗]_ [I] _[m][−]_ _[j][−]_ [1] _[ ⊗]_ _[σ]_ [ˆ] _a_ _[−]_

+ I _[j][−]_ [1] _⊗_ _σ_ ˆ _[−]_ _j_ _[⊗]_ [I] _[m][−]_ _[j][−]_ [1] _[ ⊗]_ _[σ]_ [ˆ] _a_ [+][)] _[,]_ (73)


where _a_ denotes the environment qubit, _γ_ denotes the
damping strength and _σ−_ denotes the lowering operator.
We estimate the average transverse-field magnetization,



(75)
where the jump operator for the amplitude damping on
_j_ th qubit,

_A_ _j_ = _[√]_ ~~_γ_~~ I _[j][−]_ [1] _⊗_ _σ−_ _⊗_ I _[n][−]_ _[j]_ _._ (76)



_Mz_ = [1]

_m_



_m_
### ∑ σ [z] j [,] (74)

_j_ =1



with respect to the reduced state _e_ _[L][ t]_ [ _ρS_ ], i.e., we obtain _µ_
such that

           ��� _µ −_ Tr _Mz e_ _[L][ t]_ [ _ρS_ ]���� _≤_ _ε._


Note that the Lindblad master equation dynamics, which
we numerically simulate, is given by Eq. (45). That is, we
have:



_L_ [ _ρS_ ] _≡_ _[∂ρ][S]_

_∂t_ [=] _[ −][i]_ [[] _[H][S][,]_ _[ρ]_ []+][∑] _j_




- _A_ _jρA_ [†] _j_ _[−]_ [1] _j_ _[A]_ _[j][,]_ _[ρ][}]_ _,_

2 _[{][A]_ [†]



16


We perform numerical benchmarking for estimating the
desired expectation value on a 10-qubit ( _m_ = 10) transverse
field Ising model under amplitude damping via the quantum collision model using different Hamiltonian simulation procedures (first and second order Trotter methods,
SA-LCU, and qDRIFT). In Fig. 3(a), we compare the CNOT
gate counts per coherent run to fix the Lindblad evolution
time to _t_ = 1 and estimate _µ_ for different values of _ε_ . In
Fig. 3(b), we fix _ε_ = 0 _._ 01 and vary _t_ instead. To obtain
these plots, we set the coupling strength _J_ = 1 and the
transverse magnetic field strength _h_ = 0 _._ 1 in the system
Hamiltonian _HS_ . The strength of the amplitude damping
channel for each interaction Hamiltonian is fixed to _γ_ = 1.
The time of each collision, ∆ _t_, depends on the precision _ε_
and _t_ . Hence, ∆ _t_ differs for different values of _ε_ and _t_ in
these figures.
To obtain the CNOT gate count for each Hamiltonian
simulation procedure, we construct the entire circuit on
Qiskit using a fully-connected circuit architecture. This
corresponds to a composition of Hamiltonian simulations.
For this purpose, we use the Solovay-Kitaev theorem (available in Qiskit) to decompose the circuit into a basis comprising single-qubit rotations and CNOT gates. The usual
gate optimizations available on Qiskit are applied to all the
circuits to obtain a non-trivial total CNOT count. Finally,
for a fair comparison, we choose the number of Trotter
steps based on the tighter commutator bounds [53] for the
first and second-order Trotter methods.
Fig. 3(a) shows that, for a fixed _t_, the Hamiltonian simulation by the SA-LCU method performs better than the first
and second-order Trotter methods and qDRIFT. This is because it has a better dependence on the precision. On the
other hand, in Fig. 3(b), the second-order Trotter method
outperforms the rest when _ε_ is fixed and _t_ is increased.


**V.** **SIMULATION OF NON-MARKOVIAN QUANTUM**
**COLLISION MODELS**


In the quantum algorithm we develop in Sec. III, the interactions correspond to memoryless collisions: each subenvironment qubit interacts for ∆ _t_ before being traced out.
Thus, a _K_ -collision map can only generate Markovian dynamics. Within the collision model framework, this translates to each sub-environment interacting with the system
in isolation without influencing other sub-environments.
For instance, Lindbladian dynamics adhere to a strict
Markovian assumption, where the environmental dynamics occur on much faster timescales than the system, effectively ensuring that the environment remains unaffected
by the interaction. On the other hand, non-Markovian
dynamics naturally arise when the collisions are memoryretaining: interactions between the sub-environments ensure some information about the prior collisions is retained [22]. In this section, we extend the _K_ -collision map
to the non-Markovian framework, incorporating interac


tions between the different sub-environments. In particular, we consider interactions that preserve the CPTP nature
of the maps, such that they can be seamlessly composed to
obtain the reduced dynamics of the system. To this end,
we discuss next the framework introduced by Ciccarello et
al. [23], which provides a simple way to incorporate subenvironment interactions.
As in Sec. III, we consider an _n_ -qubit system described by
the Hamiltonian _HS_ and prepared in the state _ρS_ from the
Hilbert space _HS_ . It interacts with an environment made
up of _m_ discrete sub-environments described by the Hamiltonian _HE_ _j_ and prepared in states _ρE_ _j_, for _j ∈_ [1 _,_ _m_ ]. Each
sub-environment lives in the Hilbert space _HE_ _j_ and the
overall environment belongs to _⊗_ _[m]_ _j_ =1 _[H][E]_ _j_ [. For simplicity,]
we assume that the dimension of _HE j_ is the same for all
_j ∈_ [1 _,_ _m_ ]. Also, the interaction Hamiltonian corresponding
to the _j_ -th collision between the system and the _j_ -th subenvironment is _HI_ _j_ . So, the total Hamiltonian for the _j_ -th
collision remains the same as in Sec. III, i.e.,


_H_ _j_ = _HS_ + _HI_ _j_ + _HE j_ _._


However, now, we assume that a collision between the system and the environment is followed by a collision between consecutive sub-environments via some CPTP quantum channel _Ci,_ _j_ as follows: Initially, the system in the state
_ρS_ interacts with _E_ 1 prepared in the state _ρE_ 1 for ∆ _t_ . Then,
_E_ 1 interacts with the next sub-environment _E_ 2, prepared
in _ρE_ 2 via the quantum channel _C_ 1 _,_ 2. It is only after this
intra-environment interaction that _E_ 1 is traced out. Thus,
a single iteration now consists of two collisions: a systemsub-environment collision followed by a collision between
two consecutive sub-environments.
This sequence of interactions continues for some _K_ iterations, as depicted in Fig. 4, and leads to a non-Markovian
_K_ -collision map. At the _j_ -th iteration, the system and _j_ th sub-environment interact for time ∆ _t_ . Subsequently, a
new environment state _ρE_ _j_ +1 is initialized, and _E_ _j_ interacts
with _E_ _j_ +1 via the CPTP channel _C j,_ _j_ +1, following which _E_ _j_
is then traced out. Ciccarello et al. [23] demonstrated that
when _C j,_ _j_ +1 is the partial swap operation between consecutive sub-environment qubits, the corresponding collision
model leads to a non-Markovian master equation in the
limit where the number of collisions _K →_ ∞. Or, more precisely, for _p ∈_ [0 _,_ 1] and two states _ρ_ _j_ and _σ_ _j_ +1 of the same
dimension,


_C j,_ _j_ +1[ _ρ_ _j ⊗_ _σ j_ +1] =

(1 _−_ _p_ )( _ρ_ _j ⊗_ _σ j_ +1)+ _S_ _j,_ _j_ +1( _ρ_ _j ⊗_ _σ j_ +1)S [†] _j,_ _j_ +1 _[,]_ (77)


where _S_ _j,_ _j_ +1 swaps the two states _ρ_ _j_ and _σ_ _j_ +1. The
parameter _p_ provides a handle over the degree of nonMarkovianity, ranging from no information transfer (memoryless collisions) for _p_ = 0 to perfect swapping of information between consecutive sub-environments for _p_ = 1.
We now define the map corresponding to the _j_ -th iteration (similar to Definition 1) with two sub-environment



17


FIG. 4. Non-Markovian evolution via the collision model illustrating the interleaved dynamics between system-environment and the
additional intra-environment interactions. The system _S_ (blue) interacts with the environmental subsystems _Ei_ (green) through unitary
operations _Ui_, while only the adjacent environmental subsystems interact via channel _Ci,i_ +1. This sequential structure may create
a propagating chain of correlations, where information flows not only between the system and environment but also via nearestneighbor interactions. The three panels represent consecutive time steps of the evolution, demonstrating how correlations may build
up and propagate through the environmental subsystems, capturing the memory effects and non-Markovian behavior of the quantum
dynamics.



registers (instead of one as in the Markovian case). There
is one subtlety in defining the maps, namely, which subenvironment register interacts with the system and which
one gets traced out. At the _j_ -th iteration, if _j_ is odd (even),
the second (first) sub-environment register stores _ρE_ _j_ +1,
while the first (second) sub-environment register interacts
with the system, and is ultimately traced out. For _j ∈_ [1 _,_ _m_ ],
let us then define,


_US j_ = _U_ [¯] _j ⊗_ _IE_ _,_ (78)


where _U_ [¯] _j_ = _e_ _[−][i]_ [∆] _[t][β]_ _[j][H][ j]_ denotes the collision between the system _S_ and the _j_ -th sub-environment. Here _H j_ is the normalized hamiltonian to make it’s decomposition a convex
combination of pauli operators and _β_ _j_ is the normalizing
factor. Furthermore, we define the CPTP map,


_V_ _j,_ _j_ +1 = _IS ⊗C_ _j,_ _j_ +1 _,_ (79)


where _C_ _j,_ _j_ +1 is the partial swap operation defined in
Eq. (77). The collision map is applied to a composite state
of the system and the two sub-environments _E j_ and _E_ _j_ +1,
with the state of the latter prepared in _ρE_ _j_ +1. As explained
above, the sub-environment register storing _ρE_ _j_ +1 changes
depending on whether _j_ is even or odd. Thus, we can now
formally define the _j_ -th non-Markovian collision map Φ _[N]_ _j_
as:



not interact with the next sub-environment. So, the final
map is an interaction between the system and this final
sub-environment, according to _USK_ for time ∆ _t_, followed by
the tracing out of _EK_, leaving only the transformed state of
the system. Thus, the non-Markovian _K_ -collision map can
be defined as



(82)
Analogously, for the overall map, we define




_._ (81)



_NK_ [ _·_ ] _≡_ Tr _EK_




- - _USK_ _⃝_ _[K]_ _j_ = _[−]_ 1 [1][Φ] _[N]_ _j_ [[] _[·]_ []] _US_ [†] _K_



To develop quantum algorithms for implementing the
non-Markovian _K_ -collision map _NK_ [ _._ ], there are a few
things to consider. First, it is possible to implement the
partial swap _C_ _j,_ _j_ +1 efficiently in a probabilistic manner: we
apply _S_ _j,_ _j_ +1 with probability _p_ and with probability 1 _−_ _p_,
we do not perform any operation. Second, as in the Markovian case, the system environment collisions _US j_ can be
implemented with any Hamiltonian simulation procedure.
We assume that the swap operation can be implemented
perfectly so that the only source of error is the underlying Hamiltonian simulation procedure. That is, for each
iteration, we implement an approximate map



Φ� _[N]_ _j_ [[] _[·]_ []] _[ ≡]_





   -    -    -    
Tr _E_ _j_ _V_ _j,_ _j_ +1 _U_ - _S j_ _·⊗·⊗_ _ρE_ _j_ +1 _U_ - _S_ [†] _j_

   -    -    -    
Tr _E_ _j_ _V_ _j,_ _j_ +1 _U_ - _S j_ _·⊗_ _ρE j_ +1 _⊗·_ _U_ - _S_ [†] _j_



��
_, j_ is odd,


��
_, j_ is even.




_._ (83)



Φ _[N]_ _j_ [[] _[·]_ []] _[ ≡]_





   -    -    -    
Tr _E_ _j_ _V j,_ _j_ +1 _US j_ _·⊗·⊗_ _ρE_ _j_ +1 _US_ [†] _j_

   -    -    -    
Tr _E_ _j_ _V j,_ _j_ +1 _US j_ _·⊗_ _ρE_ _j_ +1 _⊗·_ _US_ [†] _j_



��
_, j_ is odd,


��
_, j_ is even.



_N_ - _K_ [ _._ ] _≡_ Tr _EK_




- - _U_ - _SK_ _⃝_ _[K]_ _j_ = _[−]_ 1 [1] _j_ [[] _[.]_ []] _U_ - _S_ [†] _K_

[Φ][�] _[N]_



(80)
Note that irrespective of whether _j_ is odd or even, the
_j_ -th sub-environment _E j_ is traced out [it is the first (second) sub-environment register when _j_ is odd (even)]. Let
us now look at the overall map for _K_ iterations of systemenvironment and environment-environment collisions. It
is essentially equivalent to composing the Φ _[N]_ _j_ [[.] map a]
total of _K −_ 1 times, following which the reduced state
is the composite state of the system and the _K_ -th subenvironment. At this stage, the sub-environment _K_ does



_ε_

1max _≤_ _j≤K_ ��� _U_ _j −U_ - _j_ ��� _≤_ 3 _K∥O∥_ _[.]_ (84)



Next, we show that the required precision for a Hamiltonian simulation procedure to estimate Tr[ _O NK_ [ _ρS_ ]] with
_ε_ -additive accuracy remains the same as in the Markovian
case. For this, we prove the following Lemma:


**Lemma 4** (Bounds on the non-Markovian approximate collision Map) **.** _Let O be an observable and_ _N_ [�] _K be the approx-_
_imate non-Markovian K-collision map in Eq._ (8) _, where_



18


**Algorithm 3:** Algorithm to estimate the expectation value of an observable _O_ with respect to the non-Markovian
_K_ -collision map applied to a quantum state.

**Input:** Initial system state in _ρS_, sub-environment states _ρE_ 1 to _ρEK_, observable _O_, unitaries _U_ [�] 1, .... _U_ [�] _K_, and precision _ε_ _[′]_, where

the LCU decomposition of each _U_ [�] _j_ = ∑ _k α jkWjk_, such that _∀_ _j ∈_ [1 _,_ _K_ ], ���� _U_ _j −_ _e−i_ ∆ _tH j_ ��� _≤_ _ε_ _′_ .


1. Initialize the system, the first environment register, and the ancilla in states _ρS_, _ρE_ 1, and _|_ + _⟩_, respectively.


2. For iterations from _j_ = 1 to _K −_ 1:


a. Draw two i.i.d. samples _X_ _j_ and _Yj_ from the ensemble




  -   _D_ _j_ = _Wjℓ,_ _[α][ j][ℓ]_ _,_

_α_ [(] _[j]_ [)]



where _α_ [(] _[j]_ [)] = ∑ _ℓ_ _|α jℓ|_

b. Apply the controlled unitary _X_ _j_ [(] _[c]_ [)] and the anti-controlled unitary _Yj_ [(] _[a]_ [)], controlled on the ancilla qubit with the
target being the system register and the first (second) environment register if _j_ is odd (even).


c. If _j_ is odd, initialize the second environment register in the state _ρE_ _j_ +1 ; otherwise, initialize the first environment
register in _ρE_ _j_ +1 .

d. With probability _p_ apply the swap gate _S_ _j,_ _j_ +1 between the two environment registers.


e. If _j_ is odd, perform a partial trace over the first environment register; otherwise, perform a partial trace over the
second environment register.


4. Draw two i.i.d. samples _XK_ and _YK_ from the ensemble




_,_




  _DK_ = _WKℓ,_ _[α][K][ℓ]_

_α_ [(] _[K]_ [)]




  _DK_ = _WKℓ,_ _[α][K][ℓ]_



where _α_ [(] _[K]_ [)] = ∑ _ℓ_ _|αKℓ|_ .

5. Apply the unitary _XK_ [(] _[c]_ [)] and the anti-controlled unitary _YK_ [(] _[a]_ [)][, controlled on the ancilla with the target being the system and]
the first (second) environment register if _K_ is odd (even).


6. If _K_ is odd, perform a partial trace over the first environment register; otherwise, perform a partial trace over the second
environment register.

7. Measure the joint ancilla and system state on the observable ( _σ_ _[x]_ _⊗_ _O_ ) and record the measurement outcome as _µi_ .


8. Repeat Steps 1 to 7 a total of _T_ times.


9. Compute the final estimate _µ_ as:



_µ_ = _[ζ]_ [ 2]

_T_



_T_
#### ∑ µ j,

_j_ =1


_∥US j −_ _U_ [�] _S j_ _∥≤_ _ξ j_ . As before, we denote the maximum error in any of the Hamiltonian simulation procedures in the
definition of the approximate _K_ -collision map by _ξ_ max, i.e.,
_ξ_ max = max1 _≤_ _j≤K ξ j_ . Then, using Theorem A1 for any quantum state _ρ_, we have

�� _US j_ _ρUS_          - _j_ _[−][U]_ [�] _[S]_ _j_ _[ρ]_ [ �] _[U]_ _S_ [†] _j_ ��1 _[≤]_ [3] _[ξ][ j][ ≤]_ [3] _[ξ]_ [max] _[.]_ (86)


Now, since partial trace and _V_ _j,_ _j_ +1 are CPTP maps, we can
make use of the distance between the composition of CPTP
maps (Theorem A6) to get



where _ζ_ = ∏ _[K]_ _j_ =1 _[α]_ [(] _[j]_ [)][.]


**Output:** Estimated expectation value _µ_


_Then, the expectation value of O with respect to the state_
_transformed under the approximate map is ε-close to the ex-_
_pectation value under the exact map. That is, for any ρ,_


���Tr           - _O NK_ [ _ρ_ ]� _−_ Tr           - _O_ _N_ [�] _K_ [ _ρ_ ]���� _≤_ _ε._ (85)


_Proof._ We consider the error between the operations performed on the state _ρ_ under _US_ _j_ and _U_ [�] _S j_ . More pre
cisely, let ��� _U_ _j −U_ - _j_ ��� _≤_ _ξ j_ . Then, immediately, we have



19


��� _⃝Kj_ = _−_ 11 [Φ] _[N]_ _j_ [[] _[ρ]_ []] _[−⃝][K]_ _j_ = _[−]_ 1 [1][Φ][�] _[N]_ _j_ [[] _[ρ]_ []] ���1 _[≤]_ [3][(] _[K][ −]_ [1][)] _[ξ]_ [max] _[.]_ (87)



For the final step, we need to bound



���� _NK_ [ _ρ_ ]� _−_ _N_ [�] _K_ [ _ρ_ ]���1 [=] ����Tr _EK_




- - _U_ - _SK_ _⃝_ _[K]_ _j_ = _[−]_ 1 [1] _j_ [[] _[ρ]_ []] _U_ - _S_ [†] _K_

[Φ][�] _[N]_



�����1




- - _USK_ _⃝_ _[K]_ _j_ = _[−]_ 1 [1][Φ] _[N]_ _j_ [[] _[ρ]_ []] _US_ [†] _K_





_−_ Tr _EK_




   -   -   -   _≤_ ��� _USK_ _⃝_ _[K]_ _j_ = _[−]_ 1 [1][Φ] _[N]_ _j_ [[] _[ρ]_ []] _US_ [†] _K_ _[−][U]_ [�] _[S]_ _K_ _⃝_ _[K]_ _j_ = _[−]_ 1 [1][Φ][�] _[N]_ _j_ [[] _[ρ]_ []] _U_ - _S_ [†] _K_



���1



_≤_ ��� _⃝Kj_ = _−_ 11 [Φ] _[N]_ _j_ [[] _[ρ]_ []] _[−⃝][K]_ _j_ = _[−]_ 1 [1][Φ][�] _[N]_ _j_ [[] _[ρ]_ []] ���1 [+] [2] ��� _USK −U_ - _SK_ ��� _≤_ 3( _K −_ 1) _ξ_ max + 2 _ξ_ max _<_ 3 _Kξ_ max _,_ (88)



where we have used Theorem A2 to arrive at the third line
from the second. Finally, as in the proof of Lemma 1, we
can use Theorem A1 and set _ξ_ max = _ε/_ (3 _K∥O∥_ ) and get:
���Tr           - _O NK_ [ _ρ_ ]� _−_ Tr           - _O_ _N_ [�] _K_ [ _ρ_ ]���� _≤_ _ε._ (89)


This implies that for estimating the desired expectation value, we need to implement a Hamiltonian simulation procedure with precision _ε_ _[′]_ = _O_ ( _ε/K∥O∥_ ), which
is the same as in the Markovian case. Thus, we can develop a randomized quantum algorithm that can incorporate any near-term Hamiltonian simulation procedure. In
Algorithm 3, we use Hamiltonian simulation by the SALCU method to estimate the desired expectation value. We
show the circuit corresponding to each run of the algorithm in Fig. 5. We now need two sub-environment registers, along with the system register and a single qubit
ancilla register. For the first _K −_ 1 iterations, a composition of the map Φ _[N]_ [ _._ ] is implemented. Note that at odd

[�]
(even) iterations, the second (first) register stores the state
of the subsequent sub-environment. Following the interaction between the two sub-environment registers, the first
(second) environment register is traced out.
Following an approach similar to Theorem 1, we prove
the correctness of Algorithm 3 in the Appendix (Theorem A3, Appendix D). In step 2d. of Algorithm 3, we implement a map that in expectation value is simply _C j,_ _j_ +1.
Interestingly, if we assume that the cost of implementing
a swap gate between two consecutive sub-environments is
constant, the circuit depth of the procedure using the different simulation techniques is the same as those listed in
Table I. Thus, this is a unified framework to simulate nonMarkovian collisions using near-term Hamiltonian simulation procedures. Again, we do not require many ancilla
qubits or need access to block encodings.
It would be interesting to explore whether continuoustime non-Markovian master equations can be approximated by this collision model for finite _K_ . This would require obtaining the number of collisions _K_ for which it is
_ε_ -close (in, say, induced 1-norm) to the generator of the underlying non-Markovian master equation. While this prob


lem has been investigated in the Markovian setting (closeness of the _K_ -collision map and exponential of the Lindbladian [24, 55]), very little is known in the non-Markovian
case. Ciccarello et al. [23], showed that the collision model
we consider gives rise to a non-Markovian master equation
for _K →_ ∞ and _p_ = _e_ _[−][λ][t]_, where _λ_ is a continuous parameter, determining the _memory rate_ . However, we leave the
question of the precise scaling of the error in this approximation open with (finite) _K_ .


**VI.** **DISCUSSION AND OUTLOOK**


In this paper, we developed randomized quantum algorithms for simulating open quantum system dynamics
using quantum collision models designed for early faulttolerant quantum computers. Our approach enables estimating expectation values of observables for a system that
undergoes an arbitrary number of collisions, encompassing both memoryless (Markovian) and memory-retaining
(non-Markovian) interactions. Thus, it provides a unified
framework for simulating a broad range of open-system
dynamics.
A key advantage of quantum collision models is that
they naturally decompose the environment into discrete
sub-environments, making system-environment interactions efficiently implementable on near-term quantum devices. Indeed, our methods for simulating both Markovian
and non-Markovian dynamics avoid the need for block encodings, significantly reducing ancilla requirements.
We rigorously analyzed the cost of implementing _K_
Markovian collisions, where the system sequentially interacts with different sub-environments before they are
traced out, by leveraging various near-term Hamiltonian
simulation techniques such as Trotterization, qDRIFT, and
Hamiltonian simulation by SA-LCU. This provided a unified framework to simulate Lindblad dynamics using quantum collision models. We undertook a detailed comparison of the end-to-end complexities of these techniques for
simulating Lindblad dynamics, which revealed that Hamiltonian simulation by the SA-LCU method outperforms the
first and second-order Trotter methods and qDRIFT. How


20


FIG. 5. Quantum circuit corresponding to each run of Algorithm 3, simulating a non-Markovian _K_ -collision map, using Hamiltonian
simulation by SA-LCU. The algorithm applies controlled and anti-controlled sampled unitaries ( _X_ _j,Yj_ ) for the interaction between the
system and each sub-environment, followed by an interaction between consecutive sub-environments using the channel ( _C_ _j,_ _j_ +1). This
sequence is repeated for _K_ collisions. At the end of the process, the ancilla qubit and the system are measured.



ever, overall, 2 _k_ -order Trotter methods offer the most competitive circuit depth, scaling as _O_ [�] ( _t_ [2] _/ε_ ), for large _k_ . Notably, this matches known lower bounds for implementing
_e_ _[L][ t]_ using quantum collision models [15, 24].


While there have been several direct approaches to simulating Linbladian dynamics [15, 17, 54], they are resourcedemanding and hence are not implementable on early
fault-tolerant machines. Quantum collision models provide a simple, easy-to-implement route. It would be interesting to explore whether it is possible to exploit recently
developed extrapolation techniques (used to improve the
circuit depth of Trotterization [63], qDRIFT [64], and
even more general quantum algorithms [65]), in conjunction with our randomized quantum algorithm to further improve the overall circuit depth. While the _t_ [2] _/ε_ dependence on the circuit depth is unavoidable for quantum collision models, extrapolation techniques might lead
to optimal complexity even with the first-order Trotter
method and qDRIFT. Thus, better direct approaches must
be investigated to simulate Lindblad dynamics on early
fault-tolerant quantum computers with even shorter circuit depths. In this regard, during the preparation of this
manuscript, we became aware of Ref. [66]. There, the authors assume that the Lindblad jump operators can be expressed as a linear combination of strings of Pauli operators and then write down _e_ _[L][ t]_ as an LCU (much like the
LCU decomposition of _e_ _[−][iHt]_ in SA-LCU [56–58]). The authors estimate the expectation value of _O_ with respect to
_e_ _[L][ t]_ with _ε_ -additive accuracy in _O_ ( _∥O∥_ [2] _/ε_ [2] ) classical repetitions and circuit depth _O_ ( _t_ [2] log( _t/ε_ )). The procedure requires _n_ + 4 qubits overall and has an exponentially better
circuit depth than any procedure making use of quantum
collision models.


Another advantage of quantum collision models is that
their applicability goes beyond the simulation of Markovian dynamics. Indeed, we extended our framework to
non-Markovian interactions. In particular, we considered


[1] S. Lloyd, Universal quantum simulators, Science **[273](https://doi.org/10.1126/science.273.5278.1073)**, 1073
[(1996).](https://doi.org/10.1126/science.273.5278.1073)



the setting of [23], wherein a collision between the system and a sub-environment is followed by an interaction
between consecutive sub-environments, thereby retaining
some memory of prior interactions. We developed a randomized method to simulate arbitrary such collisions using near-term Hamiltonian simulation procedures. The circuit depth for implementing _K_ such collisions scales similarly to the Markovian case - once again, no block encoding is required, and the number of ancilla qubits needed is
minimal. Thus, this provides a general method to implement such dynamics resource-efficiently on quantum devices. Much like the Markovian case, our approach stands
in contrast to the direct approaches (such as Ref. [67]),
which are resource-demanding and hence unsuitable for
near-term implementation.
Finally, an interesting advance would be to simulate
Lindblad master equations with time-dependent decay parameters via quantum collision models. This would require
establishing convergence between such time-dependent
Lindblad maps and quantum collision models generated by
time-dependent Hamiltonians. One could then use quantum algorithms for simulating time-dependent Hamiltonians [68–71] to construct end-to-end simulation protocols
for a broader class of open-system dynamics, including
both Markovian and non-Markovian cases.
Overall, our results demonstrate that quantum collision
models can be used to simulate a wide range of open systems dynamics, both under Markovian and non-Markovian
environments, using early fault-tolerant quantum computers.


**ACKNOWLEDGMENTS**


We acknowledge funding from the Ministry of Electronics and Information Technology (MeitY), Government of
India, under Grant No. 4(3)/2024-ITEA. SC also acknowledges support from Fujitsu Ltd, Japan and IIIT Hyderabad.


[2] D. W. Berry, A. M. Childs, R. Cleve, R. Kothari, and R. D.



21


Somma, Exponential improvement in precision for simulating sparse Hamiltonians, in _[Proceedings of the Forty-Sixth](https://doi.org/10.1145/2591796.2591854)_
_[Annual ACM Symposium on Theory of Computing](https://doi.org/10.1145/2591796.2591854)_, STOC ’14
(Association for Computing Machinery, New York, NY, USA,
2014) p. 283–292.

[3] D. W. Berry, A. M. Childs, R. Cleve, R. Kothari, and R. D.
Somma, Simulating Hamiltonian dynamics with a truncated Taylor series, Phys. Rev. Lett. **[114](https://doi.org/10.1103/PhysRevLett.114.090502)**, 090502 (2015).

[4] E. Campbell, Random compiler for fast hamiltonian simulation, Phys. Rev. Lett. **[123](https://doi.org/10.1103/PhysRevLett.123.070503)**, 070503 (2019).

[5] G. H. Low and I. L. Chuang, Hamiltonian simulation by
qubitization, Quantum **3** [, 163 (2019).](https://doi.org/10.22331/q-2019-07-12-163)

[6] H.-P. Breuer and F. Petruccione, _The theory of open quantum_
_systems_ (Oxford University Press, USA, 2002).

[7] A. Rivas and S. F. Huelga, _[Open quantum systems](https://doi.org/10.1007/978-3-642-23354-8)_, Vol. 10
(Springer, 2012).

[8] V. Gorini, A. Kossakowski, and E. C. G. Sudarshan, Completely Positive Dynamical Semigroups of N Level Systems,
J. Math. Phys. **[17](https://doi.org/10.1063/1.522979)**, 821 (1976).

[9] G. Lindblad, On the generators of quantum dynamical
[semigroups, Communications in Mathematical Physics](https://doi.org/10.1007/BF01608499) **48**,
[119–130 (1976).](https://doi.org/10.1007/BF01608499)

[10] S. Endo, S. C. Benjamin, and Y. Li, Practical quantum er[ror mitigation for near-future applications, Phys. Rev. X](https://doi.org/10.1103/PhysRevX.8.031027) **8**,
[031027 (2018).](https://doi.org/10.1103/PhysRevX.8.031027)

[11] A. Kandala, K. Temme, A. D. Córcoles, A. Mezzacapo, J. M.
Chow, and J. M. Gambetta, Error mitigation extends the
[computational reach of a noisy quantum processor, Nature](https://doi.org/10.1038/s41586-019-1040-7)
**567** [, 491 (2019).](https://doi.org/10.1038/s41586-019-1040-7)

[12] Z. Ding, C.-F. Chen, and L. Lin, Single-ancilla ground state
[preparation via Lindbladians, Phys. Rev. Res.](https://doi.org/10.1103/PhysRevResearch.6.033147) **6**, 033147
[(2024).](https://doi.org/10.1103/PhysRevResearch.6.033147)

[13] C.-F. Chen, M. J. Kastoryano, F. G. Brandão, and A. Gilyén,
Quantum thermal state preparation, arXiv:2303.18224
[10.48550/arXiv.2303.18224 (2023).](https://doi.org/10.48550/arXiv.2303.18224)

[14] S. Chakraborty, A. Gilyén, and S. Jeffery, The Power of
Block-Encoded Matrix Powers: Improved Regression Techniques via Faster Hamiltonian Simulation, in _[46th Interna-](https://doi.org/10.4230/LIPIcs.ICALP.2019.33)_
_[tional Colloquium on Automata, Languages, and Program-](https://doi.org/10.4230/LIPIcs.ICALP.2019.33)_
_[ming (ICALP 2019)](https://doi.org/10.4230/LIPIcs.ICALP.2019.33)_, Leibniz International Proceedings in
Informatics (LIPIcs), Vol. 132 (Schloss Dagstuhl–LeibnizZentrum fuer Informatik, Dagstuhl, Germany, 2019) pp.
33:1–33:14.

[15] R. Cleve and C. Wang, Efficient quantum algorithms for
simulating Lindblad evolution, in _[44th International Collo-](https://doi.org/10.4230/LIPIcs.ICALP.2017.17)_
_[quium on Automata, Languages, and Programming (ICALP](https://doi.org/10.4230/LIPIcs.ICALP.2017.17)_
_[2017)](https://doi.org/10.4230/LIPIcs.ICALP.2017.17)_, Vol. 80 (Schloss Dagstuhl–Leibniz-Zentrum für Informatik, 2017) pp. 17:1–17:14.

[16] A. M. Childs and T. Li, Efficient simulation of sparse Marko[vian quantum dynamics, Quantum Information & Compu-](https://doi.org/10.26421/QIC17.11-12-1)
tation **[17](https://doi.org/10.26421/QIC17.11-12-1)**, 901 (2017).

[17] X. Li and C. Wang, Simulating Markovian open quantum
systems using higher-order series expansion, in _[50th Inter-](https://doi.org/10.4230/LIPIcs.ICALP.2023.87)_
_[national Colloquium on Automata, Languages, and Program-](https://doi.org/10.4230/LIPIcs.ICALP.2023.87)_
_[ming (ICALP 2023)](https://doi.org/10.4230/LIPIcs.ICALP.2023.87)_, Vol. 261 (Schloss Dagstuhl-LeibnizZentrum fur Informatik GmbH, Dagstuhl Publishing, 2023)
pp. 87:1–87:20.

[18] D. Patel and M. M. Wilde, Wave matrix Lindbladization
I: Quantum programs for simulating Markovian dynam[ics, Open Systems & Information Dynamics](https://doi.org/10.1142/S1230161223500105) **30**, 2350010
[(2023).](https://doi.org/10.1142/S1230161223500105)




[19] D. Patel and M. M. Wilde, Wave matrix Lindbladization II:
General Lindbladians, linear combinations, and polynomi[als, Open Systems & Information Dynamics](https://doi.org/10.1142/S1230161223500142) **30**, 2350014
[(2023).](https://doi.org/10.1142/S1230161223500142)

[20] A. Katabarwa, K. Gratsea, A. Caesura, and P. D. Johnson,
[Early fault-tolerant quantum computing, PRX Quantum](https://doi.org/10.1103/PRXQuantum.5.020101) **5**,
[020101 (2024).](https://doi.org/10.1103/PRXQuantum.5.020101)

[21] L. Bruneau, A. Joye, and M. Merkli, Repeated interactions
[in open quantum systems, Journal of Mathematical Physics](https://doi.org/10.1063/1.4879240)
**55** [, 075204 (2014).](https://doi.org/10.1063/1.4879240)

[22] F. Ciccarello, S. Lorenzo, V. Giovannetti, and G. M. Palma,
Quantum collision models: Open system dynamics from re[peated interactions, Physics Reports](https://doi.org/10.1016/j.physrep.2022.01.001) **954**, 1 (2022).

[23] F. Ciccarello, G. M. Palma, and V. Giovannetti, Collisionmodel-based approach to non-Markovian quantum dynamics, Phys. Rev. A **87** [, 040103 (2013).](https://doi.org/10.1103/PhysRevA.87.040103)

[24] M. Cattaneo, G. De Chiara, S. Maniscalco, R. Zambrini, and
G. L. Giorgi, Collision models can efficiently simulate any
[multipartite Markovian quantum dynamics, Phys. Rev. Lett.](https://doi.org/10.1103/PhysRevLett.126.130403)
**126** [, 130403 (2021).](https://doi.org/10.1103/PhysRevLett.126.130403)

[25] P. Strasberg, G. Schaller, T. Brandes, and M. Esposito, Quantum and information thermodynamics: A unifying frame[work based on repeated interactions, Physical Review X](https://doi.org/10.1103/PhysRevX.7.021003) **7**,
[021003 (2017).](https://doi.org/10.1103/PhysRevX.7.021003)

[26] P. Filipowicz, J. Javanainen, and P. Meystre, Theory of a
microscopic maser, Phys. Rev. A **[34](https://doi.org/10.1103/PhysRevA.34.3077)**, 3077 (1986).

[[27] F. Barra, Dissipative charging of a quantum battery, Phys.](https://doi.org/10.1103/PhysRevLett.122.210601)
Rev. Lett. **[122](https://doi.org/10.1103/PhysRevLett.122.210601)**, 210601 (2019).

[28] S. Seah, M. Perarnau-Llobet, G. Haack, N. Brunner, and
S. Nimmrichter, Quantum speed-up in collisional battery
charging, Phys. Rev. Lett. **[127](https://doi.org/10.1103/PhysRevLett.127.100601)**, 100601 (2021).

[29] S. Lorenzo, R. McCloskey, F. Ciccarello, M. Paternostro,
and G. M. Palma, Landauer’s principle in multipartite open
[quantum system dynamics, Phys. Rev. Lett.](https://doi.org/10.1103/PhysRevLett.115.120403) **115**, 120403
[(2015).](https://doi.org/10.1103/PhysRevLett.115.120403)

[30] V. Scarani, M. Ziman, P. Štelmachovič, N. Gisin, and
V. Bužek, Thermalizing quantum machines: Dissipation and
entanglement, Phys. Rev. Lett. **[88](https://doi.org/10.1103/PhysRevLett.88.097905)**, 097905 (2002).

[31] A. Manatuly, W. Niedenzu, R. Román-Ancheyta, B. Çakmak,
O. E. Müstecaplıoğlu, and G. Kurizki, Collectively enhanced
[thermalization via multiqubit collisions, Phys. Rev. E](https://doi.org/10.1103/PhysRevE.99.042145) **99**,
[042145 (2019).](https://doi.org/10.1103/PhysRevE.99.042145)

[32] F. L. S. Rodrigues, G. De Chiara, M. Paternostro, and
G. T. Landi, Thermodynamics of weakly coherent collisional
models, Phys. Rev. Lett. **[123](https://doi.org/10.1103/PhysRevLett.123.140601)**, 140601 (2019).

[33] H. Leitch, N. Piccione, B. Bellomo, and G. De Chiara, Driven
quantum harmonic oscillators: A working medium for ther[mal machines, AVS Quantum Science](https://doi.org/10.1116/5.0072067) **4**, 012001 (2022).

[34] D. Grimmer, E. Brown, A. Kempf, R. B. Mann, and E. Martín[Martínez, Gaussian ancillary bombardment, Phys. Rev. A](https://doi.org/10.1103/PhysRevA.97.052120)
**97** [, 052120 (2018).](https://doi.org/10.1103/PhysRevA.97.052120)

[35] K. Hammam, H. Leitch, Y. Hassouni, and G. De Chiara, Exploiting coherence for quantum thermodynamic advantage,
[New Journal of Physics](https://doi.org/10.1088/1367-2630/aca49b) **24**, 113053 (2022).

[[36] F. Ciccarello, Collision models in quantum optics, Quantum](https://doi.org/doi:10.1515/qmetro-2017-0007)
[Measurements and Quantum Metrology](https://doi.org/doi:10.1515/qmetro-2017-0007) **4**, 53 (2017).

[37] A. L. Grimsmo, Time-delayed quantum feedback control,

Phys. Rev. Lett. **[115](https://doi.org/10.1103/PhysRevLett.115.060402)**, 060402 (2015).

[38] S. J. Whalen, A. L. Grimsmo, and H. J. Carmichael, Open
[quantum systems with delayed coherent feedback, Quan-](https://doi.org/10.1088/2058-9565/aa8331)
[tum Science and Technology](https://doi.org/10.1088/2058-9565/aa8331) **2**, 044008 (2017).



22


[39] H. Pichler and P. Zoller, Photonic circuits with time de[lays and quantum feedback, Phys. Rev. Lett.](https://doi.org/10.1103/PhysRevLett.116.093601) **116**, 093601
[(2016).](https://doi.org/10.1103/PhysRevLett.116.093601)

[40] K. A. Fischer, R. Trivedi, V. Ramasesh, I. Siddiqi, and
J. Vučković, Scattering into one-dimensional waveguides
[from a coherently-driven quantum-optical system, Quan-](https://doi.org/10.22331/q-2018-05-28-69)
tum **2** [, 69 (2018).](https://doi.org/10.22331/q-2018-05-28-69)

[41] K. Fischer, Derivation of the quantum-optical master equa[tion based on coarse-graining of time, Journal of Physics](https://doi.org/10.1088/2399-6528/aadaf8)
[Communications](https://doi.org/10.1088/2399-6528/aadaf8) **2**, 091001 (2018).

[42] D. Cilluffo, A. Carollo, S. Lorenzo, J. A. Gross, G. M. Palma,
and F. Ciccarello, Collisional picture of quantum optics with
giant emitters, Phys. Rev. Res. **2** [, 043070 (2020).](https://doi.org/10.1103/PhysRevResearch.2.043070)

[43] J. A. Gross, C. M. Caves, G. J. Milburn, and J. Combes, Qubit
models of weak continuous measurements: Markovian con[ditional and open-system dynamics, Quantum Science and](https://doi.org/10.1088/2058-9565/aaa39f)
Technology **[3](https://doi.org/10.1088/2058-9565/aaa39f)**, 024005 (2018).

[44] S. Seah, S. Nimmrichter, D. Grimmer, J. P. Santos,
V. Scarani, and G. T. Landi, Collisional quantum thermometry, Phys. Rev. Lett. **[123](https://doi.org/10.1103/PhysRevLett.123.180602)**, 180602 (2019).

[45] A. Shu, S. Seah, and V. Scarani, Surpassing the thermal
[cramér-rao bound with collisional thermometry, Phys. Rev.](https://doi.org/10.1103/PhysRevA.102.042417)
A **102** [, 042417 (2020).](https://doi.org/10.1103/PhysRevA.102.042417)

[46] C. Pellegrini and F. Petruccione, Non-Markovian quantum
[repeated interactions and measurements, J. Phys. A Math.](https://doi.org/10.1088/1751-8113/42/42/425304)
Theor. **42** [, 425304 (2009).](https://doi.org/10.1088/1751-8113/42/42/425304)

[47] Z.-X. Man, Y.-J. Xia, and R. Lo Franco, Validity of the Landauer principle and quantum memory effects via collisional
models, Phys. Rev. A **99** [, 042106 (2019).](https://doi.org/10.1103/PhysRevA.99.042106)

[48] S. Lorenzo, F. Ciccarello, G. M. Palma, and B. Vacchini,
Quantum non-Markovian piecewise dynamics from collision models, Open Syst. Inf. Dyn. **[24](https://doi.org/10.1142/S123016121740011X)**, 1740011 (2017).

[49] S. Lorenzo, F. Ciccarello, and G. M. Palma, Class of exact
memory-kernel master equations, Phys. Rev. A **[93](https://doi.org/10.1103/PhysRevA.93.052111)**, 052111
[(2016).](https://doi.org/10.1103/PhysRevA.93.052111)

[50] D. W. Berry, A. M. Childs, and R. Kothari, Hamiltonian simulation with nearly optimal dependence on all parameters, in
_[2015 IEEE 56th Annual Symposium on Foundations of Com-](https://doi.org/10.1109/FOCS.2015.54)_
_[puter Science](https://doi.org/10.1109/FOCS.2015.54)_ (2015) pp. 792–809.

[51] G. H. Low and I. L. Chuang, Optimal Hamiltonian simu[lation by quantum signal processing, Phys. Rev. Lett.](https://doi.org/10.1103/PhysRevLett.118.010501) **118**,
[010501 (2017).](https://doi.org/10.1103/PhysRevLett.118.010501)

[52] A. M. Childs, D. Maslov, Y. Nam, N. J. Ross, and Y. Su, Toward the first quantum simulation with quantum speedup,
[Proceedings of the National Academy of Sciences](https://doi.org/10.1073/pnas.1801723115) **115**, 9456
[(2018).](https://doi.org/10.1073/pnas.1801723115)

[53] A. M. Childs, Y. Su, M. C. Tran, N. Wiebe, and S. Zhu, Theory
[of Trotter error with commutator scaling, Physical Review](https://doi.org/10.1103/PhysRevX.11.011020)
X **11** [, 011020 (2021).](https://doi.org/10.1103/PhysRevX.11.011020)

[54] Z. Ding, X. Li, and L. Lin, Simulating open quantum systems
[using Hamiltonian simulations, PRX Quantum](https://doi.org/10.1103/PRXQuantum.5.020332) **5**, 020332
[(2024).](https://doi.org/10.1103/PRXQuantum.5.020332)

[55] M. Pocrnic, D. Segal, and N. Wiebe, Quantum simulation of Lindbladian dynamics via repeated interactions,
[arXiv:2312.05371 10.48550/arXiv.2312.05371 (2023).](https://doi.org/10.48550/arXiv.2312.05371)

[56] K. Wan, M. Berta, and E. T. Campbell, Randomized quan[tum algorithm for statistical phase estimation, Phys. Rev.](https://doi.org/10.1103/PhysRevLett.129.030503)
Lett. **129** [, 030503 (2022).](https://doi.org/10.1103/PhysRevLett.129.030503)

[57] S. Wang, S. McArdle, and M. Berta, Qubit-efficient random[ized quantum algorithms for linear algebra, PRX Quantum](https://doi.org/10.1103/PRXQuantum.5.020324)
**5** [, 020324 (2024).](https://doi.org/10.1103/PRXQuantum.5.020324)




[58] S. Chakraborty, Implementing any linear combination of
[unitaries on intermediate-term quantum computers, Quan-](https://doi.org/10.22331/q-2024-10-10-1496)
tum **8** [, 1496 (2024).](https://doi.org/10.22331/q-2024-10-10-1496)

[59] S. Aaronson and P. Rall, Quantum approximate counting,
simplified, in _[Symposium on simplicity in algorithms](https://doi.org/10.1137/1.9781611976014.5)_ (SIAM,
2020) pp. 24–32.

[60] D. Grinko, J. Gacon, C. Zoufal, and S. Woerner, Iterative
[quantum amplitude estimation, npj Quantum Information](https://doi.org/10.1038/s41534-021-00379-1)
**7** [, 52 (2021).](https://doi.org/10.1038/s41534-021-00379-1)

[61] E. Borras and M. Marvian, Quantum algorithm to simu[late lindblad master equations, Phys. Rev. Res.](https://doi.org/10.1103/PhysRevResearch.7.023076) **7**, 023076
[(2025).](https://doi.org/10.1103/PhysRevResearch.7.023076)

[62] S. Sachdev, _[Quantum Phase Transitions](https://doi.org/10.1017/CBO9780511973765)_, 2nd ed. (Cambridge
University Press, 2011).

[63] J. D. Watson and J. Watkins, Exponentially reduced circuit
depths using Trotter error mitigation, arXiv:2408.14385
[10.48550/arXiv.2408.14385 (2024).](https://doi.org/10.48550/arXiv.2408.14385)

[64] J. D. Watson, Randomly compiled quantum simulation
with exponentially reduced circuit depths, arXiv preprint
[arXiv:2411.04240 10.48550/arXiv.2411.04240 (2024).](https://doi.org/10.48550/arXiv.2411.04240)

[65] S. Chakraborty, S. Hazra, T. Li, C. Shao, X. Wang,
and Y. Zhang, Quantum singular value transformation without block encodings: Near-optimal complexity
with minimal ancilla, arXiv preprint arXiv:2504.02385
[10.48550/arXiv.2504.02385 (2025).](https://doi.org/10.48550/arXiv.2504.02385)

[66] J. Kato, K. Wada, K. Ito, and N. Yamamoto, Exponentially
accurate open quantum simulation via randomized dissipation with minimal ancilla, arXiv preprint arXiv:2412.19453
[10.48550/arXiv.2412.19453 (2024).](https://doi.org/10.48550/arXiv.2412.19453)

[67] X. Li and C. Wang, Succinct description and efficient sim[ulation of non-Markovian open quantum systems, Commu-](https://doi.org/10.1007/s00220-023-04638-4)
[nications in Mathematical Physics](https://doi.org/10.1007/s00220-023-04638-4) **401**, 147 (2023).

[68] D. W. Berry, A. M. Childs, Y. Su, X. Wang, and N. Wiebe,
Time-dependent Hamiltonian simulation with _L_ [1] -norm
scaling, Quantum **4** [, 254 (2020).](https://doi.org/10.22331/q-2020-04-20-254)

[69] Y.-H. Chen, A. Kalev, and I. Hen, Quantum algorithm for
time-dependent hamiltonian simulation by permutation expansion, PRX Quantum **2** [, 030342 (2021).](https://doi.org/10.1103/PRXQuantum.2.030342)

[70] J. Watkins, N. Wiebe, A. Roggero, and D. Lee, Timedependent hamiltonian simulation using discrete-clock constructions, PRX Quantum **5** [, 040316 (2024).](https://doi.org/10.1103/PRXQuantum.5.040316)

[71] D. Fang, D. Liu, and R. Sarkar, Time-dependent hamiltonian
simulation via magnus expansion: Algorithm and supercon[vergence, Communications in Mathematical Physics](https://doi.org/10.1007/s00220-025-05314-5) **406**, 1
[(2025).](https://doi.org/10.1007/s00220-025-05314-5)

[72] M. B. Ruskai, Inequalities for traces on von Neumann al[gebras, Communications in Mathematical Physics](https://doi.org/10.1007/BF01645523) **26**, 280
[(1972).](https://doi.org/10.1007/BF01645523)



23


# **Appendix**

In the Appendix, we provide a comprehensive list of mathematical symbols, an LCU decomposition of unitaries, prove
some results concerning distances between quantum states that we make use of in the main article, and formally demonstrate the correctness of Algorithm 3.


**Appendix A: List of mathematical symbols and variables**


TABLE A1. Consolidated list of mathematical symbols


**Symbol** **Definition** **Reference** **Symbol** **Definition** **Reference**


_n_ Number of qubits in the system    - _t_ Evolution time    

_ε_ Precision/additive accuracy    - _O_ some arbitrary Observable    

_g_ ( _n_ ) = _O_ ( _f_ ( _n_ )) Big O notation - _O_ �( _f_ ( _n_ )) Big O notation (hiding polylog factors) 

Tr[ _A_ ] Trace of operator _A_    - E[ _A_ ] Expectation value of operator _A_    

Pr[ _X_ ] Probability of event _X_    - _∥X∥p_ Schatten _p_ -norm of operator _X_    

_σ_ _j_ ( _X_ ) _j_ -th singular value of _X_   - _∥X∥_ Spectral norm of operator _X_   
_∥M ∥_ 1 _→_ 1 Induced 1-norm of superoperator  - _σ_ _[x]_ _,_ _σ_ _[y]_ _,_ _σ_ _[z]_ Pauli matrices  


**i** **i**


_σ_ _[±]_ Raising/lowering operators - _I_ Identity operator 


**i** **i**


~~_√_~~
_|_ 0 _⟩,_ _|_ 1 _⟩_ Computational basis states - _|_ + _⟩_ Plus state: ( _|_ 0 _⟩_ + _|_ 1 _⟩_ ) _/_



**i** **i**


2 


**i** **i**


_HS_ System Hilbert space Sec. III A _HE_ Environment Hilbert space Sec. III A

_HEj_ _j_ -th sub-environment Hilbert space Sec. III A _HS_ System Hamiltonian Eq. (1)

_HE j_ Hamiltonian of _j_ -th sub-environment Eq. (1) _HIj_ Interaction Hamiltonian for _j_ -th collision Eq. (1)

_H_ Total Hamiltonian Eq. (1) _H_ _j_ Total Hamiltonian for _j_ -th collision Eq. (2)


_H j_ Normalized Hamiltonian for _j_ -th collision Eq. (3) _m_ Number of sub-environments Sec. III A


_ρS_ State of the system Sec. III A _ρE j_ State of the _j_ -th sub-environment Sec. III A

_Pi,_ _j_ Pauli operators in Hamiltonian decomp. Eq. (2) _hi,_ _j_ Coefficients in Pauli decomposition Eq. (2)


_L j_ Number of terms in the total Hamiltonian _H_ _j_ Eq. (2) _L_ Maximum number of terms in _H_ _j_, across collisions Eq. (2)

_Lj_
_β j_ Total weight of the Pauli coefficients: ∑ _i_ =1 _[h][i][,]_ _[j]_ Eq. (2) _β_ Maximum weight: max _j β j_ Theorem 1

∆ _t_ Time duration of each collision Sec. III A _K_ Total number of collisions Sec. III A


_U_ _j_ Time evolution unitary for _j_ -th collision Eq. (3) _U_ - _j_ Approximate time evolution operator Eq. (7)

Φ _j_ _j_ -th collision map Definition 1 Φ� _j_ Approximate _j_ -th collision map Eq. (7)

_MK_ Markovian _K_ -collision map Definition 2 _M_ - _K_ Approx. Markovian _K_ -collision map Eq. (8)


_µ_ Algorithm output estimate Eq. (6) _U_  - LCU approximation of time evolution Eq. (20)


_αi_ LCU coefficients Eq. (20) _Wi_ LCU unitaries Eq. (20)


_α_ Total LCU weight: ∑ _i |αi|_ Lemma 2 _r_ LCU parameter to control the error Lemma 2

_q_ Taylor series truncation parameter Lemma 2 _X_ _j,Yj_ i.i.d. sampled unitaries in SA-LCU algorithm Eq. (25)

_X_ _j_ [(] _[c]_ [)] Controlled version of _X_ _j_ Eq. (26) _Yj_ [(] _[a]_ [)] Anti-controlled version of _Yj_ Eq. (26)

_D j_ Sampling ensemble Eq. (25) _α_ [(] _[j]_ [)] LCU weight for _j_ -th collision Algorithm 1

_ζ_ Product of LCU weights: ∏ _[K]_ _j_ =1 _[α]_ [(] _[j]_ [)] Algorithm 1 _T_ Number of classical repetitions Eq. (28)

_τd_ Circuit depth per coherent run Eq. (29) _τρE_ Max. circuit depth to prepare the environment in _ρE_ Eq. (29)

_τρEj_ Circuit depth for preparing _ρE j_ Eq. (29) _δ_ Failure probability Theorem 1

_L_ Lindbladian superoperator Eq. (45) _A_ _j_ Lindblad jump operators Eq. (45)


_ω_ Inverse temperature Eq. (46) _λ_ System-environment coupling Sec. IV


_ν_ Repetitions of collision sequence Def. 3 _Mm,ν_ ( _m,_ _ν_ )-collision map Def. 3


Γ Complexity parameter Eq. (50) _βS_ System Hamiltonian weight Sec. IV


_βIj_ Interaction Hamiltonian weight Sec. IV _βE j_ Environment Hamiltonian weight Sec. IV

_β_ max Maximum weight parameter Eq. (58) _LS_ Terms in system Hamiltonian Eq. (65)

_LIj_ Terms in interaction Hamiltonian Eq. (65) _Mz_ Avg. transverse magnetization Eq. (74)


_J_ Coupling strength in Ising model Eq. (72) _h_ Transverse magnetic field strength Eq. (72)


_γ_ Damping strength Eq. (73) _Ci,_ _j_ CPTP channel between sub-environments Eq. (77)


_S_ _j,_ _j_ +1 Swap operation between sub-environments Eq. (77) _p_ Swap probability parameter Eq. (77)

_US j_ System-environment collision unitary Eq. (78) _V j,_ _j_ +1 Environment-environment interaction Eq. (79)

Φ _[N]_ _j_ Non-Markovian collision map Eq. (80) _NK_ Non-Markovian _K_ -collision map Eq. (81)
Φ� _[N]_ _j_ Approx. non-Markovian collision map Eq. (82) _N_ - _K_ Approx. non-Markovian _K_ -collision map Eq. (83)


24


**Appendix B: LCU decomposition of Unitaries**


We provide an LCU decomposition of the time evolution operator, which we incorporate into the simulation of the
quantum collision models. This has been proven in Refs. [56–58], and we restate the result here for completeness.
Consider any Hamiltonian _H_ which is a convex combination of Pauli operators, i.e. _H_ = ∑ _[L]_ _l_ =1 _[p][l][P][l]_ [, where] _[ P][l]_ [ is a sequence]
of Pauli operators, and ∑ _l pl_ = 1. We decompose _e_ _[−][i][τ][H]_ as an approximate linear combination of unitaries, for which we
use ideas from the Truncated Taylor series method by Berry et al.[3], as well as the LCU decomposition of [56]. We can
write


                     _e_ _[−][i][τ][H]_ = _e_ _[−][iH][τ][/][r]_ [�] _[r]_ _,_ (A1)


where _r_ (to be selected later) is a parameter such that _r > t_ . If each segment _Sr_ = _e_ _[−][iH][τ][/][r]_ has an (approximate) LCU
decomposition ∑ _m cmUm_, such that _∥Sr −_ ∑ _m cmUm∥≤_ _ε/r_ then,

### S = ( Sr ) [r] = ∑ cm 1 cm 2 ··· cmrUm 1 Um 2 ···Umr = ∑ α jWj, (A2)

_m_ 1 _m_ 2 _···mr_ _j_


is _ε_ -close to _e_ _[−][iHt]_, i.e. �� _e−iHt −_ _S_ �� _≤_ _ε_ . First note that by truncating the _Sr_ = _e−iHτ/r_ to _q_ terms, we obtain



_S_ - _r_ =



_q_
### ∑

_k_ =0



( _−iτH/r_ ) _[k]_

_._ (A3)
_k_ !



Then by choosing some


we ensure that ��� _Sr −_ _S_ - _r_ ��� _≤_ _ε/r_ .




  - log( _r/ε_ )   _q_ = _O_ _,_ (A4)
loglog( _r/ε_ )



Now, we obtain the LCU decomposition of _S_ [�] _r_, similar in spirit to Ref. [56]. This gives us,



_S_ - _r_ =



_q_
### ∑

_k_ =0



( _−iτH/r_ ) _[k]_

(A5)
_k_ !




(A6)



=


=


=


=



_q_
### ∑

_k_ =0 _, k∈_ even


_q_
### ∑

_k_ =0 _, k∈_ even


_q_
### ∑

_k_ =0 _, k∈_ even


_q_
### ∑

_k_ =0 _, k∈_ even



1 _I −_ _[i][τ][H][/][r]_
_k_ ! [(] _[−][i][τ][H][/][r]_ [)] _[k]_ _k_ + 1



( _−iτ/r_ ) _[k]_


_k_ !




~~�~~ _τ/r_
1 +




- _L_
### ∑ pmPm

_m_ =1







 _I −_ _k_ _[i][τ]_ + _[/][r]_ 1




- _k_
_×_




- []

 (A7)



1

_k_ !




- _L_
### −iτ/r ∑ pℓPℓ

_ℓ_ =1



( _−iτ/r_ ) _[k]_ _L_ _L_
### × ∑ pℓ 1 pℓ 2 ··· pℓk Pℓ 1 Pℓ 2 ··· Pℓk × ∑ pm

_k_ ! _ℓ_ 1 _,ℓ_ 2 _,···ℓk_ =1 _m_ =1



_τ/r_ ) _[k]_ _L_ _L_
### × ∑ pℓ 1 pℓ 2 ··· pℓk Pℓ 1 Pℓ 2 ··· Pℓk × ∑ pm

_k_ ! _ℓ_ 1 _,ℓ_ 2 _,···ℓk_ =1 _m_ =1




_I −_ _[i][τ][P][m][/][r]_

_k_ + 1












~~�~~ _τ/r_
1 +

_k_ + 1




~~�~~ 2 _L_
### × ∑ pℓ 1 pℓ 2 ··· pℓk pmPℓ 1 Pℓ 2 ··· Pℓk e [−][i][θ][m][P][m], (A8)

_ℓ_ 1 _,ℓ_ 2 _,···ℓk,m_ =1



where _e_ _[−][i][θ][m][P][m]_ is a Pauli rotation operator, defined as follows:



1
_e_ _[i][θ][m][P][m]_ =

~~�~~




_I −_ _[i][τ][P][m][/][r]_

_k_ + 1




_,_ (A9)




~~�~~ _τ/r_
1 +




~~�~~ 2



_k_ + 1



such that








 - _τ/r_
1 +



_k_ + 1



_θm_ = arccos




 




�2 [�] _−_ 1 _/_ 2 []

 _._ (A10)



25


Thus, _S_ [�] _r_ = ∑ _j∈M c jU_ _j_, where the index set _M_ can be defined as


_M_ = _{_ ( _k,ℓ_ 1 _,ℓ_ 2 _,_ _···_ _ℓk,_ _m_ ) :

( _i_ ) 0 _≤_ _k ≤_ _K_ ;


( _ii_ ) _ℓ_ 1 _,ℓ_ 2 _,_ _···_ _ℓk,_ _m ∈{_ 1 _,_ 2 _,_ _···,_ _L}}._ (A11)


Also,




~~�~~ _τ/r_
1 +

_k_ + 1



_c_ _j_ = [(] _[τ][/][r]_ [)] _[k]_

_k_ !








~~�~~ 2
_pℓ_ 1 _pℓ_ 2 _··· pℓk pm,_ (A12)



while


The sum of the coefficients

### ∑ |c j| =

_j∈M_



_q_
### ∑

_k_ =0 _, k∈_ even



_U_ _j_ = ( _−i_ ) _[k]_ _Pℓ_ 1 _Pℓ_ 2 _···_ _Pℓk_ _e_ _[i][θ][m][P][m]_ _._ (A13)



( _τ/r_ ) _[k]_


_k_ !




~~�~~



_k_ + 1




~~�~~ _τ/r_
1 +




~~�~~ 2 _L_
### × ∑ pℓ 1 pℓ 2 ··· pℓk pm (A14)

_ℓ_ 1 _,ℓ_ 2 _,···ℓk,m_ =1



( _τ/r_ ) _[k]_


_k_ !


( _τ/r_ ) _[k]_


_k_ !










~~�~~ _τ/r_
1 +

_k_ + 1



=



_q_
### ∑

_k_ =0 _, k∈_ even




~~�~~ _τ/r_
1 +

_k_ + 1




~~�~~ _τ/r_
1 +




~~�~~ 2
(A15)


~~�~~ 2



∞
### ≤ ∑

_k_ =0 _, k∈_ even




~~�~~ _τ/r_
1 +




~~�~~ _τ/r_
1 +

2 _k_ + 1








~~�~~ 2
(A16)



∞
### = ∑

_k_ =0


∞
### ≤ ∑

_k_ =0



( _τ/r_ ) [2] _[k]_

(2 _k_ )!



( _τ/r_ ) [2] _[k]_

= _e_ _[τ]_ [2] _[/][r]_ [2] _._ (A17)
_k_ !



Finally, in order to write down _S_ as an LCU, we write _S_ = _S_ [�] _r_ _[r]_ [. That is,]


### = ∑ c 1 c 2 ··· crU j 1 U j 2 ···U jr = ∑ αmWm, (A18)

_j_ 1 _,_ _j_ 2 _,···_ _jr∈M_ _m_



 _r_






_S_ =





###  ∑ c jU j

_j∈M_



where _|α|_ = ∑ _m |αm|_ = (∑ _j∈M |c_ _j|_ ) _[r]_ _≤_ _e_ _[τ]_ [2] _[/][r]_ .


**Appendix C: Distances between quantum states**


In this section, we prove some results concerning the distance between operators/ CPTP maps applied to quantum
states. First, consider that there exist two operators _P_ and _Q_ such that _∥P_ _−_ _Q∥≤_ _γ_ . We demonstrate that the expectation
value of _O_ with respect to _PρP_ [†] is not far off from the expectation value of _O_ with respect to _QρQ_ [†], for any density matrix
_ρ_ . More precisely, we prove that

Tr[ _O PρP_ †] _−_ Tr[ _O QρQ_ †] _≤_ 3 _∥P∥∥O∥_ _γ._
��� ���


The result was proven in Refs. [58, 65], and we state this here for completeness. Let us recall the tracial version of
Hölder’s inequality, which is stated below for completeness:


**Lemma A5** (Tracial version of Hölder’s inequality [72]) **.** _Define two operators A and B and parameters p,_ _q ∈_ [1 _,_ ∞] _such_
_that_ 1 _/p_ + 1 _/q_ = 1 _. Then the following holds:_


Tr[ _A_ [†] _B_ ] _≤∥A∥p∥B∥q ._


26


Here _∥X∥p_ corresponds to the Schatten _p_ -norm of the operator _X_ . For the special case of _p_ = ∞ and _q_ = 1, the statement
of Lemma A5 can be rewritten as


Tr[ _A_ [†] _B_ ] = _∥A_ [†] _B∥_ 1 _≤∥A∥_ ∞ _∥B∥_ 1 = _∥A∥∥B∥_ 1 _._ (A1)


Now we are in a position to formally state the main result.


**Theorem A1.** _Suppose P and Q are operators such that ∥P_ _−_ _Q∥≤_ _γ for some γ ∈_ [0 _,_ 1] _. Furthermore, let ρ be any density_
_matrix and O be some Hermitian operator with spectral norm ∥O∥. Then, if ∥P∥≥_ 1 _, the following holds:_

Tr[ _O PρP_ †] _−_ Tr[ _O QρQ_ †] _≤_ 3 _∥O∥∥P∥_ _γ._
��� ���


_Proof._ Using Lemma A5 with _p_ = ∞ and _q_ = 1, we obtain


_|_ Tr[ _O PρP_ [†] ] _−_ Tr[ _O QρQ_ [†] ] _| ≤∥O∥·∥PρP_ [†] _−_ _QρQ_ [†] _∥_ 1 (A2)


For the second term in the RHS of the above equation, we can successively apply the tracial version of Hölder’s inequality
(Lemma A5 with _p_ = ∞ and _q_ = 1) the triangle inequality to obtain:


_PρP_          - _−_ _QρQ_          - = _PρP_          - _−_ _PρQ_          - + _PρQ_          - _−_ _QρQ_          - (A3)
���� ����1 ��� ���1

_≤∥Pρ∥_ 1 _∥P_ _−_ _Q∥_ + _∥P_ _−_ _Q∥∥ρQ∥_ 1 (A4)

_≤∥P∥∥P_ _−_ _Q∥_ + _∥Q∥∥P_ _−_ _Q∥_ [ As _∥ρ∥_ 1 = 1] (A5)

_≤_             - _∥P∥_ + _∥Q∥_             - _·∥P_ _−_ _Q∥_ (A6)


_≤_             - _∥P∥_ + _∥Q_ _−_ _P_ + _P∥_             - _·∥P_ _−_ _Q∥_ (A7)


_≤_             - _∥P∥_ + _∥P_ _−_ _Q∥_ + _∥P∥_             - _·∥P_ _−_ _Q∥_ (A8)

_≤_ 2 _∥P∥∥P_ _−_ _Q∥_ + _∥P_ _−_ _Q∥_ [2] _._ (A9)


Now, substituting this upper bound back in the RHS of Eq. (A2), we obtain


���Tr[ _O PρP_ †] _−_ Tr[ _O QρQ_ †]��� _≤_ �� _O_ ���� _P_ _−_ _Q_ ��2 + 2�� _O_ ���� _P_ ���� _P_ _−_ _Q_ �� (A10)


2
_≤_ �� _O_ ���� _P_ _−_ _Q_ �� + 2�� _O_ ���� _P_ ���� _P_ _−_ _Q_ ��

_≤_ _γ_ [2][��] _O_ �� + 2�� _O_ ���� _P_ �� _γ_

_≤_ 3 _γ_ �� _O_ ���� _P_ �� (A11)


Next, we bound the distance between two quantum states that have been transformed by a composition of two Completely Positive Trace Preserving (CPTP) maps. We have the following Lemma:


**Lemma A6** (Distance between quantum states obtained by applying a composition of CPTP maps) **.** _Let {Ai}_ _[K]_ _i_ =1 _[and]_
_{Bi}_ _[K]_ _i_ =1 _[be two sets of maps acting on any density operator][ ρ][, such that each][ A][i][ and][ B][i][ are CPTP maps. Assume that for all]_
_i ∈_ [1 _,_ _K_ ] _, the following bound holds:_

�� _Ai_ [ _ρ_ ] _−_ _Bi_ [ _ρ_ ]��1 _[≤]_ _[ε][.]_ (A12)


_Then, the compositions of these maps satisfy:_

��� _⃝Ki_ =1 _[A][i]_ [[] _[ρ]_ []] _[−⃝]_ _i_ _[K]_ =1 _[B][i]_ [[] _[ρ]_ []] ���1 _[≤]_ _[K][ε][.]_ (A13)


27


_Proof._ Expanding the composition, we write:
��� _⃝Ki_ =1 _[A][i]_ [[] _[ρ]_ []] _[−⃝]_ _i_ _[K]_ =1 _[B][i]_ [[] _[ρ]_ []] ���1 [=] �� _AKAK−_ 1 _..._ _A_ 1[ _ρ_ ] _−_ _BKBK−_ 1 _..._ _B_ 1[ _ρ_ ]��1 _[.]_ (A14)


Adding and subtracting intermediate terms iteratively, and using the triangle inequality, we obtain:

�� _AKAK−_ 1 _..._ _A_ 1[ _ρ_ ] _−_ _BKBK−_ 1 _..._ _B_ 1[ _ρ_ ]��1 _[≤]_ �� _AKAK−_ 1 _..._ _A_ 1[ _ρ_ ] _−_ _BKAK−_ 1 _..._ _A_ 1[ _ρ_ ]��1 [+]
�� _BKAK−_ 1 _..._ _A_ 1[ _ρ_ ] _−_ _BKBK−_ 1 _..._ _A_ 1[ _ρ_ ]��1 [+] _[···]_ [+]
�� _BK ..._ _B_ 2 _A_ 1[ _ρ_ ] _−_ _BK ..._ _B_ 2 _B_ 1[ _ρ_ ]��1 _[.]_ (A15)


Now, let _ρk_ _[A]_ [=] _[ ⃝]_ _i_ _[k]_ =1 _[A][i]_ [[] _[ρ]_ []][ and] _[ ρ]_ _k_ _[B]_ [=] _[ ⃝]_ _i_ _[k]_ =1 _[B][i]_ [[] _[ρ]_ []][, representing the intermediate states obtained after the application of] _[ k]_

maps. Then due to the initial assumption Eq. (A12)

_A_
��� _A_ _j_ [ _ρ_ _j−_ 1 []] _[−]_ _[B]_ _[j]_ [[] _[ρ]_ _[B]_ _j−_ 1 []] ���1 _[≤]_ _[ε]_ (A16)


Using the contractivity of completely positive maps,


_∥B_ _j_ +1 _A_ _j_ [ _ρ_ _[A]_ _j−_ 1 []] _[−]_ _[B]_ _[j]_ [+][1] _[B]_ _[j]_ [[] _[ρ]_ _[B]_ _j−_ 1 []] _[∥]_ [1] _[≤]_ _[ε][,]_ (A17)


Using this repeatedly, we bound each term on the right side of the Eq. (A15) by _ε_ . Thus, by summing the contributions
across all maps, we obtain:
��� _⃝Ki_ =1 _[A][i]_ [[] _[ρ]_ []] _[−⃝]_ _i_ _[K]_ =1 _[B][i]_ [[] _[ρ]_ []] ���1 _[≤]_ _[K][ε][.]_ (A18)


Now, consider two copies of the quantum state _ρ_, such that the CPTP map _A_ has been applied to one copy, while
another CPTP map _B_ has been applied to the second copy to obtain _A_ [ _ρ_ ] and _B_ [ _ρ_ ], respectively. Now consider unitaries
_U_ and _U_ such that they are close (in spectral norm). Then, we find the distance (1-norm) between the quantum states

[�]
obtained by applying _U_ to _A_ [ _ρ_ ], and _U_ [�] to _A_ [ _ρ_ ], via the following theorem:


**Theorem A2** (Distance between quantum states) **.** _Suppose U and_ _U are unitary while A, B are CPTP maps. Then for any_

[�]
_density operator ρ,_
��� _U A_ [ _ρ_ ] _U_                                     - _−U_                                     - _B_ [ _ρ_ ] _U_ �†���1 _[≤]_ [2] ��� _U −U_ ���� +�� _A_ [ _ρ_ ] _−_ _B_ [ _ρ_ ]��1 _[.]_


_Proof._ Using triangle inequality, and Tracial version of Hölder’s inequality (Lemma A5), we obtain
��� _U A_ [ _ρ_ ] _U_                      - _−U_                      - _B_ [ _ρ_ ] _U_ �†���1 _[≤]_ ��� _U A_ [ _ρ_ ] _U_                      - _−U A_ [ _ρ_ ] _U_ �†���1 [+] ��� _U A_ [ _ρ_ ] _U_ �† _−U_                      - _B_ [ _ρ_ ] _U_ �†���1 (A19)

_≤_ ��� _U A_ [ _ρ_ ] _U_             - _−U A_ [ _ρ_ ] _U_ �†���1 [+] ��� _U A_ [ _ρ_ ] _−U_             - _B_ [ _ρ_ ]���1 _[·]_ ���� _U_ ��� (A20)

= ��� _U A_ [ _ρ_ ] _U_             - _−U A_ [ _ρ_ ] _U_ �†���1 [+] ��� _U A_ [ _ρ_ ] _−U_             - _B_ [ _ρ_ ]���1 (A21)


For the first term in the RHS we can use Lemma A5 to obtain
��� _U A_ [ _ρ_ ] _U_                                        - _−U A_ [ _ρ_ ] _U_ �†���1 _[≤]_ �� _U A_ [ _ρ_ ]��1 _[·]_ ��� _U −U_ ���� (A22)

_≤∥U∥·_ �� _A_ [ _ρ_ ]��1 _[·]_ ��� _U −U_ ���� (A23)

_≤_ ��� _U −U_ ���� _._ (A24)


On the other hand, for the second term,
��� _U A_ [ _ρ_ ] _−U_                                  - _B_ [ _ρ_ ]���1 [=] ��� _U A_ [ _ρ_ ] _−U B_ [ _ρ_ ]+ _U B_ [ _ρ_ ] _−U_                                  - _B_ [ _ρ_ ]���1 _[.]_ (A25)


28


By using triangle inequality once again to the RHS, followed by Lemma A5, we obtain

��� _U A_ [ _ρ_ ] _−U_                                 - _B_ [ _ρ_ ]���1 _[≤∥][U][∥·]_ �� _A_ [ _ρ_ ] _−_ _B_ [ _ρ_ ]��1 [+] ��� _U −U_ ���� _·_ �� _B_ [ _ρ_ ]��1 (A26)

_≤_ �� _A_ [ _ρ_ ] _−_ _B_ [ _ρ_ ]��1 [+] ��� _U −U_ ���� _._ (A27)


So, overall, we have
��� _U A_ [ _ρ_ ] _U_                                     - _−U_                                     - _B_ [ _ρ_ ] _U_ �†���1 _[≤]_ [2] ��� _U −U_ ���� +�� _A_ [ _ρ_ ] _−_ _B_ [ _ρ_ ]��1 _[.]_


This completes the proof.


**Appendix D: Correctness of Algorithm 3**


In this section, we formally prove the correctness of the algorithm (Algorithm 3) for simulating non-Markovian collisions.


**Theorem A3.** _Let ε,_ _δ ∈_ (0 _,_ 1) _. Then, for ε_ _[′]_ = _ε/_ (6 _K∥O∥_ ) _, with probability at least_ 1 _−_ _δ_ _, Algorithm 3 outputs µ, such that_

�� _µ −_ Tr[ _O NK_ [ _ρS_ ]]�� _≤_ _ε,_


_using T repetitions of the circuit shown in Figure 5, where_







_T_ = _O_




_∥O∥_ [2] ln(2 _/δ_ )

_ε_ [2]



_._ (A1)



_Each such coherent run has a circuit depth of_


_τd_ = _O_                    - _β_ [2] _K_ [2] ∆ _t_ [2] log( _β_ _K∥O∥_ ∆ _t/ε_ )
loglog( _β_ _K∥O∥_ ∆ _t/ε_ ) [+] _[K][τ][ρ][E]_




(A2)



_where, β_ = max _j β j, and τρE_ = max _j τρE j, where τρE j is the circuit depth of the unitary preparing the sub-environment in the_
_state ρE_ _j_ _._


_Proof._ The proof is similar to Theorem 1. We first initialize the system and ancilla registers. Subsequently, we prepare the
first environment register and apply the operations _X_ 1 [(] _[c]_ [)] and _Y_ 1 [(] _[a]_ [)] obtained by sampling _X_ 1 and _Y_ 1 from _D_ 1. Additionally,
we also initialize another environment register that interacts with the first environment register via the partial swap
operation represented by the map _V_ 1 _,_ 2. After this interaction, the first environment register is traced out, leaving the
combined system, ancilla and the second environment registers in a state ready for subsequent interactions.
We define the map Φ _[N]_ _j_ [ (] _[PQ]_ [)] as:



Φ� _[N]_ _j_ [ (] _[PQ]_ [)] [ _._ ] _≡_




Tr _E j_


Tr _E j_




- _V j,_ _j_ +1 _P_ ( _._ _⊗_ _._ _⊗_ _ρE_ _j_ +1) _Q_ [†][��] _,_ j is odd


- _V j,_ _j_ +1 _P_ ( _._ _⊗_ _ρE_ _j_ +1 _⊗_ _._ ) _Q_ [†][��] _,_ j is even



(A3)



Here, the map Φ [�] _[N]_ _j_ [ (] _[PQ]_ [)] [ _._ ] represents applying operator _P_ from the left and _Q_ [†] from the right, then applying the interaction
between environment register followed by tracing out of the first (second) environment register _E_ _j_ if _j_ is odd (even).
Thus, the state of the combined system-ancilla register after the initial collision can succinctly be expressed as:







_ρ_ 1 = [1]

2







_|_ 0 _⟩⟨_ 0 _|⊗_ Φ _[N]_ 1 [ (] _[Y]_ [1] _[Y]_ [1][)] [ _ρS_ ]+ _|_ 0 _⟩⟨_ 1 _|⊗_ Φ1 _[N]_ [ (] _[Y]_ [1] _[X]_ [1][)] [ _ρS_ ]+ _|_ 1 _⟩⟨_ 0 _|⊗_ Φ1 _[N]_ [ (] _[X]_ [1] _[Y]_ [1][)] [ _ρS_ ]+ _|_ 1 _⟩⟨_ 1 _|⊗_ Φ _[N]_ 1 [ (] _[X]_ [1] _[X]_ [1][)] [ _ρS_ ]



_._



We use the definition of the controlled and anti-controlled operator to simplify the combined state of the system and
ancilla.


29


To continue the process, we perform the next collision step analogously. We apply the next set of unitaries (obtained
by sampling from _D_ 2), then we simulate the intra-environmental interaction by first initializing the next environment
register in the state _ρE_ 3 and interacting it with the previous environment and then tracing out the previous environment.
At this stage, the cross terms involving different operators, such as Φ2 _[N]_ [ (] _[Y]_ [2] _[Y]_ [2][)] Φ _[N]_ 1 [ (] _[X]_ [1] _[X]_ [1][)] vanish. Thus, after tracing out the
appropriate environment register, the state simplifies neatly to:







_ρ_ 2 = [1]

2



_ρ_ 2 = [1]



_|_ 0 _⟩⟨_ 0 _|⊗_ Φ _[N]_ 2 [ (] _[Y]_ [2] _[Y]_ [2][)] Φ _[N]_ 1 [ (] _[Y]_ [1] _[Y]_ [1][)] [ _ρS_ ]+ _|_ 0 _⟩⟨_ 1 _|⊗_ Φ2 _[N]_ [ (] _[Y]_ [2] _[X]_ [2][)] Φ1 _[N]_ [ (] _[Y]_ [1] _[X]_ [1][)] [ _ρS_ ]







+ _|_ 1 _⟩⟨_ 0 _|⊗_ Φ _[N]_ 2 [ (] _[X]_ [2] _[Y]_ [2][)] Φ1 _[N]_ [ (] _[X]_ [1] _[Y]_ [1][)] [ _ρS_ ]+ _|_ 1 _⟩⟨_ 1 _|⊗_ Φ _[N]_ 2 [ (] _[X]_ [2] _[X]_ [2][)] Φ _[N]_ 1 [ (] _[X]_ [1] _[X]_ [1][)] [ _ρS_ ]



(A4)



We continue this _K −_ 1 times, where in each step the mismatched terms will cancel out and we will be left with _K −_ 1
composition of the map as follows:



_ρK−_ 1 = [1]

2





_|_ 0 _⟩⟨_ 0 _|⊗⃝_ _[K]_ _j_ = _[−]_ 1 [1][Φ] _[N]_ _j_ [ (] _[YjYj]_ [)] [ _ρS_ ]+ _|_ 0 _⟩⟨_ 1 _|⊗⃝_ _[K]_ _j_ = _[−]_ 1 [1][Φ] _[N]_ _j_ [ (] _[YjXj]_ [)] [ _ρS_ ]




                     
+ _|_ 1 _⟩⟨_ 0 _|⊗⃝_ _[K]_ _j_ = _[−]_ 1 [1][Φ] _[N]_ _j_ [ (] _[XjYj]_ [)] [ _ρS_ ]+ _|_ 1 _⟩⟨_ 1 _|⊗⃝_ _[K]_ _j_ = _[−]_ 1 [1][Φ] _[N]_ _j_ [ (] _[XjXj]_ [)] [ _ρS_ ]



(A5)



For the last collision we apply the control and anti-control operators _XK_ [(] _[c]_ [)] and _YK_ [(] _[a]_ [)] and trace out the first (second)
environment register if _K_ is odd (even). Resulting in the final state to be




+ _|_ 0 _⟩⟨_ 1 _|⊗_ Tr _EK_




- - - _YK_ _⃝_ _[K]_ _j_ = _[−]_ 1 [1] [Φ] _[N]_ _j_ [ (] _[YjXj]_ [)] [ _ρS_ ] _XK_ [†]



_ρK_ = [1]

2





_|_ 0 _⟩⟨_ 0 _|⊗_ Tr _EK_




 - _YK_ - _⃝_ _[K]_ _j_ = _[−]_ 1 [1] [Φ] _[N]_ _j_ [ (] _[YjYj]_ [)] [ _ρS_ ] - _YK_ [†]




- - - - [�]
_XK_ _⃝_ _[K]_ _j_ = _[−]_ 1 [1] [Φ] _[N]_ _j_ [ (] _[XjXj]_ [)] [ _ρS_ ] _XK_ [†]




- _XK_ - _⃝_ _[K]_ _j_ = _[−]_ 1 [1] [Φ] _[N]_ _j_ [ (] _[XjYj]_ [)] [ _ρS_ ] - _YK_ [†]



+ _|_ 1 _⟩⟨_ 0 _|⊗_ Tr _EK_




+ _|_ 1 _⟩⟨_ 1 _|⊗_ Tr _EK_



(A6)



Finally, we measure the ancilla and system register with the observable _σ_ _[x]_ _⊗_ _O_ . This constitutes one run of Algorithm 3.
Now measuring the ancilla on _σ_ _[x]_, the first and last terms of Eq. (A6) disappear, and so, the output of the _k_ -th run,





_µk_ = [1] 2 [Tr]  _O_





Tr _EK_




- - - _YK_ _⃝_ _[K]_ _j_ = _[−]_ 1 [1] [Φ] _[N]_ _j_ [ (] _[YjXj]_ [)] [ _ρS_ ] _XK_ [†] + Tr _EK_




- - _YK_ _⃝_ _[K]_ _j_ = _[−]_ 1 [1] [Φ] _[N]_ _j_ [ (] _[YjXj]_ [)] [ _ρS_ ] _XK_ [†]




- [�]

 (A7)



Then, by the linearity of expectation, we have




- - _U_ - _SK_ _⃝_ _[K]_ _j_ = _[−]_ 1 [1] _j_ [[] _[ρ][S]_ []] _U_ - _S_ [†] _K_

[Φ][�] _[N]_




- [�]




    -    
= _ζ_ [1][2] [Tr] _ON_ [�] _K_ [ _ρS_ ] _,_ (A8)



E[ _µk_ ] = _ζ_ [1][2]





Tr _EK_



= [1]



where _ζ_ is as defined in Algorithm 3. Thus, the outcome of each run is a random variable that in expectation value
estimates the desired quantity (upto a multiplicative factor of 1 _/ζ_ [2] ).
Since the observable _O_ has eigenvalues bounded within [ _−∥O∥_ _,∥O∥_ ], each individual outcome _µk_ satisfies:


_−∥O∥_ _ζ_ [2] _≤_ _ζ_ [2] _µk ≤∥O∥_ _ζ_ [2] _._ (A9)


After performing the experiment for _T_ independent runs, we have a collection of random variables _{µk}_ _[T]_ _k_ =1 [. Then, from]
Hoeffding’s inequality,



_T_
### ∑ µk,

_k_ =1



_µ_ = _[ζ]_ [ 2]

_T_



_µ_ = _[ζ]_ [ 2]



satisfies




















    -     - [�]
 _µ −_ Tr _O_ _N_ [�] _K_ [ _ρS_ ] _≥_ _ε/_ 2
���� ���



_T_ _ε_ [2]

_−_



8 _ζ_ [4] _∥O∥_ [2]



Pr



 _≤_ 2exp



_._



30


Thus, with probability at least 1 _−_ _δ_,

                         ��� _µ −_ Tr _ON_ [�] _K_ [ _ρS_ ]���� _≤_ _ε/_ 2 _,_ (A10)


for

_T ≥_ [8] _[∥][O][∥]_ [2][ ln][(][2] _[/][δ]_ [)] _[ζ]_ [ 4] _._

_ε_ [2]


Now from the statement of the Lemma, for any _j ∈_ [1 _,_ _K_ ].

��� _U_ _j −U_                                                        - _j_ ��� _≤_ _ε_ _′_ = 6 _Kε∥O∥_ _[.]_


Then using Lemma 4 and the triangle inequality, we obtain

              -               - [�]               -               - [�]               -               -               -               - [�]
_µ −_ Tr _O NK_ [ _ρS_ ] _≤_ _µ −_ Tr _ON_ [�] _K_ [ _ρS_ ] + Tr _ON_ [�] _K_ [ _ρS_ ] _−_ Tr _ONK_ [ _ρS_ ] (A11)
���� ��� ���� ��� ���� ���


_≤_ _ε/_ 2 + _ε/_ 2 = _ε._ (A12)


In order to estimate the circuit depth of Algorithm 3 and the number of classical repetitions _T_, we need to find _ζ_ .
Analogous to the Theorem 1, we use the Lemma 2 for each collision unitary and choose the maximum repetitions to be
_r_ = _O_ ( _Kβ_ [2] ∆ _t_ [2] ), which ensure _ζ_ = _O_ (1) Consequently, the number of classical repetitions needed is







_T_ = _O_




_∥O∥_ [2] log(1 _/δ_ )

_ε_ [2]



_._ (A13)



Similarly, analogous to Theorem 1, for the appropriate choices of _r_ and _q_, we have the overall circuit depth per coherent
run as



_τd_ = _O_ - _β_ [2] _K_ [2] ∆ _t_ [2] log( _β_ _K∥O∥_ ∆ _t/ε_ )
loglog( _β_ _K∥O∥_ ∆ _t/ε_ ) [+] _[K][τ][ρ][E]_




_,_ (A14)



where the additive term _KτρE_ again appears as in each run of the circuit, on account of preparing the individual subenvironments, a total of _K_ times. This completes the proof.


31


